
Оглавление	
Оглавление	1
Функциональные требования	2
1	Онбординг (Lead Management)	2
2	Подсистема уведомлений (Notification Service)	4
3	Подсистема чата (Messaging)	6
4	Подсистема отчетности (Reporting & Analytics)	9
5	Табели	15
6	Подсистема рекомендаций по тренингу	16
7	Команды (pattern Command)	24
8	Оффлайн-режим (Offline-First Approach)	24
9	Архивация и восстановление записей	26
10	Аудит и журнал событий (Audit Log)	26
11	Файл настроек приложения	29
12	Интеграция с системами бухгалтерского учета	30
13	Сайт компании	35
Нефункциональные требования	39
14	Требования к технологическому стеку	39
15	Требования к таблицам	43
16	Требования к логированию приложения	43
17	Требования к безопасности	43
18	Требования к тестированию	46
19	Дополнительные требования	46
Архитектурные требования	46
20	Редакции продукта	46
Глоссарий	49



Функциональные требования

1 Онбординг (Lead Management)
1.1 Управление лидами
1-й способ холодного контакта. Потенциальный клиент оставляет заявку на сайте компании через контейнер "Составить заявку". Система автоматически создает запись в каталоге "Заявки (Лид-менеджмент)" (onboarding_client) и уведомляет дежурного менеджера.
2-й способ холодного контакта. Менеджер вручную создает запись в каталоге "Заявки" после телефонного разговора.
Менеджер связывается с лидом для консультации. Результаты общения фиксируются в поле "Примечание менеджера" карточки лида.
1.2 Активация учетной записи клиента
После достижения договоренности менеджер в карточке лида нажимает кнопку "Отправить приглашение".
1. Генерация приглашения: Система создает уникальную одноразовую ссылку-приглашение с JWT-токеном, содержащим id записи лида. Ссылка действительна 72 часа.
2. Отправка уведомления: Ссылка отправляется лиду по тому каналу связи, который был указан как предпочтительный (email или SMS). Текст уведомления настраивается администратором.
3. Завершение регистрации: Лид переходит по ссылке, попадает на защищенную страницу, где должен задать свой пароль для системы. Пароль должен соответствовать политике безопасности.
4. Создание клиента: После успешной установки пароля система в рамках одной транзакции:
o Создает полноценную учетную запись User с ролью "Клиент", используя данные из onboarding_client.
o Помечает запись в onboarding_client как is_client_created = true.
o Автоматически аутентифицирует пользователя в системе и перенаправляет его в личный кабинет.
5. Обработка просрочки: Если ссылка истекла, клиент должен обратиться к менеджеру для генерации новой.

1.3 Диаграмма состояний для онбординга

Пояснения к диаграмме и процессу
Ключевые состояния:
1. NewLead (Новая заявка): Начальное состояние. Заявка создана (через сайт или менеджером), но еще не взята в работу.
o Подсостояние «ОжиданиеОбработки»: Заявка в очереди на менеджера.
o Подсостояние «Обработка»: Менеджер активно работает с лидом (звонок, консультация).
2. Обработка: Менеджер связался с лидом, идет этап консультации.
o Подсостояние «Консультация»: Идет общение.
o Подсостояние «ОжиданиеРешения»: Менеджер ждет ответа от клиента или принимает решение.
3. Отклонена (Archived): Конечное состояние. Заявка неактивна (клиент не заинтересовался, не вышел на связь).
4. ПриглашениеОтправлено: Ключевое состояние. Менеджер подтвердил согласие клиента, система сгенерировала и отправила ссылку-приглашение.
o Подсостояние «ОжиданиеРегистрации»: Ссылка активна, система ждет действия от клиента.
o Подсостояние «Просрочено»: Ссылка истекла (прошло >72 часов). Требуется действие менеджера. Возможен вариант повторной отправки приглашения: создается новая ссылка с новым TTL, а старые инвалидируются.
5. АктивныйКлиент (Client Created): Конечное состояние, цель процесса. Лид успешно зарегистрировался в системе, учетная запись пользователя создана.
Ключевые события (переходы):
• "Менеджер отправляет новое приглашение" из состояния Просрочено позволяет повторно активировать заявку, не создавая новую запись.
• "Лид переходит по ссылке" — это автоматическое событие, инициируемое клиентом, которое запускает процесс регистрации и финального перехода в статус АктивныйКлиент.
• "Менеджер архивирует заявку" — это ручное действие менеджера для очистки базы от неактивных просроченных заявок.

2 Подсистема уведомлений (Notification Service)
Подсистема уведомлений отвечает за своевременную отправку сообщений пользователям через различные каналы связи (Email, SMS, Push) в соответствии с их настройками и бизнес-событиями системы.
2.1 Архитектура и общие требования
• Централизованный сервис: Уведомления должны обрабатываться единым сервисом (отдельным Dart-модулем), который получает события от системы и управляет очередью отправки.
• Шаблоны сообщений: Тексты уведомлений должны храниться в базе данных в виде шаблонов с возможностями подстановки переменных (например, {{client_name}}, {{training_time}}). Это позволит администратору изменять тексты без изменения кода.
• Очередь отправки (Queue): Для надежности отправка должна использовать очередь сообщений, чтобы избежать потери уведомлений при сбоях в работе внешних сервисов (SMTP, SMS-шлюз).
• Логирование: Отправка каждого уведомления должна фиксироваться в отдельной таблице.
2.2 Типы уведомлений (Бизнес-события)
Система должна отправлять уведомления при наступлении следующих событий:
1. Приглашение клиента:
o Событие: Менеджер нажал "Отправить приглашение" в карточке лида.
o Канал: Email или SMS (в зависимости от данных лида).
o Получатель: Потенциальный клиент (запись в onboarding_client).
o Содержание: Приветствие, уникальная ссылка для активации, инструкция.
2. Напоминание о занятии:
o Событие: За hourNotification часов до начала занятия.
o Триггер: Система проверяет расписание каждые 15 минут.
o Канал: Push-уведомление в приложении (основной), дублирование на Email (опционально, по настройкам пользователя).
o Получатель: Клиент, Тренер, Инструктор (привязанные к занятию).
o Содержание: Время занятия, название плана тренировок, ссылка на карточку занятия.
3. Изменение в расписании:
o Событие: Тренер или менеджер изменил время/дату занятия, отменил его.
o Канал: Push-уведомление, Email.
o Получатель: Клиент, Тренер, Инструктор.
o Содержание: Информация об изменении, старое и новое время.
4. Новое сообщение в чате:
o Событие: Пользователь отправил сообщение в чат (Peer-to-Peer или Broadcast).
o Канал: Push-уведомление.
o Получатель: Участник(и) чата, которые в данный момент не в приложении.
o Содержание: Имя отправителя и начало текста сообщения.
5. Системные уведомления для персонала:
o Событие: Поступление новой заявки с сайта (onboarding_client).
o Канал: Push-уведомление, Email.
o Получатель: Дежурный менеджер.
o Содержание: "Поступила новая заявка от [Имя]".
o Уведомления о необходимости обслуживания оборудования
o Предупреждения о конфликтах бронирования
o Напоминания о плановом ТО
2.3 Управление подписками (Пользовательские настройки)
Каждый пользователь (в дашборде "Настройки") должен иметь возможность независимо настраивать получение уведомлений:
• Общий переключатель: sendNotification (Вкл/Выкл все уведомления).
• Время напоминания о занятии: hourNotification (в часах).
• Каналы для разных событий: Отдельные переключатели для получения уведомлений по каналам:
o Push-уведомления (всегда Вкл, если не выключены на уровне ОС).
o Email-уведомления (опционально).
o SMS-уведомления (опционально, может быть платной услугой).
2.4 Технологический стек
- **Очередь задач:** Redis Queue или пакет dart_redis
- **Шаблоны сообщений:** PostgreSQL + Handlebars-подобный движок
- **Email отправка:** SMTP сервер (Postfix или внешний провайдер)
- **SMS отправка:** REST API российских SMS-шлюзов
- **Push-уведомления:** Firebase Cloud Messaging (FCM) для мобильных приложений
- **Веб-уведомления:** WebSocket + Service Worker

2.5 Компоненты системы
notification_service/
├── lib/
│   ├── notification_queue.dart    # Очередь уведомлений
│   ├── email_sender.dart         # Отправка email
│   ├── sms_sender.dart           # Отправка SMS
│   ├── push_sender.dart          # Push-уведомления
│   ├── template_engine.dart      # Шаблонизатор
│   └── webhook_sender.dart       # Webhook-уведомления
├── config/
│   ├── smtp_config.dart          # Настройки SMTP
│   └── sms_providers.dart        # Конфигурация SMS-шлюзов
└── workers/
    ├── email_worker.dart         # Воркер для email
    └── sms_worker.dart           # Воркер для SMS

3 Подсистема чата (Messaging)
Чат является критически важным инструментом коммуникации между всеми участниками процесса (клиентами, тренерами, инструкторами, менеджерами).
3.1 Функциональные требования
3.1.1 Типы чатов
Система должна поддерживать следующие типы бесед:
1. Личные сообщения (Peer-to-Peer):
o Между любыми двумя пользователями системы, у которых есть права на общение (например, клиент может писать своему тренеру, но не может писать другому клиенту, если это не разрешено настройками).
2. Групповые чаты (Broadcast / Group):
o Тренер → Его клиенты: Создается автоматически для каждого тренера с его клиентами.
o Инструктор → Его клиенты: Создается автоматически для каждого инструктора с его клиентами.
o Менеджер → Группа сотрудников/клиентов: Для объявлений.
o Возможность создания групповых чатов вручную (например, менеджером) с выбором участников.
3. Системные уведомления:
o Уведомления от системы (напоминания, изменения расписания)
o Broadcast сообщения от администрации

3.1.2 Базовый функционал
• Отправка сообщений:
o Текстовые сообщения.
o Поддержка вложений.
• История сообщений: Полная история переписки должна храниться и подгружаться при открытии чата (с пагинацией).
• Статусы сообщений:
o sent (отправлено), delivered (доставлено получателю), read (прочитано).
o В групповых чатах статус read должен отображаться в виде списка прочитавших (или количества).
• Индикаторы активности:
o Индикатор "онлайн" (зеленая точка) рядом с аватаром пользователя.
o Индикатор "печатает..." (is typing...) в реальном времени.
• Уведомления:
o Push-уведомления на устройство при новом сообщении, если пользователь не в активном чате.
o Звуковое оповещение (опционально, настраивается пользователем).
o Бейджи (цифры) на иконке чата в интерфейсе, указывающие на количество непрочитанных сообщений.
3.1.3 Управление чатами
• Список чатов: Интерфейс должен отображать список всех чатов пользователя, отсортированный по времени последнего сообщения.
o Для каждого чата в списке отображается: аватар/название, последнее сообщение (или вложение), время и бейдж непрочитанных.
• Поиск по чатам и сообщениям: Возможность быстрого поиска по названиям чатов и тексту сообщений.
• Архивация чатов: Возможность скрыть чат из основного списка без удаления истории.
3.1.4 Автоматическое создание чатов
• При назначении клиента тренеру → создается личный чат
• При создании группового занятия → создается групповой чат участников
• При найме нового сотрудника → добавляется в общие чаты филиала

3.2 Архитектура и техническая реализация
3.2.1 Технологический стек
• Backend: Dart сервер на Shelf/Dart Frog
• База данных: PostgreSQL 15+
• Real-time: WebSocket + Redis Pub/Sub
• Хранение файлов: Локальная файловая система
• Клиент: Flutter WebSocket client
3.2.2 Компоненты системы

// Структура серверной части чата
chat_server/
├── lib/
│   ├── websocket_server.dart    # WebSocket обработчик
│   ├── chat_service.dart        # Бизнес-логика чата
│   ├── message_repository.dart  # Работа с БД
│   └── redis_service.dart       # Pub/Sub для реального времени
├── config/
│   └── database.dart           # Конфигурация БД
└── bin/
    └── server.dart             # Точка входа

3.2.3 Таблицы чата
-- Таблица чатов
-- Таблица участников чата
-- Таблица сообщений
-- Таблица статусов сообщений (для отслеживания прочтения)

3.2.4 Алгоритмы и процессы
• Создание личного чата: Происходит автоматически при первой попытке отправить сообщение пользователю, если чата еще не существует.
• Доставка и прочтение:
1. Сообщение сохраняется в БД, ему присваивается статус sent.
2. Через Realtime канал оно мгновенно доставляется всем онлайн-участникам чата. В БД для них проставляется статус delivered.
3. Когда пользователь открывает чат, клиентское приложение отправляет команду на сервер о прочтении всех сообщений в этом чате. В БД проставляется статус read.
• Индикатор "печатает...": При начале ввода текста в поле сообщения клиент отправляет через Realtime событие typing_start в канал чата. При остановке или отправке сообщения — событие typing_stop.
3.3 Требования к интерфейсу (UI/UX)
• Экран списка чатов: Должен быть доступен с главного навигационного меню каждого дашборда.
• Экран чата:
o Шапка с названием чата и списком участников (для групповых).
o Область сообщений с группировкой по датам.
o Панель ввода сообщения с кнопкой отправки.
o На втором этапе: кнопка прикрепления файла.
• Контекстные меню: Должен быть реализован функционал "долгого нажатия" на сообщение для его копирования или пересылки (для администраторов/менеджеров).
3.4 Безопасность и контроль доступа
• Row Level Security (RLS): Должны быть настроены строгие политики RLS на все таблицы чатов. Пользователь может видеть и писать только в те чаты, участником которых он является.
• Валидация: Проверка прав пользователя на отправку сообщения в конкретный чат должна выполняться на стороне сервера перед сохранением сообщения.
• Модерация: На втором этапе рассмотреть возможность удаления сообщений для ролей Менеджер/Администратор.

4 Подсистема отчетности (Reporting & Analytics)
Подсистема отчетности предоставляет руководству и менеджерам инструмент для анализа эффективности фитнес-центра, сотрудников и бизнес-процессов на основе накопленных данных.
4.1 Аналитические группы
Аналитические группы предназначены для сегментации клиентов по различным критериям для целей:
• Маркетинг и рассылки
• Аналитика и отчетность
• Управление клиентской базой
• Финансовый контроль
4.1.1 Типы аналитических групп

enum AnalyticGroupType {
  corporate,      // Корпоративные клиенты
  demographic,    // Демографические (возраст, пол)
  financial,      // Финансовые (статус оплаты, тип абонемента)
  behavioral,     // Поведенческие (активность, посещаемость)
  custom          // Произвольные (ручное создание)
}

4.1.2 Модель данных

class AnalyticGroup {
  String id;
  String name;
  String description;
  AnalyticGroupType type;
  
  // АВТОМАТИЧЕСКОЕ ОБНОВЛЕНИЕ
  bool isAutoUpdate;           // true - группа автоматически обновляется по условиям
  List<GroupCondition> conditions; // Условия для автоматических групп
  
  // ДИНАМИЧЕСКИЙ СОСТАВ
  List<String> clientIds;      // Кэшированный список клиентов в группе
  DateTime lastUpdatedAt;      // Время последнего обновления
  
  // ДОПОЛНИТЕЛЬНЫЕ ДАННЫЕ
  Map<String, dynamic> metadata; // Дополнительные данные по типам
}

4.1.3 Условия для автоматических групп (GroupCondition)

class GroupCondition {
  String field;        // Поле для условия (например, 'age', 'subscription_type')
  String operator;     // Оператор ('equals', 'greater_than', 'less_than', 'contains')
  String value;        // Значение для сравнения
}

4.1.4 Правила аналитических групп

• Динамический состав - состав может обновляться автоматически по условиям
• Нет связи с тренировками - группы не участвуют в расписании занятий
• Для аналитики - используются в отчетах, рассылках, анализе
• Гибкая настройка - могут быть как автоматическими, так и ручными
4.1.5 Валидация аналитических групп
• Условия должны быть корректными и выполнимыми
• Для автоматических групп должен быть хотя бы один участник после обновления

4.1.6 Бизнес-процессы

• Автоматическое обновление: Система ежедневно пересчитывает состав автоматических групп
• Массовые операции: Рассылки, уведомления для всех участников группы
• Аналитика: Построение отчетов по сегментам клиентов
• Управление: Контроль задолженностей, работа с неактивными клиентами
4.1.7 Форма создания/редактирования аналитической группы

• Выбор типа группы
• Настройка условий для автоматических групп
• Ручной выбор участников для неавтоматических групп
• Настройка дополнительных параметров

4.1.8 Таблица аналитических групп (analytic_groups)

CREATE TABLE analytic_groups (
  id BIGSERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  type SMALLINT NOT NULL, -- 0:corporate, 1:demographic, 2:financial, 3:behavioral, 4:custom
  
  -- Автоматическое обновление
  is_auto_update BOOLEAN DEFAULT false,
  conditions JSONB, -- Условия для автоматических групп
  
  -- Метаданные
  metadata JSONB, -- Дополнительные данные
  
  -- Кэшированный состав
  client_ids_cache JSONB,
  last_updated_at TIMESTAMPTZ,
  
  -- Системные поля
  company_id BIGINT DEFAULT -1,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by BIGINT REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  archived_at TIMESTAMPTZ,
  archived_by BIGINT REFERENCES users(id)
);


4.2 Общие принципы отчетности
• Доступ на основе ролей: Отчеты доступны только пользователям с ролями Администратор и Менеджер. Уровень детализации данных может различаться (например, менеджер видит данные только по своим клиентам/тренерам, а администратор — по всему центру).
• Интерактивность: Отчеты должны быть интерактивными: с возможностью фильтрации, сортировки и детализации (drill-down). Например, клик на цифру "Количество занятий" открывает список этих занятий.
• Визуализация: Данные должны представляться в виде сводных таблиц, графиков (столбчатые, линейные, круговые) и дашбордов с KPI.
• Экспорт: Все отчеты должны поддерживать экспорт данных в форматы PDF (для печати и презентаций) и XLSX/CSV (для дальнейшего анализа в Excel).
4.3 Виды отчетов
4.3.1 Отчетность по клиентам
4.3.1.1 Отчет «Динамика клиентской базы»
o Цель: Анализ притока и оттока клиентов.
o Параметры: Период (месяц, квартал, год).
o Метрики:
• Новые клиенты (зарегистрировались за период).
• Активные клиенты (посетили хотя бы 1 занятие за период).
• Ушедшие клиенты (не были на занятиях последние N дней).
• Общее количество клиентов на конец периода.
• График: Динамика изменения этих показателей over time.
4.3.1.2 Отчет «Посещаемость и прогресс клиентов»
o Цель: Оценка вовлеченности и эффективности тренировок.
o Параметры: Период, конкретный клиент (опционально), тренер (опционально).
o Метрики:
• Общее количество проведенных занятий.
• Процент посещаемости от запланированных занятий.
• Среднее количество занятий в неделю на одного клиента.
• Динамика изменения веса, обхватов тела.
• Динамика потребленных и затраченных калорий (дефицит/профицит).
• Достижение целей (количество клиентов, достигших целевого веса за период).
4.3.2 Отчетность по сотрудникам
4.3.2.1 Отчет «Загрузка и эффективность тренеров»
o Цель: Оценка продуктивности и загруженности тренерского состава.
o Параметры: Период, конкретный тренер (опционально).
o Метрики:
• Общее количество проведенных занятий.
• Общее количество рабочих часов (по табелю).
• Количество прикрепленных клиентов (на начало и конец периода).
• Средний доход с клиента (если интегрировано с финансовой системой. Это вынесено за рамки данной системы и будет интегрироваться via API).
• Рейтинг тренера на основе отзывов клиентов (если функционал реализован).
• График: Сравнительная диаграмма загрузки тренеров.
4.3.2.2 Отчет «Табель учета рабочего времени» (Расширенная версия)
o Цель: Финальное подведение итогов для payroll (расчета заработной платы).
o Параметры: Расчетный период (например, с 1 по последнее число месяца).
o Метрики: По каждому сотруднику:
• Отработанные часы (суммировано из занятий).
• Количество проведенных индивидуальных/групповых занятий.
• Простои/опоздания (если ведется учет).
• Экспорт: Обязательный вывод в XLSX для бухгалтерии.
4.3.3 Отчетность по занятиям и расписанию
4.3.3.1 Отчет «Статистика занятий»
o Цель: Анализ популярности направлений и загрузки зала.
o Параметры: Период, тип занятия (индивидуальное/групповое), зал (если несколько).
o Метрики:
• Распределение занятий по типам (индив./групп.).
• Распределение занятий по планам тренировок (похудение, масса и т.д.).
• Процент отмененных/перенесенных занятий.
• Среднее количество участников в групповых занятиях.
• График: Загрузка зала по времени суток и дням недели.
4.3.4 Отчетность по помещениям и оборудованию
• Отчет по загрузке залов
• Анализ использования оборудования
• Отчет по затратам на обслуживание
4.3.5 Финансовая отчетность по центру (если интегрировано с кассой/оплатами)
4.3.5.1 Отчет «Выручка и платежи»
o Цель: Контроль финансовых потоков.
o Параметры: Период.
o Метрики:
• Общая выручка за период.
• Выручка по типам услуг (абонементы, разовые занятия, персональные тренировки).
• Количество оформленных абонементов.
• Динамика выручки (сравнение с предыдущим периодом).
• График: Круговая диаграмма структуры выручки.
4.4 Техническая реализация
4.4.1 Архитектура
• Источник данных: Все отчеты строятся на основе основной базы данных PostgreSQL (таблицы users, lessons, track_calories, anthropometry_start/finish и др.).
• Генерация отчетов: Для сложных отчетов с агрегацией данных рекомендуется использовать представления (Views) или материализованные представления (Materialized Views) в PostgreSQL для оптимизации производительности.
• API: Бэкенд должен предоставлять API-эндпоинты для получения данных отчетов в формате JSON, которые затем визуализируются на фронтенде.
o Пример эндпоинта: GET /api/reports/client_dynamics?start_date=2023-01-01&end_date=2023-12-31
4.4.2 Интерфейс генератора отчетов
• Дашборд «Аналитика» в интерфейсе Администратора/Менеджера.
• Левая панель: Древовидный список всех доступных отчетов.
• Центральная часть:
1. Панель параметров: Выбор периода, фильтров (тренер, клиент, тип занятия).
2. Область визуализации: Здесь отображаются графики и таблицы.
3. Панель инструментов: Кнопки "Обновить", "Экспорт в PDF", "Экспорт в Excel".
4.5 Пример технического задания для одного отчета
Отчет: «Динамика клиентской базы за период»
• Эндпоинт API: GET /api/reports/client_dynamics
• Параметры запроса (Query Parameters):
o start_date (обязательный)
o end_date (обязательный)
• Ответ (Response Body):
json
{
  "period": {"start": "2023-01-01", "end": "2023-12-31"},
  "metrics": {
    "new_clients": 150,
    "active_clients": 400,
    "churned_clients": 45,
    "total_clients_end": 1200
  },
  "chart_data": [
    {"month": "2023-01", "new": 10, "active": 350, "churned": 5, "total": 1000},
    {"month": "2023-02", "new": 15, "active": 370, "churned": 8, "total": 1007},
    ...
  ]
}
• Логика расчета на бэкенде:
o new_clients: COUNT пользователей с ролью 'client', у которых created_at входит в период.
o active_clients: COUNT уникальных user_id из таблицы lessons, где start_fact_at входит в период и complete = 'completed'.
o churned_clients: COUNT клиентов, у которых последнее занятие (MAX(start_fact_at)) было раньше, чем end_date - 30 days (или другой порог "ухода").
o total_clients_end: COUNT пользователей с ролью 'client' на дату end_date.


5 Табели
Табели составляются на сотрудников, имеющих время проведения занятий – тренерам и инструкторам.
Табели могут отображаться как на одного сотрудника, так и на группы (роли) и имеет 2 режима: одиночный и групповой.
Табель представляет собой дашборд "Табель" с элементами управления отображения и ListView времени занятий.
В дашборде «Табель» фильтр по умолчанию: archived_at IS NULL.
Администратор может включить «Показать архивных сотрудников».

1. Элементы управления:
• Выбор интервала времени. По умолчанию отображается начало текущего месяца и текущее число.
• Комбобокс "Вид сетки". Выбор разреза времени: день, неделя, месяц. По умолчанию – день. В зависимости от выбора вида сетки, формируются колонки с соответствующими заголовками, уточняющими время.
• Комбобокс "Сотрудники". Отображается только в групповом режиме. Осуществляет выбор групп сотрудников: все, тренеры, инструкторы. По умолчанию – все. 
• Экспорт. Осуществляется выбор экспорта в pdf, xlsx или csv и по кнопке "Экспорт", проводит экспорт в указанный каталог.

2. Режимы отображения табеля.
• Групповой. В левой колонке отображаются сотрудники, выбранные по значению комбобокса "Сотрудники", с общем временем по каждому и общем временем в последней строке "Всего". Далее по горизонтали отображаются колонки в зависимости от выбора комбобокса "Вид сетки". После клика по сотруднику, открывается одиночный режим.
• Одиночный. В этом режиме колонка сотрудника скрывается, ФИО сотрудника добавляется в шапку, так же добавляется колонка со всеми ФИО прикрепленными клиентами, с общем временем по каждому и общем временем в последней строке "Всего". После клика по клиенту, открывается окно "Занятия" клиента за выбранный интервал времени.

В клетках сетки табеля, по колонкам выбранного разреза, отображаются суммирующее фактическое время, полученное функцией подсчета времени занятий.

6 Подсистема рекомендаций по тренингу
Система реализует двухуровневую гибридную модель рекомендаций:
1. Core-ядро (автономное, оффлайн) — алгоритмическая система, работающая на основе данных БД и детерминированных правил. Обеспечивает базовые, безопасные рекомендации, всегда доступные независимо от подключения к внешним сервисам.
2. AI Enhancer (опциональный модуль) — внешний AI-сервис (DeepSeek, Yandex GPT и др.), который при наличии доступа обогащает рекомендации ядра персонализированными советами. Модуль реализован как отдельный опциональный компонент.
Процесс формирования рекомендаций (Core-ядро)
1. Сбор данных: Система анализирует антропометрию (anthropometry_fix, anthropometry_start), соматотип (по обхватам запястья и лодыжки), биоимпеданс (bioimpedance_start при наличии), цель и уровень подготовки клиента.
2. Анализ соматотипа: На основе значений wrist_circ и ankle_circ определяется вероятностный профиль телосложения (процентное соотношение Эктоморф/Мезоморф/Эндоморф) по правилам из каталога types_body_build.
3. Определение типа фигуры: По соотношениям обхватов плеч, талии и бедер вычисляется текущий тип фигуры: "Яблоко", "Груша", "Песочные часы", "Прямоугольник", "Перевернутый треугольник".
4. Качественная оценка: При наличии данных биоимпеданса система оценивает процент жира, мышечную массу и скорость метаболизма, добавляя качественные флаги ("высокий жир", "низкие мышцы", "медленный метаболизм").
5. Генерация рекомендации: На основе собранного "портрета" клиента система:
o Ищет наиболее подходящую запись в таблице готовых рекомендаций training_recommendations по совпадению типа фигуры, цели и уровня подготовки.
o При неполном совпадении или отсутствии записи формирует композитную рекомендацию на основе преобладающих факторов.
o Возвращает два варианта текста: детализированный для тренера (recommendation_text_trainer) и упрощённый для клиента (recommendation_text_client).
6.1 Архитектура алгоритма рекомендаций
Входные данные (от пользователя):
1. Константы: Пол, Возраст, Рост.
2. Генетические замеры (не меняются): Обхват запястья (wrist_circ), Обхват лодыжки (ankle_circ).
3. Текущие динамические замеры: Обхват плеч (shoulders_circ), груди (breast_circ), талии (waist_circ), бедер (hips_circ).
4. Данные биоимпеданса (если есть): Процент жира (fat_percentage), мышечная масса (muscle_mass), скорость основного обмена (BMR).


Рисунок алгоритма рекомендаций

Пояснения к алгоритму
Шаг 1: Определение соматотипа (Вероятностный, генетический профиль).
• Что анализируется: Обхват запястья и лодыжки + пол пользователя.
• Как работает: Система сравнивает замеры с таблицей types_body_build.
• Результат: Вероятностный профиль (например: "Эктоморф: 15%, Мезоморф: 80%, Эндоморф: 5%").
• Особенность: Учитывает генетическую предрасположенность, которая не меняется при тренировках.

• Основа: Данные клиента (пол, wrist_circ, ankle_circ) сверяются с правилами в каталоге "Типы телосложения " (таблица types_body_build).
• Логика:
1. Для каждого типа телосложения (Эктоморф, Мезоморф, Эндоморф) из каталога, подходящего по полу клиента, система рассчитывает балл близости.
2. Расчет балла для запястья:
• Если wrist_circ меньше wrist_min, балл = 0.
• Если wrist_circ между wrist_min и rule_wrist_max, балл = 100 (полное соответствие).
• Если wrist_circ больше wrist_max, балл линейно убывает от 100 до 0 на интервале от wrist_max до (wrist_max + 2 см).
3. Аналогично рассчитывается балл для лодыжки на основе ankle_circ, ankle_min, ankle_max.
4. Итоговый балл по типу = среднее арифметическое баллов для запястья и лодыжки. Если данные для лодыжки отсутствуют, используется только балл для запястья.
5. Система выполняет п.2-4 для всех трех типов.
6. Результат: Формируется профиль вида { "Эктоморф": 25, "Мезоморф": 70, "Эндоморф": 5 }, где значения - процент принадлежности (сумма процентов равна 100 после нормализации).
Шаг 2: Определение Типа Фигуры (Текущий, динамический силуэт).
• Что анализируется: Соотношение обхватов плеч, талии и бедер.
• Как работает: Математический расчет пропорций по четким правилам.
• Результат: Один из типов: "Яблоко", "Груша", "Песочные часы", "Прямоугольник", "Перевернутый треугольник".
• Особенность: Показывает текущее состояние тела, которое можно изменить.
• Основа: Обхват плеч (shoulders_circ), талии (waist_circ), бедер (hips_circ).
• Логика: Алгоритм вычисляет соотношения.
o IF (waist_circ / hips_circ >= 0.85 AND waist_circ > shoulders_circ AND waist_circ > hips_circ) THEN bodytype = 'Яблоко' (Apple).
o IF (hips_circ > shoulders_circ * 1.05) THEN bodytype = 'Груша' (Pear).
o IF (ABS(shoulders_circ - hips_circ) < 0.05 AND (waist_circ / shoulders_circ) < 0.75) THEN bodytype = 'Песочные часы' (Hourglass).
o IF (ABS(shoulders_circ - hips_circ) < 0.05 AND (waist_circ / shoulders_circ) >= 0.75) THEN bodytype = 'Прямоугольник' (Rectangle).
o IF (shoulders_circ > hips_circ * 1.05) THEN bodytype = 'Перевернутый треугольник' (Inverted Triangle).
Шаг 3: Уточнение через Биоимпеданс (Качество состава тела).
• Что анализируется: Процент жира, мышечная масса, скорость метаболизма.
• Как работает: Оценка качества тела относительно здоровых норм.
• Результат: Флаги качества ("высокий жир", "низкие мышцы", "медленный метаболизм").
• Особенность: Дает качественную оценку состава тела.

• Основа: Процент жира (fat_percentage), мышечная масса (muscle_mass), BMR.
• Логика: Алгоритм добавляет "качественную" оценку.
o Фактор ожирения: IF (fat_percentage > max_healthy_for_age_gender) THEN flag = 'high_fat'.
o Фактор худобы: IF (fat_percentage < min_healthy_for_age_gender AND muscle_mass < average) THEN flag = 'low_muscle'.
o Фактор метаболизма: IF (BMR > calculated_average_BMR * 1.1) THEN metabolism = 'fast' ELSE IF (BMR < calculated_average_BMR * 0.9) THEN metabolism = 'slow'.

Шаг 4: Комплексный анализ и вывод рекомендаций
Процесс объединения:
• Система собирает данные всех трех этапов.
• Создает комплексный "портрет" пользователя.
• Учитывает как генетику, так и текущее состояние.
Пример портрета:
• Генетика: Преимущественно мезоморф (70%) с небольшой склонностью к эндоморфу (25%).
• Фигура: "Яблоко" (скопление жира в области талии).
• Качество: Высокий процент жира, нормальные мышцы, медленный метаболизм.

• Основа: Комбинация всех полученных данных: профиль соматотипа  + bodytype + flags + metabolism.
• Логика поиска в БД:
1. Система ищет в таблице training_recommendations записи, соответствующие bodytype, goal_training_id, level_training_id.
2. Если найдено несколько записей, приоритет отдается той, которая лучше всего подходит для преобладающего соматотипа из профиля клиента.
3. Если точного совпадения нет, система формирует композитную рекомендацию. Например, если профиль клиента {"Мезоморф": 60, "Эндоморф": 40}, итоговая рекомендация может быть: "На 60% используй стратегию для мезоморфа, на 40% - стратегию для эндоморфа, уделяя внимание ...".

• Учет смешанных типов для ИИ: Сформированный профиль соматотипа и все остальные данные передаются ИИ как есть. Это позволяет ИИ генерировать truly персонализированные рекомендации, учитывающие смешанную природу телосложения пользователя.

Таблица training_recommendations (Рекомендации по тренировкам)
• body_type// тип фигуры.
• goal_training_id; // из таблицы Цели тренировок.
• level_trainig_id; //из таблицы Уровень подготовки.
• recommendation_text_trainer // Текст рекомендации для тренера.
• recommendation_text_client // Текст рекомендации для клиента.

6.2 Рекомендации на основе ИИ 
AI-обогащение (опционально)
1. При наличии настройки use_ai_recommendations = true и доступности внешнего AI-сервиса:
2. Система отправляет AI-модулю структурированный "портрет" клиента (результаты анализа ядра + исходные данные).
3. AI-модель выступает в роли эксперта-тренера, персонализируя и дополняя базовую рекомендацию:
o Предлагает конкретные упражнения с учётом смешанного типа телосложения.
o Даёт советы по питанию и восстановлению.
o Объясняет рекомендации простым языком.
Алгоритмы и таблица: Формируют структурированный, проверенный и безопасный каркас рекомендаций. Новая вероятностная модель обеспечивает гораздо более высокую точность для пользователей со смешанным типом телосложения.
ИИ-модель (LLM DeepSeek): Выступает как "креативный ассистент-эксперт", который:
• Персонализирует стандартные рекомендации под уникальный, в том числе смешанный, кейс на основе переданного профиля.
• Генерирует конкретные примеры, учитывающие нюансы смешанного типа (например, "так как у вас есть склонность к эндоморфу, несмотря на мезоморфную основу, рекомендуем...").
• Объясняет сложные концепции простым языком.
Обновленный Пример Промпта (Запроса) для ИИ:
Ты - опытный персональный тренер и диетолог с 10-летним опытом. 
Генерируй персонализированные рекомендации по тренировкам и питанию.

ОГРАНИЧЕНИЯ И ПРАВИЛА:
1. НЕ давай медицинских рекомендаций и диагнозов
2. НЕ предлагай добавки и фармакологию
3. НЕ создавай экстремальные диеты (менее 1200 ккал/день)
4. Призывай консультироваться с врачом при проблемах со здоровьем
5. Используй только научно-доказанные методы
6. Учитывай российские пищевые привычки и доступность продуктов
ДАННЫЕ ПОЛЬЗОВАТЕЛЯ:
- Пол: {пол}
- Возраст: {возраст}
- Цель: {цель_из_таблицы}
- Опыт тренировок: {уровень}
- Генетический профиль телосложения (соматотип): {рассчитанный_профиль_соматотипа} // Напр.: "Эктоморф: 15%, Мезоморф: 80%, Эндоморф: 5%"
- Актуальный тип фигуры: {тип_фигуры}
- Биоимпеданс: процент жира - {процент_жира}, мышечная масса - {мышцы}, скорость метаболизма - {BMR}.
- Основная рекомендация из нашей базы данных: "{базовая_рекомендация_из_БД}"
ОСОБОЕ ВНИМАНИЕ: Учти, что у пользователя смешанный тип телосложения. Сгенерируй рекомендации, которые объединят подходы для его преобладающего типа, но скорректируют их с учетом влияния второстепенных типов.
СФОРМУЛИРУЙ РЕКОМЕНДАЦИИ:
1. Тренировки: Предложи 2-3 конкретных упражнения, которые особенно эффективны для этого сочетания типов и цели. Объясни, почему они подходят именно для его смешанного профиля.
2. Питание: Дай совет по балансу БЖУ и калорийности, учитывающий его метаболизм и генетические склонности.
3. Образ жизни: Дай 1-2 совета по восстановлению.
4. Предупреждение: Укажи на главную ошибку, которую ему стоит избегать, исходя из его профиля.
Тон: поддерживающий, мотивирующий, профессиональный, но без сложного жаргона.
6.3 Интеграция в интерфейс
• Доступ к рекомендациям осуществляется через кнопку "Получить рекомендации" в окне "Антропометрия" клиентского дашборда.
• При нажатии открывается модальное окно "Персональные рекомендации", содержащее:
o Базовые рекомендации (из ядра системы)
o AI-обогащённые рекомендации (при наличии)
o Кнопку "Улучшить с помощью AI" для повторного запроса к AI-сервису
• Для ролей Тренер и Менеджер рекомендации также доступны в карточке клиента, с отображением детализированной версии (recommendation_text_trainer).


7 Команды (pattern Command)
Команда реализует паттерн Command. Каждая команда должна иметь спецификацию. Команда должна иметь полную логику действий – в случае нескольких операций, не разбивать их на подкоманды, а выполнять все операции в одной команде, заключая их в блоки try-catch.

Каждая команда реализует интерфейс Command<T> с методом
Future<Result<T, String>> execute();

• Команда не знает о слое UI и не возвращает виджеты.
• Все входные данные передаются через конструктор и не изменяются после создания.
• Команда логирует начало, успешное завершение и ошибку уровня INFO / ERROR.
• В случае исключения, команда перехватывает его и возвращает Failure.

Все команды, имеющие бизнес-сценарии, должны быть задачами бэкенд-API.

8 Оффлайн-режим (Offline-First Approach)
8.1 Цель и Область применения
Система должна быть способна функционировать с ограниченным или полностью отсутствующим интернет-соединением для выполнения критически важных бизнес-процессов. Основной фокус — на мобильном приложении для ролей Тренер и Инструктор, которые работают непосредственно в зале, где связь может быть нестабильной.
8.2 Архитектура оффлайн-работы
• Стратегия: Offline-First. Приложение по умолчанию пытается сохранять данные локально, а затем синхронизировать их с сервером при наличии соединения.
• Локальное хранилище: Использование Hive или Sembast для быстрого и надежного локального хранения структурированных данных.
• Механизм синхронизации: Фоновая синхронизация при восстановлении соединения с использованием очереди (queue) отложенных запросов.
8.3 Функциональность, доступная оффлайн
Для Тренера/Инструктора:
• Просмотр расписания: Доступ к расписанию на текущий и следующий день.
• Просмотр карточек клиентов: Основная информация, актуальные планы тренировок, последние замеры.
• Фиксация занятий:
o Отметка начала и окончания занятия (start_fact_at, finish_fact_at).
o Ввод фактических параметров занятия (примечания, изменение упражнений "на лету").
o Ввод weight и calories_in для клиента после занятия.
• Работа с чатом: Просмотр истории чатов, отправка сообщений (доставляются при появлении сети).
Для Клиента:
• Просмотр своего расписания и деталей ближайшего занятия.
• Просмотр своего дневника калорий и прогресса.
• Ввод данных о потребленных калориях и весе.
8.4 Процесс синхронизации
1. Обнаружение сети: Приложение автоматически определяет восстановление стабильного интернет-соединения.
2. Выполнение очереди:
o Данные, созданные или измененные оффлайн, помещаются в специальную таблицу pending_sync_operations (локально).
o При появлении сети система последовательно отправляет эти данные на сервер.
3. Разрешение конфликтов:
o Стратегия: "Последнее изменение побеждает" (Last Write Wins - LWW) на основе меток времени updated_at.
o Если конфликт не может быть разрешен автоматически (например, изменение одних и тех же данных разными пользователями оффлайн), запись помечается как требующая ручного разрешения администратором/менеджером.
8.5 Ограничения оффлайн-режима
• Невозможно оффлайн:
o Первоначальная регистрация и вход в систему (требует аутентификации).
o Составление нового расписания.
o Генерация сложных отчетов.
o Получение онлайн-рекомендаций от ИИ.
o Работа с каталогами (создание/редактирование шаблонов упражнений).
• Уведомления: Push-уведомления не доставляются оффлайн. Локальные уведомления (напоминания о начале занятия) работают.
8.6 Требования к данным
• Кэширование при запуске: При наличии сети приложение заранее кэширует данные, необходимые для работы в течение дня:
o Активное расписание пользователя.
o Карточки прикрепленных клиентов (тренеру).
o Активные планы тренировок.
o Последние сообщения в чатах.
• Политика устаревания кэша: Локальные данные считаются актуальными в течение 24 часов. При попытке работы с устаревшим кэшем система показывает предупреждение.
8.7 Пользовательский интерфейс
• Индикатор статуса: В верхней части интерфейса всегда отображается значок:
o Зеленый / "Online" — стабильное соединение.
o Желтый / "Синхронизация..." — идет процесс синхронизации.
o Красный / "Оффлайн" — соединение отсутствует.
• Уведомления: При отправке данных в оффлайне появляется сообщение "Сообщение будет отправлено при подключении к сети". После успешной синхронизации — "Все данные синхронизированы".
8.8 Техническая реализация
dart
// Примерная структура очереди синхронизации
class PendingSyncOperation {
  String id;
  String tableName; // 'lessons', 'track_calories', etc.
  String operation; // 'INSERT', 'UPDATE'
  Map<String, dynamic> data;
  DateTime timestamp;
  int retryCount;
}

9 Архивация и восстановление записей
1. В каждой таблице обязательно присутствуют два служебных поля:
archived_at timestamp with time zone NULL – дата/время архивации;
archived_by bigint NULL – ссылка на users(id), кто архивировал.
NULL в обоих полях означает «запись активна».
2. Архивация выполняется командой ArchiveEntityCommand (паттерн Command), которая:
проверяет право «Архивировать» у текущей роли;
заполняет archived_at = now(), archived_by = current_user_id;
пишет запись в audit_log (действие = ‘ARCHIVE’).
3. Восстановление – командой RestoreEntityCommand, которая:
сбрасывает archived_at и archived_by в NULL;
пишет в audit_log действие ‘RESTORE’.
4. На всех таблицах создаётся RLS-политика (или эквивалентный механизм БД):
sql 
USING (archived_at IS NULL)
Политика действует для ролей «Клиент», «Инструктор», «Тренер», «Менеджер».
Роль «Администратор» видит записи без ограничений.
5. Списочные формы по умолчанию не выводят архивные строки. Чек-бокс «Показать архивные» добавляет условие archived_at IS NOT NULL.
6. Экспорт/отчёты/API-методы, не предназначенные для администратора, автоматически фильтруют archived_at IS NULL.
7. Физическое удаление (DELETE) запрещено; используется только логическое удаление через архивацию.


10 Аудит и журнал событий (Audit Log)
1. Цель
Обеспечить полную прослеживаемость изменений любых данных системы (клиенты, сотрудники, расписания, справочники, архивация/восстановление) без физического хранения версий строк.
2. Единая таблица аудита
Создаётся одна таблица на всю БД:
sql 
CREATE TABLE audit_log (
id            bigserial PRIMARY KEY,
table_name    text      NOT NULL,                       -- имя таблицы-источника
row_pk        bigint    NOT NULL,                       -- PK изменённой строки
action        text      NOT NULL CHECK (action IN (
 'INSERT','UPDATE','DELETE','ARCHIVE','RESTORE')),
changed_at    timestamptz DEFAULT now(),
changed_by    uuid      REFERENCES users(id),
old_values    jsonb,                                    -- предыдущие значения (NULL при INSERT)
new_values    jsonb                                     -- новые значения (NULL при DELETE)
);
3. Триггеры
Для каждой таблицы автоматически создаются триггеры AFTER INSERT, AFTER UPDATE, AFTER DELETE (через миграцию или генератор кода).
Триггер:
заполняет table_name = TG_TABLE_NAME,
row_pk = NEW.id / OLD.id,
action по типу операции,
changed_by = current_user_id() (из RLS-сессии),
old_values = to_jsonb(OLD), new_values = to_jsonb(NEW).
При архивации/восстановлении (команды ArchiveEntityCommand / RestoreEntityCommand) триггер фиксирует action = 'ARCHIVE' или 'RESTORE'.
4. Доступ к журналу
• Просмотр аудита доступен только роли Администратор.
• В карточке любой сущности кнопка «История» открывает список записей audit_log отфильтрованных по table_name + row_pk, отсортированных по changed_at DESC.
• Для удобства чтения поля old_values/new_values отображаются в виде сворачиваемого JSON-дерева; значения дат/чисел форматируются по текущей локали.
5. Хранение и ротация
Строки хранятся 36 месяцев.
Ежедневным cron-Job (pg_cron или внешний планировщик) удаляются записи старше 36 мес:
sql 
DELETE FROM audit_log WHERE changed_at < now() - interval '36 months';
6. Производительность
Индексы:
(table_name, row_pk, changed_at DESC) – быстрая выборка истории строки.
(changed_at) – быстрая чистка старых данных.
Триггеры объявляются FOR EACH ROW, но только при первичной записи (без каскадных UPDATE-ов) чтобы избежать рекурсии.
7. Интерфейс
• Списочная форма «Аудит» (доступна только администратору): фильтры по периоду, таблице, пользователю, типу действия; экспорт в CSV/XLSX.
• Виджет «Последние изменения» на дашборде администратора: 10 последних записей системы.
8. Безопасность
• Таблица audit_log не подлежит архивации (archived_at не добавляется).
• Прямое изменение/удаление строк audit_log запрещено триггером BEFORE DELETE / UPDATE (только SELECT и INSERT).
• Маскировка чувствительных данных: перед записью в new_values/old_values поля password_hash, sms_code, jwt_refresh_token обнуляются ('::text = '***').


11 Файл настроек приложения
Файл настроек приложения должен быть типовым средством фреймворка технологического стека. В файле должны содержаться следующие ключи:
Контактный телефон (contactPhone).
• E-mail (contactEmail).
• Посылать уведомления (sendNotification).
• Уведомление до начала занятий (часов) (hourNotification).
• SMS-шлюз (smsGate).
• Роль инструктора (roleInstructor). Включение и отключение (по умолчанию) роли инструктора.
• Роль менеджера (roleManager). Включение (по умолчанию) и отключение роли менеджера.
• Учет калорий (trackCalories). Включение (по умолчанию) и отключение функционала учета калорий клиентов.

• Текст приглашения для клиента (invitationText).
• Время жизни ссылки-приглашения (часы) (invitationLinkTTL).
• SMTP-хост (smtpHost).
• SMTP-порт (smtpPort).
• SMTP-логин (smtpLogin).
• SMS-шлюз URL (smsGateUrl).
   
   Файл настроек доступен только администратору.



12 
Интеграция с системами бухгалтерского учета
Данный раздел описывает архитектуру, механизмы и требования к интеграции системы «Фитнес-менеджер» с внешними бухгалтерскими и финансовыми системами на примере типовой интеграции с «1С:Предприятие».
Интеграция обеспечивает двусторонний обмен ключевыми бизнес-данными для автоматизации учёта клиентов, платежей, абонементов и посещений.
12.1 Общие положения
Цель интеграции:
Автоматизация передачи финансово-учётных данных между FitMan и бухгалтерской системой для исключения ручного ввода, минимизации ошибок и обеспечения актуальности данных в обеих системах.
Основные принципы:
• Двусторонняя синхронизация: Данные могут передаваться как из FitMan в 1С, так и в обратном направлении (например, обновление реквизитов клиента).
• Поддержка различных конфигураций 1С: Интеграция должна быть гибкой и настраиваемой под типовые конфигурации («1С:Бухгалтерия», «1С:Зарплата и управление персоналом», «1С:Управление торговлей»).
• Надёжность и отказоустойчивость: Использование очереди сообщений, повторные попытки отправки, логирование всех операций.
• Безопасность: Все данные передаются по защищённым каналам (HTTPS), используются ключи API, чувствительные данные шифруются.
12.2 Синхронизируемые сущности и сценарии
12.2.1 Клиенты (физические лица)
• Направление: В основном FitMan → 1С (при создании/обновлении клиента).
• Данные: ФИО, пол, дата рождения, контакты (телефон, email), дата регистрации.
• Сценарий: Новый клиент регистрируется в FitMan → его карточка автоматически создаётся в 1С как контрагент (физическое лицо).
12.2.2 Платежи и финансовые операции
• Направление: FitMan → 1С.
• Данные: Сумма, дата и время оплаты, тип платежа (абонемент, разовое занятие, товар), способ оплаты (наличные, карта, перевод), привязка к клиенту и договору.
• Сценарий: Клиент оплачивает абонемент через кассу FitMan → платёж фиксируется в 1С как приходный кассовый ордер (ПКО) или поступление на расчётный счёт.
12.2.3 Абонементы и договоры оказания услуг
• Направление: Двусторонняя.
• Данные: Тип абонемента (месячный, годовой, разовый), срок действия, стоимость, статус (активен, приостановлен, завершён), привязка к клиенту.
• Сценарий: Менеджер оформляет в FitMan новый абонемент клиенту → в 1С создаётся документ «Договор оказания услуг» или регистрируется продажа услуги.
12.2.4 Посещения и оказанные услуги (для аналитики и расчёта зарплаты)
• Направление: FitMan → 1С.
• Данные: Факт посещения клиентом занятия (дата, время, тип услуги), привязка к тренеру (для расчёта вознаграждения).
• Сценарий: После завершения занятия в FitMan фиксируется факт оказания услуги → данные передаются в 1С для учёта выручки и расчёта зарплаты тренера.
12.3 Архитектура и механизм обмена
12.3.1 Общая схема
Интеграция построена по принципу асинхронного обмена через очередь сообщений.
FitMan выступает инициатором событий, помещая задачи в очередь. Отдельный сервис (воркер) обрабатывает очередь и взаимодействует с веб-сервисом 1С через REST API.
FitMan → [Очередь задач] → Сервис синхронизации → [REST API] → 1С

12.3.2 Компоненты системы
1. Таблица конфигурации интеграции (integration_1c_config) – хранит настройки подключения к конкретному экземпляру 1С.
2. Очередь задач (integration_1c_queue) – хранит отложенные операции синхронизации.
3. Сервис-воркер – фоновый процесс, который:
o Забирает задачи из очереди.
o Формирует и отправляет запросы в 1С.
o Обрабатывает ответы, обновляет статусы задач, выполняет повторные попытки при ошибках.
4. REST API в 1С – набор веб-сервисов (HTTP-ендпоинтов), разработанных в конфигурации 1С для приёма и отправки данных.
12.3.3 Модель данных для обмена (Dart-модели)
dart
// Конфигурация подключения к 1С
class Integration1CConfig {
  String id;
  String baseUrl; // URL веб-сервиса 1С (например, https://1c.company.com/ws/fitman)
  String apiKey; // Ключ авторизации для доступа к API 1С
  SyncSettings syncSettings; // Настройки синхронизации
  List<EntityMapping> entityMappings; // Соответствие полей между системами
  bool isActive; // Включена ли интеграция
}

// Настройки синхронизации
class SyncSettings {
  bool autoSyncEnabled; // Автоматическая фоновая синхронизация
  Duration syncInterval; // Интервал (например, каждые 5 минут)
  List<String> syncEntities; // Какие сущности синхронизировать: ['client', 'payment', 'subscription']
  DateTime lastSuccessfulSync; // Время последней успешной синхронизации
}

// Соответствие полей сущности между FitMan и 1С
class EntityMapping {
  String fitmanEntity; // Название сущности в FitMan ('client')
  String externalCode; // Код соответствующей сущности в 1С
  Map<String, String> fieldMappings; // {'first_name': 'Имя', 'last_name': 'Фамилия'}
}
12.4 Техническая реализация
12.4.1 Структура таблиц в PostgreSQL
sql
-- Таблица конфигурации интеграции
CREATE TABLE integration_1c_config (
    id BIGSERIAL PRIMARY KEY,
    base_url VARCHAR(500) NOT NULL,
    api_key VARCHAR(500) NOT NULL,
    is_active BOOLEAN DEFAULT FALSE,
    sync_interval_minutes INTEGER DEFAULT 60,
    auto_sync_enabled BOOLEAN DEFAULT FALSE,
    last_successful_sync TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    company_id BIGINT DEFAULT -1
);

-- Очередь синхронизации
CREATE TABLE integration_1c_queue (
    id BIGSERIAL PRIMARY KEY,
    entity_type VARCHAR(50) NOT NULL, -- 'client', 'payment', 'subscription', 'visit'
    entity_id BIGINT NOT NULL, -- ID сущности в FitMan
    operation VARCHAR(20) NOT NULL, -- 'create', 'update', 'delete'
    payload JSONB NOT NULL, -- Данные сущности в формате JSON
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'processing', 'sent', 'error'
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    company_id BIGINT DEFAULT -1
);

-- Логи синхронизации (для аудита и отладки)
CREATE TABLE integration_1c_logs (
    id BIGSERIAL PRIMARY KEY,
    log_level VARCHAR(20) NOT NULL, -- 'info', 'warning', 'error'
    message TEXT NOT NULL,
    details JSONB, -- Дополнительные данные (например, тело запроса/ответа)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    company_id BIGINT DEFAULT -1
);
12.4.2 Сервис синхронизации (Dart)
dart
import 'dart:convert';
import 'package:http/http.dart' as http;

class Integration1CService {
  final HttpClient httpClient;
  final Integration1CConfig config;
  
  // Основной метод синхронизации (вызывается по расписанию или вручную)
  Future<SyncResult> syncData() async {
    try {
      // 1. Получаем pending-задачи из очереди
      final pendingItems = await _getPendingQueueItems();
      
      // 2. Группируем по типам сущностей для batch-отправки
      final groupedItems = _groupByEntityType(pendingItems);
      
      // 3. Отправляем пачки данных в 1С
      for (final entityType in groupedItems.keys) {
        await _sendBatchTo1C(entityType, groupedItems[entityType]!);
      }
      
      // 4. Опционально: запрашиваем обновления из 1С (если настроена двусторонняя синхронизация)
      if (config.syncSettings.syncDirection == 'bidirectional') {
        await _fetchUpdatesFrom1C();
      }
      
      await _logSyncSuccess();
      return SyncResult.success();
    } catch (e) {
      await _logSyncError(e);
      return SyncResult.error(e.toString());
    }
  }
  
  // Отправка пачки данных одного типа
  Future<void> _sendBatchTo1C(String entityType, List<QueueItem> items) async {
    final payload = {
      'entity_type': entityType,
      'items': items.map((item) => item.payload).toList(),
      'sync_timestamp': DateTime.now().toIso8601String(),
    };
    
    final response = await httpClient.post(
      Uri.parse('${config.baseUrl}/api/sync'),
      headers: {
        'Authorization': 'Bearer ${config.apiKey}',
        'Content-Type': 'application/json',
      },
      body: jsonEncode(payload),
    );
    
    if (response.statusCode == 200) {
      // Помечаем задачи как успешно отправленные
      await _markItemsAsSent(items);
    } else {
      // Обрабатываем ошибку (логируем, увеличиваем счётчик повторов)
      await _handleSyncError(items, response);
    }
  }
}
12.5 Интерфейс управления интеграцией
Интерфейс для администратора должен находиться в разделе «Администрирование» → «Интеграции» и включать:
1. Панель статуса:
o Статус подключения (✅/❌).
o Время последней успешной синхронизации.
o Количество неотправленных сообщений в очереди.
2. Настройки подключения:
o Поля для ввода URL веб-сервиса 1С, API-ключа.
o Переключатель «Интеграция активна».
o Выбор сущностей для синхронизации (чекбоксы: Клиенты, Платежи, Абонементы).
3. Управление синхронизацией:
o Кнопка «Синхронизировать сейчас» (ручной запуск).
o Переключатель «Автоматическая синхронизация» с настройкой интервала.
4. Мониторинг и логи:
o Таблица с последними операциями (статус, сущность, ошибка).
o Фильтры по дате, типу сущности, статусу.
o Кнопка «Экспорт логов».
12.6 Обработка ошибок и повторные попытки
Для обеспечения надёжности реализована стратегия повторных попыток (retry policy):
dart
class SyncErrorHandler {
  static const maxRetries = 3;
  static const retryDelays = [
    Duration(minutes: 1),
    Duration(minutes: 5),
    Duration(minutes: 15)
  ];
  
  Future<void> handleSyncError(QueueItem item, dynamic error) async {
    if (item.retryCount < maxRetries) {
      // Повторная попытка с увеличением задержки
      final delay = retryDelays[item.retryCount];
      await _rescheduleItem(item, delay);
      await _logWarning('Повторная попытка отправки ${item.entityType}#${item.entityId} через ${delay.inMinutes} мин.');
    } else {
      // Превышено максимальное число попыток - требуется вмешательство администратора
      await _notifyAdmin(
        'Критическая ошибка синхронизации',
        'Сущность: ${item.entityType}, ID: ${item.entityId}. Ошибка: ${error.toString()}'
      );
      await _markItemAsFailed(item, 'Превышено максимальное число попыток: $error');
    }
  }
}
12.7 Требования к API 1С
Со стороны 1С должен быть реализован REST API, поддерживающий как минимум следующие методы:
1. POST /api/sync – приём пачки данных от FitMan.
2. GET /api/sync/status – проверка доступности и статуса.
3. GET /api/clients/updates?since=... – получение обновлённых данных клиентов из 1С (для двусторонней синхронизации).
Формат запроса/ответа – JSON.
Обязательна авторизация по API-ключу в заголовке Authorization: Bearer <key>.
12.8 Рекомендации по внедрению
1. Этапность: Начать с синхронизации Клиентов и Платежей, затем добавить Абонементы и Посещения.
2. Тестирование: Перед включением в production выполнить тестовую синхронизацию с тестовой базой 1С.
3. Мониторинг: Настроить оповещения администратора при накоплении ошибок в очереди (>10 ошибок подряд).
4. Документация: Составить документ «Инструкция по настройке интеграции с 1С» для администраторов заказчика.
13 Сайт компании
   Сайт компании выполняет две ключевые функции: 
• Маркетинговую для привлечение новых клиентов.
• Служит точкой входа в веб-версию приложения для существующих пользователей.
13.1 Общие требования к дизайну и архитектуре
• Стиль: Строгий, лаконичный, корпоративный. Академичный подход с акцентом на надежность и профессионализм. Минимум декоративной графики.
• Технологии: Веб-сайт должен быть реализован как Single Page Application (SPA) на Flutter Web, что обеспечит единообразие дизайна и логики с мобильными приложениями.
• Адаптивность: Сайт должен корректно отображаться и функционировать на устройствах с разным разрешением экрана (десктоп, планшет, смартфон).
• Навигация: Интуитивно понятное главное меню, расположенное в шапке сайта. Меню должно быть доступно на всех страницах.
13.2 Структура и содержание страниц
Сайт состоит из следующих обязательных страниц:
• Главная страница («О компании»):
o Краткое описание фитнес-центра, его философия, преимущества.
o Блок с ключевыми показателями (количество довольных клиентов, лет на рынке и т.д.).
o Призыв к действию (CTA) "Оставить заявку".
o Призыв к скачиванию apk мобильной версии на Андроид.
• Контакты:
o Адрес центра с интерактивной картой (Google Maps/Яндекс.Карты).
o Телефон, email, график работы.
o Форма для обратной связи (упрощенный аналог блока "Составить заявку").
• Расписание работы: Информация о работе центра по дням недели. Данные должны подгружаться из таблицы work_schedules (только для чтения).
• FAQ: Страница с ответами на часто задаваемые вопросы.
• Отзывы: Модуль для отображения отзывов реальных клиентов.
13.3 Функциональные блоки
13.3.1 Блок «Составить заявку» (Форма лида)
Это ключевой маркетинговый элемент, доступный на главной странице и в виде всплывающего модального окна на других страницах.
• Поля формы:
1. Имя (обязательное, текст).
2. Пол (обязательное, выпадающий список: Мужской, Женский).
3. Возраст (обязательное, число).
4. Телефон (условно-обязательное, валидация формата).
5. Email (условно-обязательное, валидация формата).
6. Способ обратной связи (обязательное, радиокнопки: "По телефону", "По email"). Логика: если выбран телефон, обязательным становится поле "Телефон", и наоборот.
• Логика работы:
1. Валидация на стороне клиента: При попытке отправить форму проверяется заполненность обязательных полей и корректность формата. Ошибки выводятся рядом с полями.
2. Отправка данных: При нажатии кнопки "Отправить" данные формы отправляются методом POST на защищенный (HTTPS) API-эндпоинт бэкенда (например, /api/leads).
3. Обработка на сервере: Бэкенд создает запись в таблице onboarding_client и запускает процесс уведомления дежурного менеджера (как описано в разделе об онбординге).
4. Реакция на клиенте: После успешной отправки форма скрывается, а пользователю показывается сообщение: "Спасибо! Ваша заявка принята. Наш менеджер свяжется с вами в ближайшее время.".
13.3.2 Блок «Личный кабинет»
Это веб-интерфейс основного приложения, доступный после аутентификации.
• Страница входа:
o Поля: "Логин (Email/Телефон)" и "Пароль".
o Кнопка "Войти".
o Ссылка "Забыли пароль?" (запускает стандартный процесс сброса через email).
• Функциональность после входа:
o После успешной аутентификации пользователь перенаправляется на дашборд, соответствующий его роли (Клиент, Тренер, Менеджер, Администратор).
o Функциональность веб-дашбордов на 100% идентична функциональности мобильного приложения, описанной в разделах "Функциональный модуль «Клиент»", «Тренер» и т.д.
o Интерфейс должен быть оптимизирован для управления с помощью мыши и клавиатуры, но сохранять общую стилистику мобильного UI.
13.4 Интеграция с основной системой
• API: Веб-сайт общается с бэкендом через те же API и RESTful эндпоинты, что и мобильное приложение.
• Аутентификация: Используется единая система аутентификации. Сессия, открытая в браузере, не должна конфликтовать с сессией в мобильном приложении.
• Данные: Данные для страниц "Расписание работы" и др. должны браться напрямую из БД основной системы, чтобы избежать дублирования и расхождения информации.
13.5 Требования к контенту и SEO
• Контент: Все тексты на сайте должны быть уникальными, грамотными и отражать специфику центра.
• Мета-теги: Настройка title, description и keywords для каждой страницы.
• Скорость загрузки: Оптимизация изображений и кода для быстрой загрузки страниц, что критично для SEO и удержания пользователей.






Нефункциональные требования


14 Требования к технологическому стеку
Технологический стек должен обеспечивать полную независимость от внешних BaaS-провайдеров, отсутствие контейнеризации, соответствие российским требованиям безопасности и возможность развертывания на собственной инфраструктуре заказчика.
14.1 Серверная часть
Backend Framework

**Основной стек:**
- **Язык:** Dart 3.0+
- **Фреймворк:** Dart Frog или Shelf
- **HTTP сервер:** Dart native (dart:io)
- **Реальное время:** WebSocket + Redis Pub/Sub

База данных
**Основная БД:** 
- **Система:** PostgreSQL 15+
- **Хостинг:** Отдельный сервер или VPS
- **Миграции:** Dart-пакет `moor` или собственные скрипты

**Расширения PostgreSQL:**
- pg_trgm - для полнотекстового поиска
- btree_gin - для составных индексов
- uuid-ossp - для генерации UUID

**Репликация:** 
- Настройка master-slave репликации
- Автоматические бэкапы

Кэширование и реальное время
**Redis сервер:**
- **Назначение:** Pub/Sub для реального времени, кэширование
- **Конфигурация:** Отдельный инстанс Redis 7+
- **Использование:**
  - WebSocket сообщения через Pub/Sub
  - Кэш сессий пользователей
  - Временное хранение токенов
  - Очереди задач
14.2 Клиентская часть
Мобильные приложения

**Фреймворк:** Flutter 3.0+
- **Язык:** Dart 3.0+
- **Состояние:** Riverpod 2.0
- **Навигация:** Go Router
- **Локальное хранилище:** Hive 2.0

**Поддерживаемые платформы:**
- Android 8.0+ (API 26+)
- iOS 13.0+
- **Сборка:** Ручная компиляция APK/IPA

Веб-приложение

**Фреймворк:** Flutter Web
- **Режим сборки:** CanvasKit для производительности
- **Роутинг:** Browser history API
- **PWA:** Service Worker для оффлайн-работы

**Хостинг:** 
- Статические файлы на nginx
- NAS хранилище для медиа-файлов
14.3 Инфраструктура
Серверное окружение
**Операционная система:**
- **Основная:** Ubuntu 22.04 LTS
- **Альтернативная:** Debian 11+

**Веб-сервер:**
- **Прокси:** Nginx 1.20+
- **SSL:** Let's Encrypt или коммерческий сертификат
- **Балансировка:** На уровне nginx (при масштабировании)

**Управление процессами:**
- **Инит-система:** Systemd
- **Логирование:** Journald + ротация логов
- **Мониторинг:** Prometheus + Grafana (опционально)

Файловое хранилище
**Локальное хранилище:**
- **Структура:** 
  `/opt/fitman/storage/`
  ├── uploads/     # Пользовательские файлы
  ├── avatars/     # Фотографии профилей
  ├── documents/   # Сканы документов
  └── backups/     # Резервные копии

14.4 Установка и развертывание
Способ дистрибуции
**Серверная часть:**
- **Формат:** Самодостаточный инсталлятор (.run)
- **Содержимое:** 
  - Бинарные файлы Dart приложения
  - Скрипты установки PostgreSQL/Redis
  - Конфигурационные файлы nginx
  - Systemd unit files

**Мобильные приложения:**
- **Android:** APK файлы для скачивания с сайта
- **iOS:** TestFlight для тестирования, App Store для продакшена
14.5 Процесс установки
bash
# Пример установочного скрипта
#!/bin/bash
# fitman-installer.run

echo "Установка Фитнес-Менеджера..."

# Автоматическая установка зависимостей
apt-get install -y postgresql postgresql-contrib redis-server nginx

# Настройка БД
sudo -u postgres psql -c "CREATE USER fitman_user WITH PASSWORD '${DB_PASSWORD}';"
sudo -u postgres psql -c "CREATE DATABASE fitman OWNER fitman_user;"

# Развертывание приложения
cp -r application /opt/fitman/
chown -R www-data:www-data /opt/fitman

# Запуск сервисов
systemctl enable fitman.service
systemctl start fitman.service
14.6 Безопасность
Аутентификация и авторизация
**Механизм аутентификации:**
- **Токены:** JWT (JSON Web Tokens)
- **Алгоритм:** HS256 или RS256
- **Время жизни:** Access token - 24 часа, Refresh token - 7 дней

**Защита API:**
- **HTTPS:** Обязательно для всех endpoints
- **CORS:** Настройка для доменов клиента
- **Rate Limiting:** Ограничение запросов по IP/пользователю
14.7 Защита данных
**Шифрование:**
- **Пароли:** bcrypt с salt rounds = 12
- **Чувствительные данные:** AES-256 в базе данных
- **Транспорт:** TLS 1.3 для всех соединений

**Резервное копирование:**
- **Частота:** Ежедневные полные бэкапы
- **Хранение:** Отдельный защищенный сервер
- **Шифрование:** GPG для резервных копий
14.8 Мониторинг и логирование
Система мониторинга
**Встроенные метрики:**
- Нагрузка CPU, памяти, диска
- Количество активных пользователей
- Время ответа API endpoints
- Статус WebSocket соединений

**Внешний мониторинг:**
- **Доступность:** Zabbix или UptimeKuma или UptimeRobot
- **Логи:** Centralized logging через rsyslog
- **Оповещения:** Telegram bot для критических ошибок

Логирование
dart
// Пример системы логирования
class AppLogger {
  static final Logger _logger = Logger();
  
  static void setupLogging() {
    Logger.root.level = Level.INFO;
    Logger.root.onRecord.listen((record) {
      // Запись в файл с ротацией
      _writeToFile(record);
      // Отправка в syslog для критических ошибок
      if (record.level >= Level.SEVERE) {
        _sendToSyslog(record);
      }
    });
  }
}
14.9 Производительность и масштабирование
Оптимизация базы данных
sql
-- Пример индексов для производительности
CREATE INDEX CONCURRENTLY idx_users_email ON users(email);
CREATE INDEX CONCURRENTLY idx_chats_company ON chats(company_id);
CREATE INDEX CONCURRENTLY idx_messages_chat_date ON messages(chat_id, created_at DESC);

-- Частичные индексы для архивных данных
CREATE INDEX idx_active_users ON users(id) WHERE archived_at IS NULL;

Стратегия масштабирования
**Вертикальное масштабирование:**
- Увеличение ресурсов VPS (CPU, RAM, SSD)
- Настройка репликации PostgreSQL
- Кэширование часто запрашиваемых данных

**Горизонтальное масштабирование (при росте):**
- Добавление application-серверов
- Балансировка нагрузки через nginx
- Шардирование базы данных
14.10 Резервные копии и восстановление
Процедуры бэкапа
**Автоматические бэкапы:**
- **База данных:** pg_dump ежедневно в 02:00
- **Файлы приложения:** rsync раз в неделю
- **Конфигурации:** Git-репозиторий с историей изменений

**Восстановление:**
- Скрипт автоматического восстановления из бэкапа
- Пошаговые инструкции для ручного восстановления
- Регулярные тесты восстановления
14.11 
Модульная архитектура API (frontend)

Для повышения поддерживаемости, масштабируемости и чистоты кода, слой взаимодействия с API на фронтенде рефакторизован с использованием модульного подхода и паттерна "Фасад".
1. Фасад `ApiService`: Основной класс `ApiService` (frontend/lib/services/api_service.dart) теперь выступает в роли фасада. Он предоставляет единый и упрощенный интерфейс для всех API-запросов, делегируя фактическое выполнение специализированным внутренним сервисам. Это позволяет остальной части приложения взаимодействовать с API через стабильный, высокоуровневый интерфейс, не зная о внутренней сложности.
2. Базовый сервис `BaseApiService`: В класс `BaseApiService` (frontend/lib/services/api/base_api.dart) вынесена вся общая логика, необходимая для работы с API:
• Управление базовым URL (получение из .env).
• Хранение и управление токеном аутентификации (в Shared Preferences).
• Формирование стандартных HTTP-заголовков (включая Authorization-токен).
• Унифицированные методы для выполнения HTTP-запросов (GET, POST, PUT, DELETE, Multipart POST) с автоматической обработкой ответов и ошибок.
3. Доменно-ориентированные сервисы: Вся специфическая логика API разбита на отдельные модули, каждый из которых отвечает за свою доменную область. Эти сервисы расположены в директории `frontend/lib/services/api/` и включают:
• `auth_api.dart`: Аутентификация, регистрация, управление пользователями и ролями.
• `infrastructure_api.dart`: Управление помещениями, зданиями и оборудованием.
• `groups_api.dart`: Управление тренировочными и аналитическими группами.
• `chat_api.dart`: Функциональность чата (получение сообщений, отправка вложений).
• `manager_api.dart`: Специфические функции для роли менеджера.
• `instructor_api.dart`: Специфические функции для роли инструктора.
• `client_api.dart`: Специфические функции для роли клиента (например, антропометрия).
• `catalogs_api.dart`: Получение справочных данных (цели, уровни тренировок).
• `schedule_api.dart`: Управление расписаниями.
• `admin_api.dart`: Функции, доступные только администратору.

Преимущества новой архитектуры:
• **Разделение ответственности (Single Responsibility Principle):** Каждый модуль API отвечает только за свой домен, что делает код более понятным и легким для модификации.
• **Улучшенная организация:** API-вызовы структурированы по функциональным областям, что упрощает поиск и навигацию по коду.
• **Повышенная поддерживаемость:** Изменения в одном домене API не затрагивают другие, снижая риск побочных эффектов.
• **Тестируемость:** Модульные сервисы легче тестировать изолированно.
• **Снижение конфликтов при слиянии:** Разработка в разных модулях снижает вероятность конфликтов при работе нескольких разработчиков.

14.12 Принцип модульности структуры кода
Проект FitMan разработан с учетом принципа модульности, что обеспечивает его гибкость, масштабируемость и простоту поддержки. Данный подход применяется на всех уровнях архитектуры приложения: от структуры фронтенда и бэкенда до организации баз данных.
Ключевые аспекты модульности:
• **Разделение по доменам:** Функциональность приложения разбита на независимые домены (например, `users`, `groups`, `chat`, `infrastructure`, `auth`), каждый из которых инкапсулирует свою логику, модели данных, API-интерфейсы и пользовательские интерфейсы.
• **Инкапсуляция:** Каждый модуль является самодостаточным и минимизирует зависимости от других модулей. Взаимодействие между модулями происходит через четко определенные интерфейсы.
• **Гибкая архитектура Frontend:**
• **Организация по фичам:** Код фронтенда (Flutter) структурирован по фичам (модулям), где каждый модуль (`frontend/lib/modules/<module_name>/`) содержит все компоненты, относящиеся к данной функциональности:
• `models/`: Модели данных, специфичные для модуля.
• `providers/`: Riverpod-провайдеры для управления состоянием.
• `screens/`: Экраны и виджеты, составляющие UI модуля.
• `services/`: Клиентские сервисы для взаимодействия с API (где API-слой сам модульный).
• **Модульный API-слой:** Как описано в разделе 14.11, API-запросы также организованы в доменно-ориентированные сервисы, что позволяет легко добавлять, изменять или удалять эндпоинты без влияния на другие части системы.
• **Модульная структура Backend:**
• Бэкенд (Dart Frog/Shelf) также организован по модульному принципу (`backend/lib/modules/<module_name>/`), что включает контроллеры, сервисы и репозитории для каждого домена.
Преимущества модульного подхода:
• **Упрощение разработки:** Разработчики могут сосредоточиться на одном модуле, не отвлекаясь на другие.
• **Легкость тестирования:** Модули могут быть протестированы независимо, что повышает надежность.
• **Масштабируемость:** Новая функциональность может быть добавлена как новый модуль, не затрагивая существующую логику.
• **Удобство поддержки:** Изоляция кода упрощает отладку и внесение изменений.
• **Повышение читаемости кода:** Четкая структура и границы между модулями делают кодовую базу более понятной.


15 Требования к таблицам
База данных системы – PostgreSQL.
• В каждой таблице должно быть поле id (BIGSERIAL) с primary key.
Имена foreign key полей должны соответствовать шаблону: <имя_таблицы_в_единственном_числе>_id.
• В каждой таблице должно быть поле company_id (BIGINT) для мультитенантности. По умолчанию равно -1.
• Индексы должны быть добавлены на все поля, используемые в условиях JOIN и WHERE, в частности, на все foreign key поля.
• Имена и поля таблиц должны быть в snake_case нотации.
• Способ удаления записей -- логическая архивация: заполняются поля archived_at, archived_by. Физический DELETE запрещён.
• Поле для фото – тип URL, ссылка на файл с фото в хранилище
• Не использовать встроенный тип ENUM. Вместо него использовать SMALLINT, в нем значение enum в коде. 
• Не использовать строковый тип как перечисления. Вместо него использовать SMALLINT, в нем значение enum в коде.
• Тип дата/время должен быть timestamp with time zone.
• Для оперативного аудита, все таблицы должны иметь поля:
• "Дата Создания" (created_at (TIMESTAMP)) 
• "Дата Изменения" (updated_at (TIMESTAMP))
• "Создан пользователем" (created_by (BIGINT FK → users(id)))
• "Изменен пользователем" (updated_by (BIGINT FK → users(id))).
Поля created_at, created_by, необходимо учитывать при добавлении записи. Поля updated_at, updated_by, необходимо учитывать при обновлении запросов.
• Для архивации и восстановления записей, все таблицы должны включать поля:
• archived_at (TIMESTAMP NULL)
• archived_by (BIGINT FK → users(id))

16 Требования к логированию приложения
Логирование должно осуществляться средствами технологического стека. Логирование должно иметь 4 уровня важности сообщения: отладочное, информационное, предупреждение, ошибка. Максимальный уровень, по которому сообщения будут записываться, записывается в файл настроек приложения. Сообщения должны записываться в суточный файл формата "EFT_YYYY_MM_DD", где YYYY_MM_DD – год, месяц и день. Сообщение, кроме отладочного, должно выводиться на экран.


17 Требования к безопасности
Данный раздел описывает меры, направленные на обеспечение конфиденциальности, целостности и доступности данных системы, а также на защиту от несанкционированного доступа.
17.1 Аутентификация и авторизация
• Многофакторная аутентификация (MFA). Система должна предоставлять возможность включения MFA для ролей Администратор, Менеджер и Тренер.
• Политика паролей. Пароли пользователей должны храниться в базе данных исключительно в виде хешей с использованием современных алгоритмов (например, bcrypt/scrypt/Argon2).
• Минимальная длина пароля — 8 символов.
• Пароль должен содержать как минимум одну заглавную букву, одну строчную букву, одну цифру и один специальный символ.
• Запрещено использовать простые или скомпрометированные пароли.
• Защита от brute-force. Система должна блокировать учетную запись или вводить задержку после 5 неуспешных попыток ввода пароля в течение 15 минут.
• JWT Tokens. Время жизни Access Token должно быть ограничено (например, 15-30 минут).
• Обязательно использование Refresh Tokens с ограниченным временем жизни (например, 7 дней) и механизмом их отзыва.
• Tokens должны быть подписаны с использованием надежного алгоритма (например, RS256).
• Управление сессиями. При выходе из системы или по истечении времени неактивности (30 минут) сессия пользователя должна быть полностью завершена на стороне клиента и сервера.

17.2 Контроль доступа (Authorization)
• Принцип наименьших привилегий. Каждая роль в системе должна иметь доступ только к тем данным и функциям, которые абсолютно необходимы для выполнения ее задач.
• Row Level Security (RLS)  Для базы данных PostgreSQL  **обязательно** должна быть настроена политика RLS на всех таблицах, содержащих персональные или бизнес-данные. Доступ к данным должен предоставляться на основе роли пользователя и его идентификатора.
• Валидация на стороне сервера. Все запросы к API, включая проверки прав доступа к объектам, должны быть валидированы на стороне бэкенда. Недостаточно проверять права только на фронтенде.

17.3 Защита данных
• Все данные должны передаваться по защищенному протоколу **HTTPS/TLS 1.2+**.
• Чувствительные данные (например, пароли, персональные данные клиентов) должны шифроваться при хранении в базе данных или использовать механизмы шифрования.
• Маскирование данных. При отображении конфиденциальной информации (например, телефона, email) в интерфейсах для некоторых ролей следует применять маскирование (например, `+7 *** *** ** 12`).
• Безопасное хранение секретов. Ключи API, секреты для подписи JWT, учетные данные для внешних сервисов (SMS-шлюз) не должны храниться в коде или репозитории. Необходимо использовать защищенные механизмы хранения секретов.
• Доступ к архивным записям возможен только роли «Администратор». Остальные роли видят только активные записи (RLS-политика archived_at IS NULL).
17.4 Безопасность API
• Защита от перебора (Rate Limiting).  API должен быть защищен от DDoS-атак и перебора паролей путем ограничения количества запросов с одного IP-адреса или для одной учетной записи в единицу времени.
• Валидация входных данных. Все входные данные, поступающие в API (параметры запросов, тела запросов), должны быть строго валидированы на предмет типа, длины, диапазона и наличия потенциально опасных конструкций (SQL-инъекции, XSS).

17.5 Защита на клиенте (Frontend).
• Защита от XSS. Данные, предоставляемые пользователями (например, комментарии, имена), должны быть экранированы перед отображением в интерфейсе для предотвращения межсайтового скриптинга.
• Безопасные заголовки HTTP. Приложение должно использовать security headers (например, Content-Security-Policy, X-Frame-Options, X-Content-Type-Options) для защиты от различных видов атак.

17.6 Аудит и мониторинг
• Логирование событий безопасности. В логи приложения должны записываться все критичные события:
• Неудачные попытки входа в систему.
• Попытки доступа к запрещенным ресурсам (ошибки 403).
• Изменение критичных настроек системы, прав пользователей.
• Создание, изменение и удаление учетных записей пользователей.
• Мониторинг. Система должна иметь возможность мониторинга подозрительной активности, с уведомлением ответственных лиц (Администратор).

17.7 Резервное копирование и восстановление
• Регулярное резервное копирование. Должна быть обеспечена процедура регулярного (ежедневного) резервного копирования базы данных и критичных файлов.
• План восстановления. Должен быть документирован и протестирован план восстановления работы системы после сбоя в течение не более 4 часов.



18 Требования к тестированию
• Реализовать юнит-тесты по всем командам.
• Реализовать интеграционные тесты по каждой роли.


19 Дополнительные требования
19.1 Добавить диаграмму БД.
• ER-диаграмму отношений между таблицами
• Схему связей и индексов

19.2 Уточнить API endpoints.
• REST API методы для каждого модуля
• Форматы запросов/ответов

Архитектурные требования
20 Редакции продукта
20.1 Редакция Basic
Эта редакция является текущей.
Основной функционал:
• Для будущей мультитенантности вводится поле company_id во все таблицы.
• Система лицензий и ограничений.
• Весь функционал в Basic-качестве.
Для: малых фитнес-залов, студий, персональных тренеров
Ограничения: 1 филиал, до 100 клиентов, до 3 тренеров

20.2 Редакция Pro
Основной функционал:
• Мультитенантная архитектура.
• Расширенная аналитика.
• White-label.
• API для интеграций.
Для: средних клубов, сетей в одном городе, мультибрендовых операторов
Ограничения: мультитенантность, до 500 клиентов, до 10 тренеров

20.3 Редакция Enterprise
Основной функционал:
• Филиальная и мультитенантная архитектура.
• Корпоративная отчетность.
• Сложные интеграции.
Для: федеральных сетей, крупных клубов с филиалами
Ограничения: неограниченно, филиальная структура


Архитектура с учетом трех версий
Базовая версия:
  - Единая база данных
  - Простая схема tenant_id = 1
  - Ограничения через application logic

Pro версия:
  - Schema-based мультитенантность
  - Отдельные схемы для каждого tenant
  - Общие справочники

Enterprise версия:
  - База данных на филиал + общая сводная
  - Репликация между филиалами
  - Единый каталог пользователей


Глоссарий

• Списочная форма – виджет-экран со списочным представлением (ListView).
• Карточка – виджет-экран с детальным представлением (DetailView).
• Дашборд – виджет-экран с вложенными виджетами.
• Фрейм – виджет-контейнер для группировки других виджетов.
• BMR - Basal Metabolic Rate (Основной обмен веществ).
• Дефицит/профицит калорий - разница между потребленными и затраченными калориями.
• Мультитенантность - архитектура для работы с несколькими независимыми клиентами в одной системе
• Филиальность - иерархическая структура подразделений с единым управлением




46


