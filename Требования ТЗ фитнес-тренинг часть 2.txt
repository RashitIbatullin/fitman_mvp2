
Оглавление	
Оглавление	1
Функциональные требования	2
Функциональный модуль "Администратор"	2
11	Функциональный модуль "Клиент"	4
12	Функциональный модуль "Инструктор"	14
13	Функциональный модуль "Тренер"	15
14	Функциональный модуль "Менеджер"	16
15	Архитектура планов тренировок	16
16	Расписание занятий	17
17	Табели	18
18	Подсистема рекомендаций по тренингу	19
19	Команды (pattern Command)	27
20	Каталоги (Catalogs)	27
21	Оффлайн-режим (Offline-First Approach)	38
22	Архивация и восстановление записей	40
23	Аудит и журнал событий (Audit Log)	40
24	Файл настроек приложения	42
25	Сайт компании	43
26	Интеграция с системами бухгалтерского учета	46
Нефункциональные требования	52
26	Требования к технологическому стеку	52
27	Требования к таблицам	56
28	Требования к логированию приложения	56
29	Требования к безопасности	56
30	Требования к тестированию	59
31	Дополнительные требования	59
Архитектурные требования	59
32	Редакции продукта	59
Глоссарий	62



Функциональные требования
Функциональный модуль "Администратор"
10.1  Дашборд "Администратор"
Обозначение: AdminDashboard.
Заголовок: "Администратор".
Меню дашборда:
• Главное. Экран дашборда.
• Профиль. Экран с личной информацией.
• Подменю каталогов. Доступны для создания/редактирования записей всех каталогов.
• Параметры -> Настройки. Открывается popup-форма "Настройки".
• Инфо.
Дашборд включает ListView пользователей с панелью инструментов. На панели инструментов находятся кнопки: "Создать" (активная), "Изменить", " Архивировать", "Сброс пароля" (активные при выборе строки в списке). Так же имеется поле поиска по ФИО/телефону/e-mail и кнопкой сброса содержимого поля. На каждое действие определяется своя команда.
Отдельно размещен виджет SegmentedButton со значениями: Все | Администраторы | Менеджеры | Тренеры | Инструкторы | Клиенты. При клике вызывается соответствующая команда фильтрации списка.

10.1.1 Окно "Создание пользователя"
Параметр: строка (userRole).
Заголовок: "Создание: " + userRole.
Поля:
• login (string). //Логин. Обязательное.
• password (string). //Пароль. Обязательное.
• lastName (string). //Фамилия. Обязательное.
• firstName (string). //Имя. Обязательное.
• middleName (string). //Отчество. Не обязательное.
• fullName (string). //Полное ФИО.
• shortName (string). //Краткое ФИО.
• gender (string). //Пол. Обязательное.
• age (int). //Возраст. Обязательное.
• phone (string). //Телефон. Обязательное.
• email (string). //E-mail. Не обязательное.
• photo (URL). //Фото. Не обязательное
• sendNotification (bool). //Посылать уведомления. Обязательное. Значение берется из файла настроек.
• hourNotification (duration). //Время уведомления до занятий (в часах). Обязательное. Значение берется из файла настроек.

В случае создания администратора, поля sendNotification, hourNotification, не отображаются.
В случае создания клиента, отображаются дополнительные поля:
• trackCalories (bool) //Учет калорий. Значение берется из файла настроек.
• double coeffActivity = 1.2; //Минимальный коэффициент активности.

Поле "Пароль" имеет отображаемый формат в виде звездочек.
Поля fullName и shortName вычисляются автоматически после ввода lastName, firstName, middleName.
Для выбора пола сформировать выпадающий список со значениями "мужской", "женский".
Телефон и почту проверять функциями валидации.

Кнопки: "Генерировать пароль", "Создать", "Отмена".
По кнопке "Генерировать пароль", запускается команда генерации пароля с солью в поле Пароль.
По кнопке "Создать", запускается команда создания пользователя с параметром userRole.
По кнопке "Отмена" закрывает окно.

10.1.2 Окно "Сброс пароля"
Параметр: строка (userLogin).
Лэйбл: "При сбросе пароля будет установлен новый пароль, который нужно будет сообщить пользователю. Продолжить?"
Поле: "Пароль".
Кнопки: "Сбросить пароль" и "Отменить".
Должно быть предусмотрено скрытие пароля. Должен быть предусмотрен ручной ввод пароля. Должна быть предусмотрена повторная генерация пароля.
При открытии формы запускается Команда "Генерация пароля" и возвращаемое значение подставляется в поле "Пароль".
При нажатии на кнопку "Сбросить пароль" запускается Команда "Сохранение пароля " с параметрами: userLogin и паролем.

10.1.3 Окно "Дежурства сотрудников"
Фрейм "Дежурный менеджер"
Содержит элементы:
• ФИО дежурного менеджера; //Статус "дежурный" определяется по последней незавершенной записи в employees_duty (где duty_finish_at IS NULL)'
• Дежурство с: ' + время последней записи duty_start_at из таблицы employees_duty по id из таблицы users;  
• ListView пользователей, отфильтрованных по роли Менеджер. 
• Кнопка с заголовком "Назначить", если ФИО пусто, или с заголовком "Сменить", если ФИО не пусто.
Логика: После выбора строки из ListView, и нажатия кнопки, запускается команда назначения дежурного сотрудника с параметрами: типа роли и id сотрудника. У нее есть 2 варианта:
1. id == null. В этом случае выдается предупреждающее сообщение "Назначить имярек дежурным менеджером?" В случае "Да" в таблице employees_duty создается новая запись с текущем временем в поле duty_start_at. На выходе команды заполняется поле ФИО и 'Дежурство с: ' + время duty_start_at;
2. id != null. В этом случае выдается предупреждающее сообщение "Сменить дежурного менеджера имярек1 на имярек2?" В случае "Да" в таблице employees_duty по id менеджера1 устанавливается текущем временем поле duty_finish_at. Далее создается новая запись с текущем временем в поле duty_start_at.  На выходе команды заполняется поле ФИО и 'Дежурство с: ' + время dutyManagerStartAt;

10.1.4 Окно "Настройки"
Имеет поля из файла настроек.
Кнопка: "Сохранить". Становится доступной при изменении любого поля окна.
10.1.5 Окно "Расписание работы центра"
Содержит редактируемую ListView из таблицы work_schedules.

10.1.6 Окно "Расписание занятий"
Содержит все виды расписаний занятий, с выборкой по тренеру, инструктору, клиенту.
Содержит функционал составления общего расписания, обновления по клиенту.

10.1.7 Окно "Табели"
Окно содержит дашборд "Табель" в групповом режиме.

11 Функциональный модуль "Клиент"
11.1 Таблицы индивидуальных назначений
• Таблица: client_training_plans
o id (PK)
o user_id (FK -> users)
o training_plan_template_id (FK -> training_plan_templates) // Исходный шаблон
o assigned_by (FK -> users) // Кто назначил (тренер)
o assigned_at (TIMESTAMP)
o is_active (BOOLEAN) // Активный план у клиента
o goal (VARCHAR) // Цель может быть переопределена для этого клиента
o notes (TEXT) // Персональные заметки тренера
• Таблица: client_set_exercises
o id (PK)
o client_training_plan_id (FK -> client_training_plans) // Часть какого ИНДИВИДУАЛЬНОГО плана
o set_exercise_template_id (FK -> set_exercise_templates) // Основано на каком шаблоне
o order (INT) // Порядок в плане для этого клиента
o is_active (BOOLEAN)
o repeats (INT) // Индивидуальное кол-во повторений всего сета
o rest_after_set (REAL) // Индивидуальное время отдыха после сета
• Таблица: client_exercises
o id (PK)
o client_set_exercise_id (FK -> client_set_exercises) // Часть какого ИНДИВИДУАЛЬНОГО сета
o exercise_template_id (FK -> exercise_templates) // Основано на каком шаблоне
o order (INT) // Порядок в сете для этого клиента
o custom_repeat_qty (INT) // Индивидуальное кол-во повторов
o custom_duration_exec (REAL) // Индивидуальная длительность
o custom_duration_rest (REAL) // Индивидуальный отдых
o custom_notes (TEXT) // Персональные указания (например, "ставить ноги шире")
11.2 Таблица "lessons"

• schedule_id (BIGINT); //определяет запланированный слот,
• client_training_plan_id (BIGINT); //конкретный план, который был выполнен в этом слоте
• set_exercises_id (BIGINT);
• user_id (BIGINT);
• instructor_id (BIGINT);
• trainer_id (BIGINT);
• room_id BIGINT REFERENCES rooms(id);
• equipment_ids JSONB; -- список equipment.id
• start_plan_at (TIMESTAMP);
• start_fact_at (TIMESTAMP);
• finish_plan_at (TIMESTAMP);
• finish_fact_at (TIMESTAMP);
• complete (INT);
• note (VARCHAR(100));
Таблица lessons заполняется на основе расписания.

Таблица "track_сalories"
• user_id (BIGINT);
• lesson_id (BIGINT);
• weight (double); //вес
• calories_in (REAL); //входящие калории
• calories_out (REAL); //исходящие калории

Таблица хранения формулы расчета BMR "bmr_formulas"
• name (VARCHAR(100));
• formula (TEXT), -- например: "66 + (13.7 * weight) + (5 * height) - (6.8 * age)"
• for_men (BOOLEAN),
• for_women (BOOLEAN),
• is_active (BOOLEAN DEFAULT true)


11.3 Таблицы антропометрии
Таблица "anthropometry_fix" (фиксированные значения, вводятся 1 раз).
• user_id (BIGINT);
• date_time (TIMESTAMP);
• height (int); //рост в см
• wrist_circ (Обхват запястья, см);
• ankle_circ (Обхват лодыжки, см);
Таблица "anthropometry_start" (антропология начало).
• user_id (BIGINT);
• date_time (TIMESTAMP);
• photo_date_time (TIMESTAMP);
• photo (URL); //фото 
• weight (double); //вес в кг
• shoulders_circ (int); //обхват в плечах
• breast_circ (int); //обхват в груди
• waist_circ (int); //обхват в талии
• hips_circ (int); //обхват бедер

Таблица "anthropometry_finish" " (антропология окончание). По структуре повторяет таблицу "anthropometry_start".
Таблицы anthropometry_ обновлять могут только сотрудники (не роль Клиент).

11.4 Таблицы биоимпеданса
Таблица "bioimpedance_start"
• user_id (BIGINT);
• date_time (TIMESTAMP);
• fat_percentage (Процент жира);
• muscle_mass (Мышечная масса, кг);
• water_percentage (Процент воды);
• visceral_fat (Висцеральный жир, уровень);
• bmc (Минеральная масса костей);
• bmi (Индекс массы тела, часто считает сам аппарат);
• metabolism (Скорость основного обмена, ккал);

Таблица "bioimpedance_finish". По структуре повторяет таблицу "bioimpedance_start".
Таблицы bioimpedance_ обновлять могут только сотрудники (не роль Клиент).

11.5 Таблица предпочтений
Таблица "client_schedule_preferences" (предпочтения клиента по расписанию).
• user_id (FK -> users). Ссылка на клиента.
• day_of_week (Integer, NOT NULL). День недели: 1-7.
• preferred_start_time (Time, NOT NULL). Желаемое время начала занятия.
• preferred_end_time (Time, NOT NULL). Желаемое время окончания занятия.

11.6 Списочная форма
ListView клиентов должна отображаться в дашбордах инструкторов, тренеров, менеджеров в окне "Клиенты".
Отображаемые поля:
• Фото клиента. При выборе поля открывается дашборд клиента.
• Фамилия, Имя, Отчество. При выборе поля открывается дашборд клиента.
• Занятие ближайшее. При выборе поля открывается дашборд занятия
• Инфо.
Поле Инфо представляет собой строку информации о ближайшем занятии клиента в зависимости от значения hourNotification клиента:
• Текущее время меньше разницы времени начала ближайшего занятия и hourNotification:
отображается строка: "До занятия " + (разница времени начала ближайшего занятия и текущего) + " час."
• Текущее время в пределах разницы времени начала ближайшего занятия и hourNotification:
отображается строка на желтом фоне: "До занятия " + (разница времени начала ближайшего занятия и текущего) + " час."
• Текущее время больше времени начала ближайшего занятия и меньше времени окончания занятия:
      отображается строка на зеленом фоне: "Идет занятие".
   Функционал поля Инфо является задачей бэкенд-API с периодом 1 минута.
11.7 Дашборд "Клиент"
Дашборд "Клиент" должен быть доступен как клиенту, так и всем остальным ролям при открытии дашборда из списка клиентов.
Обозначение: ClientDashboard.
Дашборд должен включать следующие виджеты:
1. Виджет "Следующая тренировка":
o Отображает информацию о ближайшем предстоящем занятии.
o Включает динамический обратный отсчет до начала занятия.
o Содержит кнопку-ссылку для перехода к деталям занятия.
2. Виджет "Прогресс тренировок":
o Отображает общую статистику: количество завершенных занятий за период, общее количество сожженных калорий, процент посещаемости.
o Визуализирует данные с помощью индикаторов выполнения (progress bar) и компактных графиков активности.
3. Виджет "Прогресс по цели":
o Отображает текущую цель клиента (напр., целевой вес).
o Показывает прогресс в достижении цели в виде численных индикаторов и тренда на мини-графике.
o Отображает средний недельный дефицит или профицит калорий.
4. Виджет "Достижения":
o В геймифицированном виде отображает последние полученные клиентом достижения.
o Представляет собой сетку иконок с кратким описанием.
5. Быстрое меню: Доступ к основным разделам ("Занятия", "Учет калорий") должен быть реализован в виде панели быстрого доступа или виджетов-карточек на самом дашборде.
Примечание: Виджеты должны быть адаптивными и перестраиваться в зависимости от размера экрана устройства. Порядок и наличие виджетов можно настроить.

Меню дашборда:
• Главное. Экран дашборда.
• Профиль. Экран с личной информацией.
• Мой тренер.
• Мой инструктор (при включенном roleInstructor из файла настройки).
• Мой менеджер (при включенном roleManager из файла настройки).
• Антропометрия.
• Занятия.
• Учет калорий (при включенном trackCalories из таблицы client).
• Прогресс.
• Инфо (доступно всем ролям, кроме Клиента).

11.7.1 Окно "Мой тренер"
Содержит фото тренера, полное ФИО, телефон, фрейм чата.

11.7.2 Окно "Мой инструктор"
Содержит фото инструктора, полное ФИО, телефон, фрейм чата.

11.7.3 Окно "Мой менеджер"
Содержит фото менеджера, полное ФИО, телефон, фрейм чата.
  
11.7.4 Окно "Антропометрия"
Состоит из:
• Виджета вверху по центру с данными из таблицы anthropometry_fix.
• 2-х одинаковых виджетов "Начало" и "Окончание", расположенных горизонтально, с данными из таблиц anthropometry_start и anthropometry_finish.
• В каждом виджете кнопка "Редактировать" переводит данные в режим редактирования. Кнопка "Редактировать" видна всем, кроме роли клиента.
• Кнопка "Сохранить" появляется после активации редактирования. После сохранения - возврат в режим просмотра.
• В виджетах "Начало" и "Окончание" имеется виджет "Индекс здоровья WHtR".  WHtR рассчитывается, как рост/обхват талии. Индекс рассчитывается с поправкой на возраст:
• Возраст до 25 – поправка 0.
• Возраст до 40 – поправка 0.02.
• Возраст до 60 – поправка 0.04.
• Возраст после 60 – поправка 0.05.
Виджет представляет собой линейный прогресс-бар с разметкой:
• Зеленая зона (0.45 - 0.55): "Норма, риск низкий"
• Желтая/Оранжевая зона (0.55 - 0.6): "Повышенный риск ожирения"
• Желтая/Оранжевая зона (0.4 - 0.45): "Повышенный риск истощения"
• Красная зона (>0.6): "Высокий риск ожирения"
• Красная зона (<0.4): "Высокий риск истощения"
• В окне расположена кнопка "Сравнение по фото". После нажатия открывается экран "Сравнение по фото" с двумя виджетами с заголовками "Начало" и "Окончание", выровненными по горизонтали. В каждом виджете имеется фрейм для показа фото, поле даты и кнопка "Загрузить фото". Кнопка видна всем, кроме роли клиента. По кнопке загружается фото из выбранной папки, с указанием даты/времени создании фото, если имеется, если нет, то даты/времени загрузки. При отображении обоих фото появляется кнопка "Сравнить". По кнопке запускается функция "Сравнить".
Функция "Сравнить":
• При нажатии кнопки "Сравнить" система открывает полноэкранный режим для визуального сравнения фотографий "до" и "после".
• Реализовать режим "Слайдер" (split-view), позволяющий пользователю интерактивно перекрывать одно изображение другим для наглядной оценки изменений.
• На втором этапе разработки рассмотреть возможность добавления функционала ручной разметки ключевых точек на фотографиях для автоматического расчета и сравнения объемов тела.
• Технологии автоматического замера объемов с помощью Computer Vision (AI) являются опциональными и требуют отдельного технико-экономического обоснования.

11.7.5 Окно "Биоимпеданс"
Состоит из 2-х одинаковых фреймов "Начало" и "Окончание", расположенных горизонтально, с ListView таблиц bioimpedance_start и bioimpedance_finish.

11.7.6 Окно "Занятия"
Окно содержит ListView "Lessons" c расписанием занятий.
Поля:
• № занятия.
• Наименование набора упражнений.
• Начало занятия план.
• Конец занятия план.
• Начало занятия факт. 
• Конец занятия факт.
• Длительность.
• Инструктор.
• Тренер.
• Выполнение.
• Примечание.
Логика отображения:
• Если у клиента есть активные занятия в расписании: отображается таблица с расписанием.
• Если активных занятий нет: таблица скрывается. Вместо нее отображается виджет с текстом: "Вам еще не назначены занятия. Заполните, пожалуйста, предпочтения по времени." и кнопка "Заполнить предпочтения".
Логика кнопки "Заполнить предпочтения":
• При нажатии открывается окно "Предпочтения по расписанию" ClientPreferenceSchedule.
После тапа-клика строки ListView "Lessons", открывается карточка "Занятие". Редактирование полей карточки возможно только последней записи.
Окно содержит кнопку "Создать", после чего создается запись в таблице lessons на основе расписания и открывается карточка "Занятие".
Карточка "Занятие"
Поля:
• № занятия (недоступно).
• Наименование набора упражнений (недоступно).
• Начало занятия план (недоступно).
• Конец занятия план (недоступно).
• Начало занятия факт. 
• Конец занятия факт.
• Длительность (недоступно).
• Инструктор.
• Тренер.
• Выполнение.
• Примечание.

Примечания:

По умолчанию поля Начало занятия факт = Начало занятия план, Конец занятия факт = Конец занятия план, и их можно изменить.
Длительность рассчитывается после обновления поля "Выполнение".
По умолчанию поле Выполнение пустое. Поле Выполнение выбирается из
enum CompleteLesson {completed, postponed, canceled, frozen} (выполнено, перенесено, отменено, заморожено). В случае выбора из последних двух, открывается inputBox для обязательного ввода примечания. Нельзя сохранить запись с пустым полем Выполнение.

В полях Инструктор и Тренер можно выбрать из выпадающего списка произвольного инструктора и тренера.


11.7.7 Окно "Предпочтения по расписанию"
Класс ClientPreferenceSchedule.
• Форма загружает данные из таблицы work_schedules.
• Для каждого рабочего дня недели (is_day_off = false) отображается строка с:
• Наименованием дня недели.
• Диапазоном доступного времени (взят из work_schedules для этого дня). Например: "Понедельник (доступно с 09:00 до 20:00)". (минус 1 час на последнее занятие: end_time - 1h).
• Полями для ввода или выбором времени (TimePicker) "Желаемое время начала" и "Желаемое время окончания" в пределах доступного диапазона.
• Клиент может заполнить предпочтения для одного или нескольких дней.
• Кнопки "Сохранить" и "Отмена".

11.7.8 Окно "Учет калорий"
Окно представляет собой дашборд, включающий ListView "Таблица учета калорий".
Редактирование разрешено только последней записи.
Поля ListView:
№ занятия (недоступно).
Наименование набора упражнений (недоступно).
Начало занятия факт (недоступно).
Длительность (недоступно).
Входящий вес (in-line). 
Полученные калории (in-line). 
Затраченные калории (недоступно).

Примечания:
Клиент, после создания занятия, вводит свой вес и полученные калории в последнюю запись в режиме in-line. Полученные калории рассчитываются за время в часах, прошедшее с окончания предыдущего занятия до начала текущего. После ввода калорий рассчитывается поле "Затраченные калории" по формуле
Затраченные калории = (BMR / 24 * coeffActivity * ΔT) + calories_out
где:
• BMR - Основной обмен веществ (ккал/день).
• 24 - количество часов в сутках.
• coeffActivity - Коэффициент активности.
• ΔT (Delta T) - Время в часах между занятиями, прошедшее с окончания предыдущего занятия до начала текущего.
• calories_out - Расход на занятии. Рассчитывается как сумма caloriesOut всех упражнений в плане, скорректированная на длительность и интенсивность.
Если занятие первое, то клиент вводит полученные калории за последние сутки и рассчитывается за последние сутки.
Пример 1: Тренировки день через день (короткий интервал)
• Данные:
o BMR = 1600 ккал/день
o coeffActivity = 1.55
o Предыдущее занятие закончилось вчера в 19:00.
o Текущее занятие началось сегодня в 10:00.
o ΔT = 15 часов (с 19:00 до 10:00 следующего дня).
o Расход на занятии = 350 ккал.
• Расчет:
1. Часовой BMR: 1600 / 24 ≈ 66.67 ккал/час
2. Расход за период между тренировками: 66.67 ккал/час * 1.55 * 15 часов ≈ 1550 ккал
3. Общий расход: 1550 ккал + 350 ккал = 1900 ккал
Пример 2: Тренировки 2 раза в неделю (длинный интервал)
• Данные:
o ΔT = 3 дня = 72 часа (с понедельника 19:00 до четверга 19:00).
o Расход на занятии = 400 ккал.
• Расчет:
1. Расход за период: 66.67 ккал/час * 1.55 * 72 часа ≈ 7440 ккал
2. Общий расход: 7440 ккал + 400 ккал = 7840 ккал
Расчет затраченных калорий на занятии является задачей бэкенд-API.

11.7.9 Окно "Прогресс"

Комплекс визуализации прогресса должен включать:
• График зависимости веса и калорий.
• График дефицита/профицита калорий.
• Индикаторы и KPI.
• Выводы системы рекомендаций.
• Интерактивные элементы.
• Адаптивный дизайн.
• Интеграция с планами тренировок.

12 Функциональный модуль "Инструктор"
12.1  Списочная форма
ListView инструкторов должна отображаться в дашбордах тренера, менеджера в окне "Инструкторы".


12.2  Дашборд "Инструктор"
Дашборд должен быть доступен как инструктору, так и тренеру, и менеджеру, и администратору.
Обозначение: InstructorDashboard.
Меню дашборда:
• Главное. Экран дашборда.
• Профиль. Экран с личной информацией.
• Клиенты
• Мой тренер.
• Мой менеджер (при включенном roleManager из файла настройки).
• Расписание.
• Табель.
• Подменю каталогов, только просмотр. 
• Инфо.

12.2.1 Окно "Клиенты"
Содержит ListView привязанных клиентов, фрейм группового чата. При выборе клиента открывается дашборд клиента.
12.2.2 Окно "Мой тренер"
Содержит фото тренера, полное ФИО, телефон, фрейм чата.
12.2.3 Окно "Мой менеджер"
Содержит фото менеджера, полное ФИО, телефон, фрейм чата.
12.2.4 Окно "Расписание"
Окно содержит персональное расписание инструктора.
12.2.5 Окно "Табель"
Окно содержит дашборд "Табель" в одиночном режиме.


13 Функциональный модуль "Тренер"
13.1 Списочная форма
ListView тренеров должна отображаться в дашборде менеджера, в окне "Тренеры". 
13.2 Дашборд "Тренер"
Дашборд должен быть доступен как тренеру, так и менеджеру, и администратору.
Обозначение: TrainerDashboard.
Меню дашборда:
• Главное. Экран дашборда.
• Профиль. Экран с личной информацией.
• Клиенты.
• Мой менеджер (при включенном roleManager из файла настройки).
• Расписание.
• Табель.
• Подменю каталогов. Тренер может создавать/редактировать только шаблоны упражнений и планов, все остальное – только просмотр.
• Инфо.

13.2.1 Окно "Клиенты"
Содержит ListView привязанных клиентов, фрейм группового чата. При выборе клиента открывается дашборд клиента.
13.2.2 Окно "Инструкторы"
Содержит ListView привязанных инструкторов, фрейм группового чата. При выборе инструктора открывается дашборд инструктора.
13.2.3 Окно "Мой менеджер"
Содержит фото менеджера, полное ФИО, телефон, фрейм чата.
13.2.4 Окно "Расписание"
Окно содержит персональное расписание тренера.
13.2.5 Окно "Табель"
Окно содержит дашборд "Табель" в одиночном режиме.


14 Функциональный модуль "Менеджер"
14.1 Дашборд "Менеджер"
Дашборд должен быть доступен как менеджеру, так и администратору.
Обозначение: ManagerDashboard.
Меню дашборда:
• Главное. Экран дашборда.
• Профиль. Экран с личной информацией.
• Клиенты
• Расписание.
• Табели.
• Подменю каталогов. Доступны для создания/редактирования записей всех каталогов, кроме "Расписание работы центра" и Дежурства сотрудников, они только для просмотра.

14.1.1 Окно "Клиенты"
Содержит ListView привязанных клиентов, фрейм группового чата. При выборе клиента открывается дашборд клиента.
14.1.2 Окно "Инструкторы"
Содержит ListView привязанных инструкторов, фрейм группового чата. При выборе инструктора открывается дашборд инструктора.
14.1.3 Окно "Тренеры"
Содержит ListView привязанных тренеров, фрейм группового чата. При выборе тренера открывается дашборд тренера.
14.1.4 Окно "Расписание"
Содержит все виды расписаний занятий, с выборкой по тренеру, инструктору, клиенту.
Содержит функционал составления общего расписания, обновления по клиенту.

14.1.5 Окно "Табели"
Окно содержит дашборд "Табель" в групповом режиме.
15 Архитектура планов тренировок
Система должна реализовывать модель разделения на Шаблоны и Индивидуальные назначения для поддержки кастомизации тренировок для каждого клиента.
15.1 Таблицы шаблонов (Templates)
Являются общей библиотекой сущностей, доступной для создания и редактирования тренерам.
o training_plan_templates
o set_exercise_templates
o exercise_templates
15.2 Таблицы индивидуальных назначений (Assignments)
Связывают клиента с его персональной версией плана тренировок, созданной на основе шаблонов. Поля в этих таблицах позволяют переопределить любые параметры шаблона (повторы, длительность, порядок, заметки).
o client_training_plans - Связь "клиент - план". Хранит активный план и историю назначений.
o client_set_exercises - Индивидуальные наборы упражнений в рамках плана клиента.
o client_exercises - Индивидуальные упражнения в рамках набора клиента.
15.3 Связь с занятиями
Таблица lessons должна быть связана с таблицей client_training_plans через foreign key, чтобы однозначно идентифицировать, какая персональная версия плана отрабатывалась на занятии.

16 Расписание занятий
16.1 Виды и шаблоны расписаний
Система должна поддерживать следующие виды расписаний и их отображение:
16.1.1 Общее расписание зала
Сводная таблица всех групповых занятий на неделю с привязкой ко времени, залу и тренеру. Должна поддерживать фильтрацию по залу и типу занятия.
16.1.2 Персональное расписание тренера и инструктора
Детальное расписание конкретного тренера с указанием клиентов, планов тренировок и статусов занятий на каждый день. Должно отображать свободные и занятые слоты.
16.1.3 Индивидуальное расписание клиента
Упрощенный вид, отображающий только занятия конкретного клиента с указанием статуса (Завершено, Запланировано, Отменено, Заморожено).
16.1.4 Коллизии предпочтений клиентов
При коллизии (см. класс ClientPreferenceSchedule), отдавать приоритет по дате-времени регистрации. 
16.1.5 Поддержка сложных сценариев
o Повторяющиеся события: Создание расписания по шаблону (ежедневно, еженедельно) на указанный период.
o Исключения: Возможность отменить одно повторяющееся событие в серии.
o Перенос: Возможность изменить время или дату одного события в серии.
o Контроль конфликтов: Система не должна позволять назначать клиенту или тренеру два занятия на одно и то же время.

16.2 Процесс составления расписания
1. Выбор плана тренировок.
2. Проверка конфликтов.
3. Генерация расписания на период.
4. UI для составления расписания.
5. Интеграция с каталогами.
16.3 Процесс работы:
1. Менеджер/Тренер выбирает дату, время, тренера.
2. Система предлагает подходящие планы тренировок based on цели клиентов.
3. Проверяются конфликты в расписании.
4. Рассчитывается длительность и калорийность.
5. Создается расписание с привязкой ко всем каталогам.
16.4 Таблицы расписания
1. Основная таблица расписания schedules.
2. Таблица связи расписания с клиентами schedule_clients.
3. Таблица повторяющихся расписаний recurring_schedules.
4. Таблица исключений расписания schedule_exceptions.
5. Таблица уведомлений о занятиях schedule_notifications.
6. Выходная таблица занятий lessons.

17 Табели
Табели составляются на сотрудников, имеющих время проведения занятий – тренерам и инструкторам.
Табели могут отображаться как на одного сотрудника, так и на группы (роли) и имеет 2 режима: одиночный и групповой.
Табель представляет собой дашборд "Табель" с элементами управления отображения и ListView времени занятий.
В дашборде «Табель» фильтр по умолчанию: archived_at IS NULL.
Администратор может включить «Показать архивных сотрудников».

1. Элементы управления:
• Выбор интервала времени. По умолчанию отображается начало текущего месяца и текущее число.
• Комбобокс "Вид сетки". Выбор разреза времени: день, неделя, месяц. По умолчанию – день. В зависимости от выбора вида сетки, формируются колонки с соответствующими заголовками, уточняющими время.
• Комбобокс "Сотрудники". Отображается только в групповом режиме. Осуществляет выбор групп сотрудников: все, тренеры, инструкторы. По умолчанию – все. 
• Экспорт. Осуществляется выбор экспорта в pdf, xlsx или csv и по кнопке "Экспорт", проводит экспорт в указанный каталог.

2. Режимы отображения табеля.
• Групповой. В левой колонке отображаются сотрудники, выбранные по значению комбобокса "Сотрудники", с общем временем по каждому и общем временем в последней строке "Всего". Далее по горизонтали отображаются колонки в зависимости от выбора комбобокса "Вид сетки". После клика по сотруднику, открывается одиночный режим.
• Одиночный. В этом режиме колонка сотрудника скрывается, ФИО сотрудника добавляется в шапку, так же добавляется колонка со всеми ФИО прикрепленными клиентами, с общем временем по каждому и общем временем в последней строке "Всего". После клика по клиенту, открывается окно "Занятия" клиента за выбранный интервал времени.

В клетках сетки табеля, по колонкам выбранного разреза, отображаются суммирующее фактическое время, полученное функцией подсчета времени занятий.

18 Подсистема рекомендаций по тренингу
Система реализует двухуровневую гибридную модель рекомендаций:
1. Core-ядро (автономное, оффлайн) — алгоритмическая система, работающая на основе данных БД и детерминированных правил. Обеспечивает базовые, безопасные рекомендации, всегда доступные независимо от подключения к внешним сервисам.
2. AI Enhancer (опциональный модуль) — внешний AI-сервис (DeepSeek, Yandex GPT и др.), который при наличии доступа обогащает рекомендации ядра персонализированными советами. Модуль реализован как отдельный опциональный компонент.
Процесс формирования рекомендаций (Core-ядро)
1. Сбор данных: Система анализирует антропометрию (anthropometry_fix, anthropometry_start), соматотип (по обхватам запястья и лодыжки), биоимпеданс (bioimpedance_start при наличии), цель и уровень подготовки клиента.
2. Анализ соматотипа: На основе значений wrist_circ и ankle_circ определяется вероятностный профиль телосложения (процентное соотношение Эктоморф/Мезоморф/Эндоморф) по правилам из каталога types_body_build.
3. Определение типа фигуры: По соотношениям обхватов плеч, талии и бедер вычисляется текущий тип фигуры: "Яблоко", "Груша", "Песочные часы", "Прямоугольник", "Перевернутый треугольник".
4. Качественная оценка: При наличии данных биоимпеданса система оценивает процент жира, мышечную массу и скорость метаболизма, добавляя качественные флаги ("высокий жир", "низкие мышцы", "медленный метаболизм").
5. Генерация рекомендации: На основе собранного "портрета" клиента система:
o Ищет наиболее подходящую запись в таблице готовых рекомендаций training_recommendations по совпадению типа фигуры, цели и уровня подготовки.
o При неполном совпадении или отсутствии записи формирует композитную рекомендацию на основе преобладающих факторов.
o Возвращает два варианта текста: детализированный для тренера (recommendation_text_trainer) и упрощённый для клиента (recommendation_text_client).
18.1 Архитектура алгоритма рекомендаций
Входные данные (от пользователя):
1. Константы: Пол, Возраст, Рост.
2. Генетические замеры (не меняются): Обхват запястья (wrist_circ), Обхват лодыжки (ankle_circ).
3. Текущие динамические замеры: Обхват плеч (shoulders_circ), груди (breast_circ), талии (waist_circ), бедер (hips_circ).
4. Данные биоимпеданса (если есть): Процент жира (fat_percentage), мышечная масса (muscle_mass), скорость основного обмена (BMR).


Рисунок алгоритма рекомендаций

Пояснения к алгоритму
Шаг 1: Определение соматотипа (Вероятностный, генетический профиль).
• Что анализируется: Обхват запястья и лодыжки + пол пользователя.
• Как работает: Система сравнивает замеры с таблицей types_body_build.
• Результат: Вероятностный профиль (например: "Эктоморф: 15%, Мезоморф: 80%, Эндоморф: 5%").
• Особенность: Учитывает генетическую предрасположенность, которая не меняется при тренировках.

• Основа: Данные клиента (пол, wrist_circ, ankle_circ) сверяются с правилами в каталоге "Типы телосложения " (таблица types_body_build).
• Логика:
1. Для каждого типа телосложения (Эктоморф, Мезоморф, Эндоморф) из каталога, подходящего по полу клиента, система рассчитывает балл близости.
2. Расчет балла для запястья:
• Если wrist_circ меньше wrist_min, балл = 0.
• Если wrist_circ между wrist_min и rule_wrist_max, балл = 100 (полное соответствие).
• Если wrist_circ больше wrist_max, балл линейно убывает от 100 до 0 на интервале от wrist_max до (wrist_max + 2 см).
3. Аналогично рассчитывается балл для лодыжки на основе ankle_circ, ankle_min, ankle_max.
4. Итоговый балл по типу = среднее арифметическое баллов для запястья и лодыжки. Если данные для лодыжки отсутствуют, используется только балл для запястья.
5. Система выполняет п.2-4 для всех трех типов.
6. Результат: Формируется профиль вида { "Эктоморф": 25, "Мезоморф": 70, "Эндоморф": 5 }, где значения - процент принадлежности (сумма процентов равна 100 после нормализации).
Шаг 2: Определение Типа Фигуры (Текущий, динамический силуэт).
• Что анализируется: Соотношение обхватов плеч, талии и бедер.
• Как работает: Математический расчет пропорций по четким правилам.
• Результат: Один из типов: "Яблоко", "Груша", "Песочные часы", "Прямоугольник", "Перевернутый треугольник".
• Особенность: Показывает текущее состояние тела, которое можно изменить.
• Основа: Обхват плеч (shoulders_circ), талии (waist_circ), бедер (hips_circ).
• Логика: Алгоритм вычисляет соотношения.
o IF (waist_circ / hips_circ >= 0.85 AND waist_circ > shoulders_circ AND waist_circ > hips_circ) THEN bodytype = 'Яблоко' (Apple).
o IF (hips_circ > shoulders_circ * 1.05) THEN bodytype = 'Груша' (Pear).
o IF (ABS(shoulders_circ - hips_circ) < 0.05 AND (waist_circ / shoulders_circ) < 0.75) THEN bodytype = 'Песочные часы' (Hourglass).
o IF (ABS(shoulders_circ - hips_circ) < 0.05 AND (waist_circ / shoulders_circ) >= 0.75) THEN bodytype = 'Прямоугольник' (Rectangle).
o IF (shoulders_circ > hips_circ * 1.05) THEN bodytype = 'Перевернутый треугольник' (Inverted Triangle).
Шаг 3: Уточнение через Биоимпеданс (Качество состава тела).
• Что анализируется: Процент жира, мышечная масса, скорость метаболизма.
• Как работает: Оценка качества тела относительно здоровых норм.
• Результат: Флаги качества ("высокий жир", "низкие мышцы", "медленный метаболизм").
• Особенность: Дает качественную оценку состава тела.

• Основа: Процент жира (fat_percentage), мышечная масса (muscle_mass), BMR.
• Логика: Алгоритм добавляет "качественную" оценку.
o Фактор ожирения: IF (fat_percentage > max_healthy_for_age_gender) THEN flag = 'high_fat'.
o Фактор худобы: IF (fat_percentage < min_healthy_for_age_gender AND muscle_mass < average) THEN flag = 'low_muscle'.
o Фактор метаболизма: IF (BMR > calculated_average_BMR * 1.1) THEN metabolism = 'fast' ELSE IF (BMR < calculated_average_BMR * 0.9) THEN metabolism = 'slow'.

Шаг 4: Комплексный анализ и вывод рекомендаций
Процесс объединения:
• Система собирает данные всех трех этапов.
• Создает комплексный "портрет" пользователя.
• Учитывает как генетику, так и текущее состояние.
Пример портрета:
• Генетика: Преимущественно мезоморф (70%) с небольшой склонностью к эндоморфу (25%).
• Фигура: "Яблоко" (скопление жира в области талии).
• Качество: Высокий процент жира, нормальные мышцы, медленный метаболизм.

• Основа: Комбинация всех полученных данных: профиль соматотипа  + bodytype + flags + metabolism.
• Логика поиска в БД:
1. Система ищет в таблице training_recommendations записи, соответствующие bodytype, goal_training_id, level_training_id.
2. Если найдено несколько записей, приоритет отдается той, которая лучше всего подходит для преобладающего соматотипа из профиля клиента.
3. Если точного совпадения нет, система формирует композитную рекомендацию. Например, если профиль клиента {"Мезоморф": 60, "Эндоморф": 40}, итоговая рекомендация может быть: "На 60% используй стратегию для мезоморфа, на 40% - стратегию для эндоморфа, уделяя внимание ...".

• Учет смешанных типов для ИИ: Сформированный профиль соматотипа и все остальные данные передаются ИИ как есть. Это позволяет ИИ генерировать truly персонализированные рекомендации, учитывающие смешанную природу телосложения пользователя.

Таблица training_recommendations (Рекомендации по тренировкам)
• body_type// тип фигуры.
• goal_training_id; // из таблицы Цели тренировок.
• level_trainig_id; //из таблицы Уровень подготовки.
• recommendation_text_trainer // Текст рекомендации для тренера.
• recommendation_text_client // Текст рекомендации для клиента.

18.2 Рекомендации на основе ИИ 
AI-обогащение (опционально)
1. При наличии настройки use_ai_recommendations = true и доступности внешнего AI-сервиса:
2. Система отправляет AI-модулю структурированный "портрет" клиента (результаты анализа ядра + исходные данные).
3. AI-модель выступает в роли эксперта-тренера, персонализируя и дополняя базовую рекомендацию:
o Предлагает конкретные упражнения с учётом смешанного типа телосложения.
o Даёт советы по питанию и восстановлению.
o Объясняет рекомендации простым языком.
Алгоритмы и таблица: Формируют структурированный, проверенный и безопасный каркас рекомендаций. Новая вероятностная модель обеспечивает гораздо более высокую точность для пользователей со смешанным типом телосложения.
ИИ-модель (LLM DeepSeek): Выступает как "креативный ассистент-эксперт", который:
• Персонализирует стандартные рекомендации под уникальный, в том числе смешанный, кейс на основе переданного профиля.
• Генерирует конкретные примеры, учитывающие нюансы смешанного типа (например, "так как у вас есть склонность к эндоморфу, несмотря на мезоморфную основу, рекомендуем...").
• Объясняет сложные концепции простым языком.
Обновленный Пример Промпта (Запроса) для ИИ:
Ты - опытный персональный тренер и диетолог с 10-летним опытом. 
Генерируй персонализированные рекомендации по тренировкам и питанию.

ОГРАНИЧЕНИЯ И ПРАВИЛА:
1. НЕ давай медицинских рекомендаций и диагнозов
2. НЕ предлагай добавки и фармакологию
3. НЕ создавай экстремальные диеты (менее 1200 ккал/день)
4. Призывай консультироваться с врачом при проблемах со здоровьем
5. Используй только научно-доказанные методы
6. Учитывай российские пищевые привычки и доступность продуктов
ДАННЫЕ ПОЛЬЗОВАТЕЛЯ:
- Пол: {пол}
- Возраст: {возраст}
- Цель: {цель_из_таблицы}
- Опыт тренировок: {уровень}
- Генетический профиль телосложения (соматотип): {рассчитанный_профиль_соматотипа} // Напр.: "Эктоморф: 15%, Мезоморф: 80%, Эндоморф: 5%"
- Актуальный тип фигуры: {тип_фигуры}
- Биоимпеданс: процент жира - {процент_жира}, мышечная масса - {мышцы}, скорость метаболизма - {BMR}.
- Основная рекомендация из нашей базы данных: "{базовая_рекомендация_из_БД}"
ОСОБОЕ ВНИМАНИЕ: Учти, что у пользователя смешанный тип телосложения. Сгенерируй рекомендации, которые объединят подходы для его преобладающего типа, но скорректируют их с учетом влияния второстепенных типов.
СФОРМУЛИРУЙ РЕКОМЕНДАЦИИ:
1. Тренировки: Предложи 2-3 конкретных упражнения, которые особенно эффективны для этого сочетания типов и цели. Объясни, почему они подходят именно для его смешанного профиля.
2. Питание: Дай совет по балансу БЖУ и калорийности, учитывающий его метаболизм и генетические склонности.
3. Образ жизни: Дай 1-2 совета по восстановлению.
4. Предупреждение: Укажи на главную ошибку, которую ему стоит избегать, исходя из его профиля.
Тон: поддерживающий, мотивирующий, профессиональный, но без сложного жаргона.
18.3 Интеграция в интерфейс
• Доступ к рекомендациям осуществляется через кнопку "Получить рекомендации" в окне "Антропометрия" клиентского дашборда.
• При нажатии открывается модальное окно "Персональные рекомендации", содержащее:
o Базовые рекомендации (из ядра системы)
o AI-обогащённые рекомендации (при наличии)
o Кнопку "Улучшить с помощью AI" для повторного запроса к AI-сервису
• Для ролей Тренер и Менеджер рекомендации также доступны в карточке клиента, с отображением детализированной версии (recommendation_text_trainer).


19 Команды (pattern Command)
Команда реализует паттерн Command. Каждая команда должна иметь спецификацию. Команда должна иметь полную логику действий – в случае нескольких операций, не разбивать их на подкоманды, а выполнять все операции в одной команде, заключая их в блоки try-catch.

Каждая команда реализует интерфейс Command<T> с методом
Future<Result<T, String>> execute();

• Команда не знает о слое UI и не возвращает виджеты.
• Все входные данные передаются через конструктор и не изменяются после создания.
• Команда логирует начало, успешное завершение и ошибку уровня INFO / ERROR.
• В случае исключения, команда перехватывает его и возвращает Failure.

Все команды, имеющие бизнес-сценарии, должны быть задачами бэкенд-API.

20 Каталоги (Catalogs)
• Все каталоги должны иметь списочную форму и карточку или дашборд. В списке должна быть панель с элементами управления: создание, клонирование, сохранение, удаление, поиск. В карточке аналогично должна быть панель элементов (без поиска), а также возможность изменения, удаления, выбора полей сущности.
• Если действия (создание, сохранение и т.д.) требуют внутреннюю логику, обращение к нескольким таблицам, то создавать отдельные команды.
• В списочной форме чек-бокс "Показать архивные" добавляет фильтр archived_at IS NOT NULL. Архивные строки выделяются серым фоном.
• Все таблицы каталогов должны иметь поле замечаний: note (VARCHAR(100));
• Работа со каталогами в полном объеме (CRUD) доступна ролям "Администратор" и "Менеджер". Роль "Тренер" имеет разрешение создавать записи, изменять и удалять. Изменять и удалять записи может только свои. Роль "Инструктор" имеет разрешение на просмотр и переход. Роли "Клиент" каталоги недоступны.

Каталог "Виды активности клиента "
Необходим для определения коэффициента активности для расчета калорийности BMR. 
Таблица kinds_activity_client
Поля:
• name (VARCHAR(100));
• coeffActivity (REAL); //Коэффициент активности.

Каталог "Уровни фитнес-подготовки"
Необходим для сопоставления с планами тренировок. 
Таблица levels_training
Поля:
• name (VARCHAR(20));

Класс LevelTrainingCatalog
Поля:
• name.

Списочная форма
Заголовок: Уровни фитнес-подготовки
Отображаемые поля: 
• Наименование (name).

Каталог "Цели тренировок"
Таблица goals_training
Поля:
• name (VARCHAR(20));
Класс GoalTrainingCatalog
Поля:
• name.

Списочная форма
Заголовок: Цели тренировок
Отображаемые поля: 
• Наименование (name).

Каталог "Виды Упражнений"
Таблица kinds_exercis
Поля:
• name (VARCHAR(100));
Класс KindExercisCatalog
Поля:
• name;

   Списочная форма
      Заголовок: Виды упражнений
      Отображаемые поля: Наименование (name).
   Карточка
      Заголовок: Вид упражнения
      Отображаемые поля: Наименование (name).
      
Каталог "Типы Упражнений"
Таблица types_exercis
Поля:
• name (VARCHAR(100));
• kind_exercis_id (BIGINT);
• equipment_type_id (BIGINT);


Класс TypeExercisCatalog
Поля:
• name;
• kindExercis;
• typeEquip;
   Списочная форма
      Заголовок: Типы упражнений
Отображаемые поля:
• Наименование (name)
• Вид упражнения (kindExercis.name)
• Фото оборудования (typeEquip.photo).
   Карточка
      Заголовок: Тип упражнения
Отображаемые поля:
• Наименование (name)
• Вид упражнения (kindExercis.name)
• Фото оборудования (typeEquip.photo).
К полю kindExercis.name привязана кнопка с действием выбора вида упражнения из списка в popup-окне.

Каталог "Упражнения"
Таблица exercises_templates
Поля:
• name (VARCHAR(100));
• repeatQty (INT);
• duration_exec (REAL);
• duration_rest (REAL);
• caloriesOut (REAL);
• is_group (BOOL, false);
• type_exercis_id (BIGINT);

Класс ExercisCatalog
Поля:
• name;
• repeatQty; //nullable (Количество повторов).
• durationExec; //Длительность проведения в минутах.
• durationRest; //Длительность отдыха после упражнения в минутах.
• caloriesOut; //Расход калорий в кал.
• isGroup; //Групповое упражнение.
• typeExercis; //Тип.

   Списочная форма
      Заголовок: Упражнения - шаблон
Отображаемые поля: 
• Фото (typeExercis.typeEquip.photo).
• Наименование (name).
• Количество повторов (repeatQty).
• Время проведения (durationExec).
• Время отдыха (durationRest).
• Расход калорий в калориях (caloriesOut).
• Групповое (isGroup).
   Карточка
      Заголовок: Упражнение - шаблон
Отображаемые поля: 
• Фото (typeExercis.typeEquip.photo).
• Наименование (name).
• Количество повторов (repeatQty).
• Время проведения (durationExec).
• Время отдыха (durationRest).
• Расход калорий в калориях (caloriesOut).
• Групповое (isGroup).

Каталог "Набор упражнений"
Таблица sets_exercises_templates
Поля:
• name (VARCHAR(100));
• level_training_id; //уровень фитнес-подготовки

Таблица отношений "Набор упражнений - Упражнения"
Обозначение: set_exercises_templates_exercis_templates
Поля: set_exercises_template_id, exercis_template_id.


Класс SetExercisCatalog
Поля:
• name;
• exercisQty (int); //расчетное, кол-во упражнений.
• durationExecSum (double); //расчетное, длительность проведения всех упражнений.
• durationRestSum(double); //расчетное, длительность отдыха упражнений.
• durationSum(double); //расчетное, durationExecSum + durationRestSum.
• caloriesOutSum (double); //расчетное, расходуемые калории. 

   Списочная форма
      Заголовок: Наборы упражнений - шаблон
Отображаемые поля: 
• Наименование (name).
• Уровень подготовки (level_training_id).
• Количество (exercisQty).
• Длительность упражнений (durationExec).
• Отдых (durationRestSum).
• Длительность набора (durationSum).
• Расход калорий (caloriesOutSum).

 Дашборд
 Заголовок: Набор упражнений - шаблон
 Отображаемые поля: 
• Наименование (name).
• Уровень подготовки (level_training_id).
• Количество (exercisQty).
• Длительность упражнений (durationExec).
• Длительность отдыха между упражнениями(durationRestSum).
• Длительность набора упражнений (durationSum).
• Расход калорий (caloriesOutSum).
Элемент дашборда представляет собой фрейм с наименованием "Упражнения". Во фрейме сверху размещается панель инструментов с активной кнопкой "Добавить" и неактивной кнопкой "Удалить".  Так же находится список упражнений, привязанный к данному набору. При выделении строки из списка, кнопка "Удалить" становится активной.
При нажатии на кнопку "Добавить" отображается popup-окно со списком всех упражнений, с неактивной кнопкой "Ок" и активной кнопкой "Отмена". По кнопке "Отмена", окно закрывается. При выделении строки из списка упражнений, кнопка "Ок" становится активной. По кнопке "Ок", окно закрывается и выбранное упражнение добавляется к списку упражнений.
При нажатии на кнопку "Удалить" удаляется id выбранного упражнения по id набора упражнений из таблицы set_exercises_exercis.
После изменения списка упражнений, все поля должны обновиться.

Каталог "Планы тренировок"
Каталог имеет записи плана тренировок – наборы упражнений в отношении один ко многим.
Таблица training_plan_templates
Поля:
• name (VARCHAR(100));
• goal_training_id (BIGINT). //из таблицы Цели тренировок

Таблица отношений "Планы тренировок – Наборы упражнений"
Обозначение: training_plan__templates_set_exercises_templates
Поля: training_plan_template_id, set_exercises_template_id.

Класс TrainingPlanCatalog
Поля:
• name;
• kindTrainingPlan; //вид плана тренировок.
• setExercisQty (int); //расчетное, кол-во наборов упражнений.
• exercisQty (int); //расчетное, кол-во упражнений.
• durationExecSum (double); //расчетное, длительность всех упражнений.
• durationRestSum(double); //расчетное, длительность отдыха упражнений.
• durationSum(double); //расчетное, durationExecSum + durationRestSum.
• caloriesOutSum (double); //расчетное, расходуемые калории. 
   
   Списочная форма
      Заголовок: Планы тренировок – шаблон
      Отображаемые поля: 
• Наименование (name).
• Вид плана тренировок (kindTrainingPlan.name).
• Длительность упражнений (durationExec).
• Длительность отдыха между упражнениями (durationRestSum).
• Длительность набора упражнений (durationSum).
• Расход калорий (caloriesOutSum).
   Дашборд
      Заголовок: План тренировок - шаблон
      Отображаемые поля: 
• Наименование (name).
• Вид плана тренировок (kindTrainingPlan.name).
• Длительность упражнений (durationExec).
• Длительность отдыха между упражнениями (durationRestSum).
• Длительность набора упражнений (durationSum).
• Расход калорий (caloriesOutSum).
Элемент дашборда представляет собой фрейм с наименованием "Наборы упражнений". Во фрейме сверху размещается панель инструментов с активной кнопкой "Добавить" и неактивной кнопкой "Удалить".  Так же находится список наборов упражнений, привязанный к данному плану. При выделении строки из списка, кнопка "Удалить" становится активной.
При нажатии на кнопку "Добавить" отображается popup-окно со списком всех наборов упражнений, с неактивной кнопкой "Ок" и активной кнопкой "Отмена". По кнопке "Отмена", окно закрывается. При выделении строки из списка упражнений, кнопка "Ок" становится активной. По кнопке "Ок", окно закрывается и выбранный набор упражнений добавляется к списку.
При нажатии на кнопку "Удалить" удаляется id выбранного набора упражнений по id плана из таблицы training_plan_set_exercises.  
После изменения списка упражнений, все поля должны обновиться.

Каталог "Заявки (Лид-менеджмент)"
Таблица onboarding_client
   Поля:
• first_name (VARCHAR(100));//Имя
• last_name (VARCHAR(100));//Фамилия
• middle_name (VARCHAR(100); //Отчество
• gender (VARCHAR(20)); //'М', 'Ж'
• age (int); //Возраст
• phone (VARCHAR(20));  //Телефон
• email (VARCHAR(100);  //E-mail
• feedback_method (VARCHAR(20));  //способ обратной связи: 'телефон' или 'почта'
• is_contact_on_website (bool); //по умолчанию – false, признак холодного контакта клиента через вебсайт
• is_client_build (bool); //признак, что на основе записи создан клиент
• client_build_at (TIMESTAMP); //дата-время создания клиента


Класс OnboardingClientCatalog
   Поля:
• firstName (string);//Имя
• lastName (string);//Фамилия
• middleName (string); //Отчество
• gender (string); //'М', 'Ж'
• age (int); //Возраст
• phone (string);  //Телефон
• email (string);  //E-mail
• feedbackMethod(string); //способ обратной связи: 'телефон' или 'почта'
• isContactOnWebsite (bool); //признак холодного контакта клиента через вебсайт
• isClientBuild (bool); //признак создания клиента
• clientBuildAt (datetime); // дата-время создания клиента
• archived_at (Timestamp)
• archived_by (BIGINT)
• note (VARCHAR(100)); //примечание


Списочная форма
Заголовок: Заявки (Лид-менеджмент)
Отображаемые поля: 
• Имя (firstName)
• Фамилия (lastName)
• Отчество (middleName)
• Пол (gender)
• Возраст (age)
• Телефон (phone)
• E-mail (email)
• Cпособ обратной связи (feedbackMethod)
• Активное (isActive)
Форма содержит панель инструментов с поиском по имени, фамилии, телефону, почте. Так же содержит чекбокс по полю isActive, по умолчанию true.
Карточка
Заголовок: Заявка (Лид-менеджмент)
Отображаемые поля:
• Имя (firstName)
• Фамилия (lastName)
• Отчество (kindEquip.name)
• Пол (gender)
• Возраст (age)
• Телефон (phone)
• E-mail (email)
• Зашел через сайт (isContactOnWebsite)
• Cпособ обратной связи (feedbackМethod)
• Активное (isActive)
• Примечание менеджера (note)

Обязательность полей при создании записи: 
• firstName;
• gender;
• age;
• phone или email. Обязательное хотя бы одно из двух.
Карточка содержит кнопку "Создать клиента", которая вызывает функцию-команду создания клиента. При успешном создании, заполняются поля isClientBuild, ClientBuildAt и isActive.

Каталог "Расписание работы центра"
Таблица work_schedules
Поля:
• day_of_week (Integer, NOT NULL, UNIQUE). День недели: 1 (Понедельник) - 7 (Воскресенье).
• start_time (Time, NOT NULL). Время начала работы (например, 09:00).
• end_time (Time, NOT NULL). Время окончания работы (например, 21:00).
• is_day_off (Boolean, default: false). Флаг, указывающий, что этот день недели по умолчанию нерабочий (например, Воскресенье).

Класс WorkSchedule
Поля:
• dayOfWeek;
• startTime;
• endTime;
• IsDayOff


Каталог "Дежурства сотрудников"
Каталог имеет записи дежурства сотрудников по центру.
Таблица employees_duty
Поля:
• user_id(BIGINT). //из таблицы users
• duty_start_at (TIMESTAMP); //время начала дежурства
• duty_finish_at (TIMESTAMP); //время окончания дежурства

Класс EmployeeDuty
Поля:
• userId; //сотрудник
• dutyManagerStartAt (DateTime); //время начала дежурства
• dutyManagerFinishAt (DateTime); //время окончания дежурства
   Списочная форма
      Заголовок: "Дежурства сотрудников"
      Отображаемые поля: 
• ФИО (userId).
• Время начала (dutyManagerStartAt).
• Время окончания (dutyManagerFinishAt).
   Дашборд
      Заголовок: "Дежурство сотрудника" + ФИО
      Отображаемые элементы: 
• ФИО (userId).
• ListView по userId с полями Время начала, Время окончания.

Каталог "Квалификации"
Каталог имеет записи квалификаций тренеров и инструкторов.
Таблица employees_qualifications
Поля:
• user_id (BIGINT); //из таблицы users
• education_level (SMALLINT); //enum employeeEducation ('высшее', 'среднее', 'курсы')
• specialization (SMALLINT); //enum employeeSpec ('фитнес', 'йога', 'реабилитация')
• qualification_date (TIMESTAMP); //дата присвоения квалификации
• education_document (URL); //скан диплома/сертификата


Класс employeeQualification
Поля:
• userId; //сотрудник
• educationLevel (Enum); //enum employeeEducation 
• specialization (Enum); //enum employeeSpec
• qualificationDate (DateTime);
• educationDocument (Image); //скан документа  
   Списочная форма
      Заголовок: "Квалификации"
      Отображаемые поля: 
• ФИО (userId);
• Уровень (educationLevel );
• Специализация (specialization);
• Дата квалификации (qualificationDate);
   Дашборд
      Заголовок: "Квалификация" + ФИО
      Отображаемые элементы: 
• ФИО (userId);
• Уровень (educationLevel );
• Специализация (specialization);
• Дата квалификации (qualificationDate);
• Скан (educationDocument);

21 Оффлайн-режим (Offline-First Approach)
21.1 Цель и Область применения
Система должна быть способна функционировать с ограниченным или полностью отсутствующим интернет-соединением для выполнения критически важных бизнес-процессов. Основной фокус — на мобильном приложении для ролей Тренер и Инструктор, которые работают непосредственно в зале, где связь может быть нестабильной.
21.2 Архитектура оффлайн-работы
• Стратегия: Offline-First. Приложение по умолчанию пытается сохранять данные локально, а затем синхронизировать их с сервером при наличии соединения.
• Локальное хранилище: Использование Hive или Sembast для быстрого и надежного локального хранения структурированных данных.
• Механизм синхронизации: Фоновая синхронизация при восстановлении соединения с использованием очереди (queue) отложенных запросов.
21.3 Функциональность, доступная оффлайн
Для Тренера/Инструктора:
• Просмотр расписания: Доступ к расписанию на текущий и следующий день.
• Просмотр карточек клиентов: Основная информация, актуальные планы тренировок, последние замеры.
• Фиксация занятий:
o Отметка начала и окончания занятия (start_fact_at, finish_fact_at).
o Ввод фактических параметров занятия (примечания, изменение упражнений "на лету").
o Ввод weight и calories_in для клиента после занятия.
• Работа с чатом: Просмотр истории чатов, отправка сообщений (доставляются при появлении сети).
Для Клиента:
• Просмотр своего расписания и деталей ближайшего занятия.
• Просмотр своего дневника калорий и прогресса.
• Ввод данных о потребленных калориях и весе.
21.4 Процесс синхронизации
1. Обнаружение сети: Приложение автоматически определяет восстановление стабильного интернет-соединения.
2. Выполнение очереди:
o Данные, созданные или измененные оффлайн, помещаются в специальную таблицу pending_sync_operations (локально).
o При появлении сети система последовательно отправляет эти данные на сервер.
3. Разрешение конфликтов:
o Стратегия: "Последнее изменение побеждает" (Last Write Wins - LWW) на основе меток времени updated_at.
o Если конфликт не может быть разрешен автоматически (например, изменение одних и тех же данных разными пользователями оффлайн), запись помечается как требующая ручного разрешения администратором/менеджером.
21.5 Ограничения оффлайн-режима
• Невозможно оффлайн:
o Первоначальная регистрация и вход в систему (требует аутентификации).
o Составление нового расписания.
o Генерация сложных отчетов.
o Получение онлайн-рекомендаций от ИИ.
o Работа с каталогами (создание/редактирование шаблонов упражнений).
• Уведомления: Push-уведомления не доставляются оффлайн. Локальные уведомления (напоминания о начале занятия) работают.
21.6 Требования к данным
• Кэширование при запуске: При наличии сети приложение заранее кэширует данные, необходимые для работы в течение дня:
o Активное расписание пользователя.
o Карточки прикрепленных клиентов (тренеру).
o Активные планы тренировок.
o Последние сообщения в чатах.
• Политика устаревания кэша: Локальные данные считаются актуальными в течение 24 часов. При попытке работы с устаревшим кэшем система показывает предупреждение.
21.7 Пользовательский интерфейс
• Индикатор статуса: В верхней части интерфейса всегда отображается значок:
o Зеленый / "Online" — стабильное соединение.
o Желтый / "Синхронизация..." — идет процесс синхронизации.
o Красный / "Оффлайн" — соединение отсутствует.
• Уведомления: При отправке данных в оффлайне появляется сообщение "Сообщение будет отправлено при подключении к сети". После успешной синхронизации — "Все данные синхронизированы".
21.8 Техническая реализация
dart
// Примерная структура очереди синхронизации
class PendingSyncOperation {
  String id;
  String tableName; // 'lessons', 'track_calories', etc.
  String operation; // 'INSERT', 'UPDATE'
  Map<String, dynamic> data;
  DateTime timestamp;
  int retryCount;
}

22 Архивация и восстановление записей
1. В каждой таблице обязательно присутствуют два служебных поля:
archived_at timestamp with time zone NULL – дата/время архивации;
archived_by bigint NULL – ссылка на users(id), кто архивировал.
NULL в обоих полях означает «запись активна».
2. Архивация выполняется командой ArchiveEntityCommand (паттерн Command), которая:
проверяет право «Архивировать» у текущей роли;
заполняет archived_at = now(), archived_by = current_user_id;
пишет запись в audit_log (действие = ‘ARCHIVE’).
3. Восстановление – командой RestoreEntityCommand, которая:
сбрасывает archived_at и archived_by в NULL;
пишет в audit_log действие ‘RESTORE’.
4. На всех таблицах создаётся RLS-политика (или эквивалентный механизм БД):
sql 
USING (archived_at IS NULL)
Политика действует для ролей «Клиент», «Инструктор», «Тренер», «Менеджер».
Роль «Администратор» видит записи без ограничений.
5. Списочные формы по умолчанию не выводят архивные строки. Чек-бокс «Показать архивные» добавляет условие archived_at IS NOT NULL.
6. Экспорт/отчёты/API-методы, не предназначенные для администратора, автоматически фильтруют archived_at IS NULL.
7. Физическое удаление (DELETE) запрещено; используется только логическое удаление через архивацию.


23 Аудит и журнал событий (Audit Log)
1. Цель
Обеспечить полную прослеживаемость изменений любых данных системы (клиенты, сотрудники, расписания, справочники, архивация/восстановление) без физического хранения версий строк.
2. Единая таблица аудита
Создаётся одна таблица на всю БД:
sql 
CREATE TABLE audit_log (
id            bigserial PRIMARY KEY,
table_name    text      NOT NULL,                       -- имя таблицы-источника
row_pk        bigint    NOT NULL,                       -- PK изменённой строки
action        text      NOT NULL CHECK (action IN (
 'INSERT','UPDATE','DELETE','ARCHIVE','RESTORE')),
changed_at    timestamptz DEFAULT now(),
changed_by    uuid      REFERENCES users(id),
old_values    jsonb,                                    -- предыдущие значения (NULL при INSERT)
new_values    jsonb                                     -- новые значения (NULL при DELETE)
);
3. Триггеры
Для каждой таблицы автоматически создаются триггеры AFTER INSERT, AFTER UPDATE, AFTER DELETE (через миграцию или генератор кода).
Триггер:
заполняет table_name = TG_TABLE_NAME,
row_pk = NEW.id / OLD.id,
action по типу операции,
changed_by = current_user_id() (из RLS-сессии),
old_values = to_jsonb(OLD), new_values = to_jsonb(NEW).
При архивации/восстановлении (команды ArchiveEntityCommand / RestoreEntityCommand) триггер фиксирует action = 'ARCHIVE' или 'RESTORE'.
4. Доступ к журналу
• Просмотр аудита доступен только роли Администратор.
• В карточке любой сущности кнопка «История» открывает список записей audit_log отфильтрованных по table_name + row_pk, отсортированных по changed_at DESC.
• Для удобства чтения поля old_values/new_values отображаются в виде сворачиваемого JSON-дерева; значения дат/чисел форматируются по текущей локали.
5. Хранение и ротация
Строки хранятся 36 месяцев.
Ежедневным cron-Job (pg_cron или внешний планировщик) удаляются записи старше 36 мес:
sql 
DELETE FROM audit_log WHERE changed_at < now() - interval '36 months';
6. Производительность
Индексы:
(table_name, row_pk, changed_at DESC) – быстрая выборка истории строки.
(changed_at) – быстрая чистка старых данных.
Триггеры объявляются FOR EACH ROW, но только при первичной записи (без каскадных UPDATE-ов) чтобы избежать рекурсии.
7. Интерфейс
• Списочная форма «Аудит» (доступна только администратору): фильтры по периоду, таблице, пользователю, типу действия; экспорт в CSV/XLSX.
• Виджет «Последние изменения» на дашборде администратора: 10 последних записей системы.
8. Безопасность
• Таблица audit_log не подлежит архивации (archived_at не добавляется).
• Прямое изменение/удаление строк audit_log запрещено триггером BEFORE DELETE / UPDATE (только SELECT и INSERT).
• Маскировка чувствительных данных: перед записью в new_values/old_values поля password_hash, sms_code, jwt_refresh_token обнуляются ('::text = '***').


24 Файл настроек приложения
Файл настроек приложения должен быть типовым средством фреймворка технологического стека. В файле должны содержаться следующие ключи:
Контактный телефон (contactPhone).
• E-mail (contactEmail).
• Посылать уведомления (sendNotification).
• Уведомление до начала занятий (часов) (hourNotification).
• SMS-шлюз (smsGate).
• Роль инструктора (roleInstructor). Включение и отключение (по умолчанию) роли инструктора.
• Роль менеджера (roleManager). Включение (по умолчанию) и отключение роли менеджера.
• Учет калорий (trackCalories). Включение (по умолчанию) и отключение функционала учета калорий клиентов.

• Текст приглашения для клиента (invitationText).
• Время жизни ссылки-приглашения (часы) (invitationLinkTTL).
• SMTP-хост (smtpHost).
• SMTP-порт (smtpPort).
• SMTP-логин (smtpLogin).
• SMS-шлюз URL (smsGateUrl).
   
   Файл настроек доступен только администратору.



25 
Сайт компании
   Сайт компании выполняет две ключевые функции: 
• Маркетинговую для привлечение новых клиентов.
• Служит точкой входа в веб-версию приложения для существующих пользователей.
25.1 Общие требования к дизайну и архитектуре
• Стиль: Строгий, лаконичный, корпоративный. Академичный подход с акцентом на надежность и профессионализм. Минимум декоративной графики.
• Технологии: Веб-сайт должен быть реализован как Single Page Application (SPA) на Flutter Web, что обеспечит единообразие дизайна и логики с мобильными приложениями.
• Адаптивность: Сайт должен корректно отображаться и функционировать на устройствах с разным разрешением экрана (десктоп, планшет, смартфон).
• Навигация: Интуитивно понятное главное меню, расположенное в шапке сайта. Меню должно быть доступно на всех страницах.
25.2 Структура и содержание страниц
Сайт состоит из следующих обязательных страниц:
• Главная страница («О компании»):
o Краткое описание фитнес-центра, его философия, преимущества.
o Блок с ключевыми показателями (количество довольных клиентов, лет на рынке и т.д.).
o Призыв к действию (CTA) "Оставить заявку".
o Призыв к скачиванию apk мобильной версии на Андроид.
• Контакты:
o Адрес центра с интерактивной картой (Google Maps/Яндекс.Карты).
o Телефон, email, график работы.
o Форма для обратной связи (упрощенный аналог блока "Составить заявку").
• Расписание работы: Информация о работе центра по дням недели. Данные должны подгружаться из таблицы work_schedules (только для чтения).
• FAQ: Страница с ответами на часто задаваемые вопросы.
• Отзывы: Модуль для отображения отзывов реальных клиентов.
25.3 Функциональные блоки
25.3.1 Блок «Составить заявку» (Форма лида)
Это ключевой маркетинговый элемент, доступный на главной странице и в виде всплывающего модального окна на других страницах.
• Поля формы:
1. Имя (обязательное, текст).
2. Пол (обязательное, выпадающий список: Мужской, Женский).
3. Возраст (обязательное, число).
4. Телефон (условно-обязательное, валидация формата).
5. Email (условно-обязательное, валидация формата).
6. Способ обратной связи (обязательное, радиокнопки: "По телефону", "По email"). Логика: если выбран телефон, обязательным становится поле "Телефон", и наоборот.
• Логика работы:
1. Валидация на стороне клиента: При попытке отправить форму проверяется заполненность обязательных полей и корректность формата. Ошибки выводятся рядом с полями.
2. Отправка данных: При нажатии кнопки "Отправить" данные формы отправляются методом POST на защищенный (HTTPS) API-эндпоинт бэкенда (например, /api/leads).
3. Обработка на сервере: Бэкенд создает запись в таблице onboarding_client и запускает процесс уведомления дежурного менеджера (как описано в разделе об онбординге).
4. Реакция на клиенте: После успешной отправки форма скрывается, а пользователю показывается сообщение: "Спасибо! Ваша заявка принята. Наш менеджер свяжется с вами в ближайшее время.".
25.3.2 Блок «Личный кабинет»
Это веб-интерфейс основного приложения, доступный после аутентификации.
• Страница входа:
o Поля: "Логин (Email/Телефон)" и "Пароль".
o Кнопка "Войти".
o Ссылка "Забыли пароль?" (запускает стандартный процесс сброса через email).
• Функциональность после входа:
o После успешной аутентификации пользователь перенаправляется на дашборд, соответствующий его роли (Клиент, Тренер, Менеджер, Администратор).
o Функциональность веб-дашбордов на 100% идентична функциональности мобильного приложения, описанной в разделах "Функциональный модуль «Клиент»", «Тренер» и т.д.
o Интерфейс должен быть оптимизирован для управления с помощью мыши и клавиатуры, но сохранять общую стилистику мобильного UI.
25.4 Интеграция с основной системой
• API: Веб-сайт общается с бэкендом через те же API и RESTful эндпоинты, что и мобильное приложение.
• Аутентификация: Используется единая система аутентификации. Сессия, открытая в браузере, не должна конфликтовать с сессией в мобильном приложении.
• Данные: Данные для страниц "Расписание работы" и др. должны браться напрямую из БД основной системы, чтобы избежать дублирования и расхождения информации.
25.5 Требования к контенту и SEO
• Контент: Все тексты на сайте должны быть уникальными, грамотными и отражать специфику центра.
• Мета-теги: Настройка title, description и keywords для каждой страницы.
• Скорость загрузки: Оптимизация изображений и кода для быстрой загрузки страниц, что критично для SEO и удержания пользователей.



26 Интеграция с системами бухгалтерского учета
Данный раздел описывает архитектуру, механизмы и требования к интеграции системы «Фитнес-менеджер» с внешними бухгалтерскими и финансовыми системами на примере типовой интеграции с «1С:Предприятие».
Интеграция обеспечивает двусторонний обмен ключевыми бизнес-данными для автоматизации учёта клиентов, платежей, абонементов и посещений.
26.1 Общие положения
Цель интеграции:
Автоматизация передачи финансово-учётных данных между FitMan и бухгалтерской системой для исключения ручного ввода, минимизации ошибок и обеспечения актуальности данных в обеих системах.
Основные принципы:
• Двусторонняя синхронизация: Данные могут передаваться как из FitMan в 1С, так и в обратном направлении (например, обновление реквизитов клиента).
• Поддержка различных конфигураций 1С: Интеграция должна быть гибкой и настраиваемой под типовые конфигурации («1С:Бухгалтерия», «1С:Зарплата и управление персоналом», «1С:Управление торговлей»).
• Надёжность и отказоустойчивость: Использование очереди сообщений, повторные попытки отправки, логирование всех операций.
• Безопасность: Все данные передаются по защищённым каналам (HTTPS), используются ключи API, чувствительные данные шифруются.
26.2 Синхронизируемые сущности и сценарии
26.2.1 Клиенты (физические лица)
• Направление: В основном FitMan → 1С (при создании/обновлении клиента).
• Данные: ФИО, пол, дата рождения, контакты (телефон, email), дата регистрации.
• Сценарий: Новый клиент регистрируется в FitMan → его карточка автоматически создаётся в 1С как контрагент (физическое лицо).
26.2.2 Платежи и финансовые операции
• Направление: FitMan → 1С.
• Данные: Сумма, дата и время оплаты, тип платежа (абонемент, разовое занятие, товар), способ оплаты (наличные, карта, перевод), привязка к клиенту и договору.
• Сценарий: Клиент оплачивает абонемент через кассу FitMan → платёж фиксируется в 1С как приходный кассовый ордер (ПКО) или поступление на расчётный счёт.
26.2.3 Абонементы и договоры оказания услуг
• Направление: Двусторонняя.
• Данные: Тип абонемента (месячный, годовой, разовый), срок действия, стоимость, статус (активен, приостановлен, завершён), привязка к клиенту.
• Сценарий: Менеджер оформляет в FitMan новый абонемент клиенту → в 1С создаётся документ «Договор оказания услуг» или регистрируется продажа услуги.
26.2.4 Посещения и оказанные услуги (для аналитики и расчёта зарплаты)
• Направление: FitMan → 1С.
• Данные: Факт посещения клиентом занятия (дата, время, тип услуги), привязка к тренеру (для расчёта вознаграждения).
• Сценарий: После завершения занятия в FitMan фиксируется факт оказания услуги → данные передаются в 1С для учёта выручки и расчёта зарплаты тренера.
26.3 Архитектура и механизм обмена
26.3.1 Общая схема
Интеграция построена по принципу асинхронного обмена через очередь сообщений.
FitMan выступает инициатором событий, помещая задачи в очередь. Отдельный сервис (воркер) обрабатывает очередь и взаимодействует с веб-сервисом 1С через REST API.
FitMan → [Очередь задач] → Сервис синхронизации → [REST API] → 1С

26.3.2 Компоненты системы
1. Таблица конфигурации интеграции (integration_1c_config) – хранит настройки подключения к конкретному экземпляру 1С.
2. Очередь задач (integration_1c_queue) – хранит отложенные операции синхронизации.
3. Сервис-воркер – фоновый процесс, который:
o Забирает задачи из очереди.
o Формирует и отправляет запросы в 1С.
o Обрабатывает ответы, обновляет статусы задач, выполняет повторные попытки при ошибках.
4. REST API в 1С – набор веб-сервисов (HTTP-ендпоинтов), разработанных в конфигурации 1С для приёма и отправки данных.
26.3.3 Модель данных для обмена (Dart-модели)
dart
// Конфигурация подключения к 1С
class Integration1CConfig {
  String id;
  String baseUrl; // URL веб-сервиса 1С (например, https://1c.company.com/ws/fitman)
  String apiKey; // Ключ авторизации для доступа к API 1С
  SyncSettings syncSettings; // Настройки синхронизации
  List<EntityMapping> entityMappings; // Соответствие полей между системами
  bool isActive; // Включена ли интеграция
}

// Настройки синхронизации
class SyncSettings {
  bool autoSyncEnabled; // Автоматическая фоновая синхронизация
  Duration syncInterval; // Интервал (например, каждые 5 минут)
  List<String> syncEntities; // Какие сущности синхронизировать: ['client', 'payment', 'subscription']
  DateTime lastSuccessfulSync; // Время последней успешной синхронизации
}

// Соответствие полей сущности между FitMan и 1С
class EntityMapping {
  String fitmanEntity; // Название сущности в FitMan ('client')
  String externalCode; // Код соответствующей сущности в 1С
  Map<String, String> fieldMappings; // {'first_name': 'Имя', 'last_name': 'Фамилия'}
}
26.4 Техническая реализация
26.4.1 Структура таблиц в PostgreSQL
sql
-- Таблица конфигурации интеграции
CREATE TABLE integration_1c_config (
    id BIGSERIAL PRIMARY KEY,
    base_url VARCHAR(500) NOT NULL,
    api_key VARCHAR(500) NOT NULL,
    is_active BOOLEAN DEFAULT FALSE,
    sync_interval_minutes INTEGER DEFAULT 60,
    auto_sync_enabled BOOLEAN DEFAULT FALSE,
    last_successful_sync TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    company_id BIGINT DEFAULT -1
);

-- Очередь синхронизации
CREATE TABLE integration_1c_queue (
    id BIGSERIAL PRIMARY KEY,
    entity_type VARCHAR(50) NOT NULL, -- 'client', 'payment', 'subscription', 'visit'
    entity_id BIGINT NOT NULL, -- ID сущности в FitMan
    operation VARCHAR(20) NOT NULL, -- 'create', 'update', 'delete'
    payload JSONB NOT NULL, -- Данные сущности в формате JSON
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'processing', 'sent', 'error'
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    company_id BIGINT DEFAULT -1
);

-- Логи синхронизации (для аудита и отладки)
CREATE TABLE integration_1c_logs (
    id BIGSERIAL PRIMARY KEY,
    log_level VARCHAR(20) NOT NULL, -- 'info', 'warning', 'error'
    message TEXT NOT NULL,
    details JSONB, -- Дополнительные данные (например, тело запроса/ответа)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    company_id BIGINT DEFAULT -1
);
26.4.2 Сервис синхронизации (Dart)
dart
import 'dart:convert';
import 'package:http/http.dart' as http;

class Integration1CService {
  final HttpClient httpClient;
  final Integration1CConfig config;
  
  // Основной метод синхронизации (вызывается по расписанию или вручную)
  Future<SyncResult> syncData() async {
    try {
      // 1. Получаем pending-задачи из очереди
      final pendingItems = await _getPendingQueueItems();
      
      // 2. Группируем по типам сущностей для batch-отправки
      final groupedItems = _groupByEntityType(pendingItems);
      
      // 3. Отправляем пачки данных в 1С
      for (final entityType in groupedItems.keys) {
        await _sendBatchTo1C(entityType, groupedItems[entityType]!);
      }
      
      // 4. Опционально: запрашиваем обновления из 1С (если настроена двусторонняя синхронизация)
      if (config.syncSettings.syncDirection == 'bidirectional') {
        await _fetchUpdatesFrom1C();
      }
      
      await _logSyncSuccess();
      return SyncResult.success();
    } catch (e) {
      await _logSyncError(e);
      return SyncResult.error(e.toString());
    }
  }
  
  // Отправка пачки данных одного типа
  Future<void> _sendBatchTo1C(String entityType, List<QueueItem> items) async {
    final payload = {
      'entity_type': entityType,
      'items': items.map((item) => item.payload).toList(),
      'sync_timestamp': DateTime.now().toIso8601String(),
    };
    
    final response = await httpClient.post(
      Uri.parse('${config.baseUrl}/api/sync'),
      headers: {
        'Authorization': 'Bearer ${config.apiKey}',
        'Content-Type': 'application/json',
      },
      body: jsonEncode(payload),
    );
    
    if (response.statusCode == 200) {
      // Помечаем задачи как успешно отправленные
      await _markItemsAsSent(items);
    } else {
      // Обрабатываем ошибку (логируем, увеличиваем счётчик повторов)
      await _handleSyncError(items, response);
    }
  }
}
26.5 Интерфейс управления интеграцией
Интерфейс для администратора должен находиться в разделе «Администрирование» → «Интеграции» и включать:
1. Панель статуса:
o Статус подключения (✅/❌).
o Время последней успешной синхронизации.
o Количество неотправленных сообщений в очереди.
2. Настройки подключения:
o Поля для ввода URL веб-сервиса 1С, API-ключа.
o Переключатель «Интеграция активна».
o Выбор сущностей для синхронизации (чекбоксы: Клиенты, Платежи, Абонементы).
3. Управление синхронизацией:
o Кнопка «Синхронизировать сейчас» (ручной запуск).
o Переключатель «Автоматическая синхронизация» с настройкой интервала.
4. Мониторинг и логи:
o Таблица с последними операциями (статус, сущность, ошибка).
o Фильтры по дате, типу сущности, статусу.
o Кнопка «Экспорт логов».
26.6 Обработка ошибок и повторные попытки
Для обеспечения надёжности реализована стратегия повторных попыток (retry policy):
dart
class SyncErrorHandler {
  static const maxRetries = 3;
  static const retryDelays = [
    Duration(minutes: 1),
    Duration(minutes: 5),
    Duration(minutes: 15)
  ];
  
  Future<void> handleSyncError(QueueItem item, dynamic error) async {
    if (item.retryCount < maxRetries) {
      // Повторная попытка с увеличением задержки
      final delay = retryDelays[item.retryCount];
      await _rescheduleItem(item, delay);
      await _logWarning('Повторная попытка отправки ${item.entityType}#${item.entityId} через ${delay.inMinutes} мин.');
    } else {
      // Превышено максимальное число попыток - требуется вмешательство администратора
      await _notifyAdmin(
        'Критическая ошибка синхронизации',
        'Сущность: ${item.entityType}, ID: ${item.entityId}. Ошибка: ${error.toString()}'
      );
      await _markItemAsFailed(item, 'Превышено максимальное число попыток: $error');
    }
  }
}
26.7 Требования к API 1С
Со стороны 1С должен быть реализован REST API, поддерживающий как минимум следующие методы:
1. POST /api/sync – приём пачки данных от FitMan.
2. GET /api/sync/status – проверка доступности и статуса.
3. GET /api/clients/updates?since=... – получение обновлённых данных клиентов из 1С (для двусторонней синхронизации).
Формат запроса/ответа – JSON.
Обязательна авторизация по API-ключу в заголовке Authorization: Bearer <key>.
26.8 Рекомендации по внедрению
1. Этапность: Начать с синхронизации Клиентов и Платежей, затем добавить Абонементы и Посещения.
2. Тестирование: Перед включением в production выполнить тестовую синхронизацию с тестовой базой 1С.
3. Мониторинг: Настроить оповещения администратора при накоплении ошибок в очереди (>10 ошибок подряд).
4. Документация: Составить документ «Инструкция по настройке интеграции с 1С» для администраторов заказчика.


Нефункциональные требования


26 Требования к технологическому стеку
Технологический стек должен обеспечивать полную независимость от внешних BaaS-провайдеров, отсутствие контейнеризации, соответствие российским требованиям безопасности и возможность развертывания на собственной инфраструктуре заказчика.
26.1 Серверная часть
Backend Framework

**Основной стек:**
- **Язык:** Dart 3.0+
- **Фреймворк:** Dart Frog или Shelf
- **HTTP сервер:** Dart native (dart:io)
- **Реальное время:** WebSocket + Redis Pub/Sub

База данных
**Основная БД:** 
- **Система:** PostgreSQL 15+
- **Хостинг:** Отдельный сервер или VPS
- **Миграции:** Dart-пакет `moor` или собственные скрипты

**Расширения PostgreSQL:**
- pg_trgm - для полнотекстового поиска
- btree_gin - для составных индексов
- uuid-ossp - для генерации UUID

**Репликация:** 
- Настройка master-slave репликации
- Автоматические бэкапы

Кэширование и реальное время
**Redis сервер:**
- **Назначение:** Pub/Sub для реального времени, кэширование
- **Конфигурация:** Отдельный инстанс Redis 7+
- **Использование:**
  - WebSocket сообщения через Pub/Sub
  - Кэш сессий пользователей
  - Временное хранение токенов
  - Очереди задач
26.2 Клиентская часть
Мобильные приложения

**Фреймворк:** Flutter 3.0+
- **Язык:** Dart 3.0+
- **Состояние:** Riverpod 2.0
- **Навигация:** Go Router
- **Локальное хранилище:** Hive 2.0

**Поддерживаемые платформы:**
- Android 8.0+ (API 26+)
- iOS 13.0+
- **Сборка:** Ручная компиляция APK/IPA

Веб-приложение

**Фреймворк:** Flutter Web
- **Режим сборки:** CanvasKit для производительности
- **Роутинг:** Browser history API
- **PWA:** Service Worker для оффлайн-работы

**Хостинг:** 
- Статические файлы на nginx
- NAS хранилище для медиа-файлов
26.3 Инфраструктура
Серверное окружение
**Операционная система:**
- **Основная:** Ubuntu 22.04 LTS
- **Альтернативная:** Debian 11+

**Веб-сервер:**
- **Прокси:** Nginx 1.20+
- **SSL:** Let's Encrypt или коммерческий сертификат
- **Балансировка:** На уровне nginx (при масштабировании)

**Управление процессами:**
- **Инит-система:** Systemd
- **Логирование:** Journald + ротация логов
- **Мониторинг:** Prometheus + Grafana (опционально)

Файловое хранилище
**Локальное хранилище:**
- **Структура:** 
  `/opt/fitman/storage/`
  ├── uploads/     # Пользовательские файлы
  ├── avatars/     # Фотографии профилей
  ├── documents/   # Сканы документов
  └── backups/     # Резервные копии

26.4 Установка и развертывание
Способ дистрибуции
**Серверная часть:**
- **Формат:** Самодостаточный инсталлятор (.run)
- **Содержимое:** 
  - Бинарные файлы Dart приложения
  - Скрипты установки PostgreSQL/Redis
  - Конфигурационные файлы nginx
  - Systemd unit files

**Мобильные приложения:**
- **Android:** APK файлы для скачивания с сайта
- **iOS:** TestFlight для тестирования, App Store для продакшена
26.5 Процесс установки
bash
# Пример установочного скрипта
#!/bin/bash
# fitman-installer.run

echo "Установка Фитнес-Менеджера..."

# Автоматическая установка зависимостей
apt-get install -y postgresql postgresql-contrib redis-server nginx

# Настройка БД
sudo -u postgres psql -c "CREATE USER fitman_user WITH PASSWORD '${DB_PASSWORD}';"
sudo -u postgres psql -c "CREATE DATABASE fitman OWNER fitman_user;"

# Развертывание приложения
cp -r application /opt/fitman/
chown -R www-data:www-data /opt/fitman

# Запуск сервисов
systemctl enable fitman.service
systemctl start fitman.service
26.6 Безопасность
Аутентификация и авторизация
**Механизм аутентификации:**
- **Токены:** JWT (JSON Web Tokens)
- **Алгоритм:** HS256 или RS256
- **Время жизни:** Access token - 24 часа, Refresh token - 7 дней

**Защита API:**
- **HTTPS:** Обязательно для всех endpoints
- **CORS:** Настройка для доменов клиента
- **Rate Limiting:** Ограничение запросов по IP/пользователю
26.7 Защита данных
**Шифрование:**
- **Пароли:** bcrypt с salt rounds = 12
- **Чувствительные данные:** AES-256 в базе данных
- **Транспорт:** TLS 1.3 для всех соединений

**Резервное копирование:**
- **Частота:** Ежедневные полные бэкапы
- **Хранение:** Отдельный защищенный сервер
- **Шифрование:** GPG для резервных копий
26.8 Мониторинг и логирование
Система мониторинга
**Встроенные метрики:**
- Нагрузка CPU, памяти, диска
- Количество активных пользователей
- Время ответа API endpoints
- Статус WebSocket соединений

**Внешний мониторинг:**
- **Доступность:** Zabbix или UptimeKuma или UptimeRobot
- **Логи:** Centralized logging через rsyslog
- **Оповещения:** Telegram bot для критических ошибок

Логирование
dart
// Пример системы логирования
class AppLogger {
  static final Logger _logger = Logger();
  
  static void setupLogging() {
    Logger.root.level = Level.INFO;
    Logger.root.onRecord.listen((record) {
      // Запись в файл с ротацией
      _writeToFile(record);
      // Отправка в syslog для критических ошибок
      if (record.level >= Level.SEVERE) {
        _sendToSyslog(record);
      }
    });
  }
}
26.9 Производительность и масштабирование
Оптимизация базы данных
sql
-- Пример индексов для производительности
CREATE INDEX CONCURRENTLY idx_users_email ON users(email);
CREATE INDEX CONCURRENTLY idx_chats_company ON chats(company_id);
CREATE INDEX CONCURRENTLY idx_messages_chat_date ON messages(chat_id, created_at DESC);

-- Частичные индексы для архивных данных
CREATE INDEX idx_active_users ON users(id) WHERE archived_at IS NULL;

Стратегия масштабирования
**Вертикальное масштабирование:**
- Увеличение ресурсов VPS (CPU, RAM, SSD)
- Настройка репликации PostgreSQL
- Кэширование часто запрашиваемых данных

**Горизонтальное масштабирование (при росте):**
- Добавление application-серверов
- Балансировка нагрузки через nginx
- Шардирование базы данных
26.10 Резервные копии и восстановление
Процедуры бэкапа
**Автоматические бэкапы:**
- **База данных:** pg_dump ежедневно в 02:00
- **Файлы приложения:** rsync раз в неделю
- **Конфигурации:** Git-репозиторий с историей изменений

**Восстановление:**
- Скрипт автоматического восстановления из бэкапа
- Пошаговые инструкции для ручного восстановления
- Регулярные тесты восстановления


27 Требования к таблицам
База данных системы – PostgreSQL.
• В каждой таблице должно быть поле id (BIGSERIAL) с primary key.
Имена foreign key полей должны соответствовать шаблону: <имя_таблицы_в_единственном_числе>_id.
• В каждой таблице должно быть поле company_id (BIGINT) для мультитенантности. По умолчанию равно -1.
• Индексы должны быть добавлены на все поля, используемые в условиях JOIN и WHERE, в частности, на все foreign key поля.
• Имена и поля таблиц должны быть в snake_case нотации.
• Способ удаления записей -- логическая архивация: заполняются поля archived_at, archived_by. Физический DELETE запрещён.
• Поле для фото – тип URL, ссылка на файл с фото в хранилище
• Не использовать встроенный тип ENUM. Вместо него использовать SMALLINT, в нем значение enum в коде. 
• Не использовать строковый тип как перечисления. Вместо него использовать SMALLINT, в нем значение enum в коде.
• Тип дата/время должен быть timestamp with time zone.
• Для оперативного аудита, все таблицы должны иметь поля:
• "Дата Создания" (created_at (TIMESTAMP)) 
• "Дата Изменения" (updated_at (TIMESTAMP))
• "Создан пользователем" (created_by (BIGINT FK → users(id)))
• "Изменен пользователем" (updated_by (BIGINT FK → users(id))).
Поля created_at, created_by, необходимо учитывать при добавлении записи. Поля updated_at, updated_by, необходимо учитывать при обновлении запросов.
• Для архивации и восстановления записей, все таблицы должны включать поля:
• archived_at (TIMESTAMP NULL)
• archived_by (BIGINT FK → users(id))

28 Требования к логированию приложения
Логирование должно осуществляться средствами технологического стека. Логирование должно иметь 4 уровня важности сообщения: отладочное, информационное, предупреждение, ошибка. Максимальный уровень, по которому сообщения будут записываться, записывается в файл настроек приложения. Сообщения должны записываться в суточный файл формата "EFT_YYYY_MM_DD", где YYYY_MM_DD – год, месяц и день. Сообщение, кроме отладочного, должно выводиться на экран.


29 Требования к безопасности
Данный раздел описывает меры, направленные на обеспечение конфиденциальности, целостности и доступности данных системы, а также на защиту от несанкционированного доступа.
29.1 Аутентификация и авторизация
• Многофакторная аутентификация (MFA). Система должна предоставлять возможность включения MFA для ролей Администратор, Менеджер и Тренер.
• Политика паролей. Пароли пользователей должны храниться в базе данных исключительно в виде хешей с использованием современных алгоритмов (например, bcrypt/scrypt/Argon2).
• Минимальная длина пароля — 8 символов.
• Пароль должен содержать как минимум одну заглавную букву, одну строчную букву, одну цифру и один специальный символ.
• Запрещено использовать простые или скомпрометированные пароли.
• Защита от brute-force. Система должна блокировать учетную запись или вводить задержку после 5 неуспешных попыток ввода пароля в течение 15 минут.
• JWT Tokens. Время жизни Access Token должно быть ограничено (например, 15-30 минут).
• Обязательно использование Refresh Tokens с ограниченным временем жизни (например, 7 дней) и механизмом их отзыва.
• Tokens должны быть подписаны с использованием надежного алгоритма (например, RS256).
• Управление сессиями. При выходе из системы или по истечении времени неактивности (30 минут) сессия пользователя должна быть полностью завершена на стороне клиента и сервера.

29.2 Контроль доступа (Authorization)
• Принцип наименьших привилегий. Каждая роль в системе должна иметь доступ только к тем данным и функциям, которые абсолютно необходимы для выполнения ее задач.
• Row Level Security (RLS)  Для базы данных PostgreSQL  **обязательно** должна быть настроена политика RLS на всех таблицах, содержащих персональные или бизнес-данные. Доступ к данным должен предоставляться на основе роли пользователя и его идентификатора.
• Валидация на стороне сервера. Все запросы к API, включая проверки прав доступа к объектам, должны быть валидированы на стороне бэкенда. Недостаточно проверять права только на фронтенде.

29.3 Защита данных
• Все данные должны передаваться по защищенному протоколу **HTTPS/TLS 1.2+**.
• Чувствительные данные (например, пароли, персональные данные клиентов) должны шифроваться при хранении в базе данных или использовать механизмы шифрования.
• Маскирование данных. При отображении конфиденциальной информации (например, телефона, email) в интерфейсах для некоторых ролей следует применять маскирование (например, `+7 *** *** ** 12`).
• Безопасное хранение секретов. Ключи API, секреты для подписи JWT, учетные данные для внешних сервисов (SMS-шлюз) не должны храниться в коде или репозитории. Необходимо использовать защищенные механизмы хранения секретов.
• Доступ к архивным записям возможен только роли «Администратор». Остальные роли видят только активные записи (RLS-политика archived_at IS NULL).
29.4 Безопасность API
• Защита от перебора (Rate Limiting).  API должен быть защищен от DDoS-атак и перебора паролей путем ограничения количества запросов с одного IP-адреса или для одной учетной записи в единицу времени.
• Валидация входных данных. Все входные данные, поступающие в API (параметры запросов, тела запросов), должны быть строго валидированы на предмет типа, длины, диапазона и наличия потенциально опасных конструкций (SQL-инъекции, XSS).

29.5 Защита на клиенте (Frontend).
• Защита от XSS. Данные, предоставляемые пользователями (например, комментарии, имена), должны быть экранированы перед отображением в интерфейсе для предотвращения межсайтового скриптинга.
• Безопасные заголовки HTTP. Приложение должно использовать security headers (например, Content-Security-Policy, X-Frame-Options, X-Content-Type-Options) для защиты от различных видов атак.

29.6 Аудит и мониторинг
• Логирование событий безопасности. В логи приложения должны записываться все критичные события:
• Неудачные попытки входа в систему.
• Попытки доступа к запрещенным ресурсам (ошибки 403).
• Изменение критичных настроек системы, прав пользователей.
• Создание, изменение и удаление учетных записей пользователей.
• Мониторинг. Система должна иметь возможность мониторинга подозрительной активности, с уведомлением ответственных лиц (Администратор).

29.7 Резервное копирование и восстановление
• Регулярное резервное копирование. Должна быть обеспечена процедура регулярного (ежедневного) резервного копирования базы данных и критичных файлов.
• План восстановления. Должен быть документирован и протестирован план восстановления работы системы после сбоя в течение не более 4 часов.



30 Требования к тестированию
• Реализовать юнит-тесты по всем командам.
• Реализовать интеграционные тесты по каждой роли.


31 Дополнительные требования
31.1 Добавить диаграмму БД.
• ER-диаграмму отношений между таблицами
• Схему связей и индексов

31.2 Уточнить API endpoints.
• REST API методы для каждого модуля
• Форматы запросов/ответов

Архитектурные требования
32 Редакции продукта
32.1 Редакция Basic
Эта редакция является текущей.
Основной функционал:
• Для будущей мультитенантности вводится поле company_id во все таблицы.
• Система лицензий и ограничений.
• Весь функционал в Basic-качестве.
Для: малых фитнес-залов, студий, персональных тренеров
Ограничения: 1 филиал, до 100 клиентов, до 3 тренеров

32.2 Редакция Pro
Основной функционал:
• Мультитенантная архитектура.
• Расширенная аналитика.
• White-label.
• API для интеграций.
Для: средних клубов, сетей в одном городе, мультибрендовых операторов
Ограничения: мультитенантность, до 500 клиентов, до 10 тренеров

32.3 Редакция Enterprise
Основной функционал:
• Филиальная и мультитенантная архитектура.
• Корпоративная отчетность.
• Сложные интеграции.
Для: федеральных сетей, крупных клубов с филиалами
Ограничения: неограниченно, филиальная структура


Архитектура с учетом трех версий
Базовая версия:
  - Единая база данных
  - Простая схема tenant_id = 1
  - Ограничения через application logic

Pro версия:
  - Schema-based мультитенантность
  - Отдельные схемы для каждого tenant
  - Общие справочники

Enterprise версия:
  - База данных на филиал + общая сводная
  - Репликация между филиалами
  - Единый каталог пользователей


Глоссарий

• Списочная форма – виджет-экран со списочным представлением (ListView).
• Карточка – виджет-экран с детальным представлением (DetailView).
• Дашборд – виджет-экран с вложенными виджетами.
• Фрейм – виджет-контейнер для группировки других виджетов.
• BMR - Basal Metabolic Rate (Основной обмен веществ).
• Дефицит/профицит калорий - разница между потребленными и затраченными калориями.
• Мультитенантность - архитектура для работы с несколькими независимыми клиентами в одной системе
• Филиальность - иерархическая структура подразделений с единым управлением




