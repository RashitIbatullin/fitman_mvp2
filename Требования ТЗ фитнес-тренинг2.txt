







Требования
к техническому заданию
на разработку ПО 

"Фитнес-менеджер" (FitMan)


Оглавление	
Оглавление	2
Введение	3
Цель проекта	3
Общие сведения	3
Функциональные сведения	5
Краткое описание функциональных процессов	5
Функциональные требования	6
1	Основной функционал системы	6
2	Роли пользователей и их функции в системе	10
3	Система управления группами	12
4	Управление помещениями и оборудованием	23
5	Онбординг (Lead Management)	31
6	Подсистема уведомлений (Notification Service)	33
7	Подсистема чата (Messaging)	35
8	Подсистема отчетности (Reporting & Analytics)	38
9	Подсистема управления пользователями (User Management)	41
10	Функциональный модуль "Администратор"	46
11	Функциональный модуль "Клиент"	49
12	Функциональный модуль "Инструктор"	58
13	Функциональный модуль "Тренер"	60
14	Функциональный модуль "Менеджер"	61
15	Архитектура планов тренировок	61
16	Расписание занятий	62
17	Табели	63
18	Подсистема рекомендаций по тренингу	64
19	Команды (pattern Command)	72
20	Каталоги (Catalogs)	72
21	Оффлайн-режим (Offline-First Approach)	86
22	Архивация и восстановление записей	88
23	Аудит и журнал событий (Audit Log)	89
24	Файл настроек приложения	91
25	Сайт компании	92
26	Интеграция с системами бухгалтерского учета	95
Нефункциональные требования	101
26	Требования к технологическому стеку	101
27	Требования к таблицам	105
28	Требования к логированию приложения	105
29	Требования к безопасности	105
30	Требования к тестированию	108
31	Дополнительные требования	108
Архитектурные требования	108
32	Редакции продукта	108
Глоссарий	111



Введение
Цель проекта
Создание веб-приложения уровня предприятия с мобильным клиентом, для автоматизации процессов фитнес-центра с основным функционалом:
• ведение шаблонов и индивидуальных планов тренировок;
• контроль и учёт занятий;
• управление расписанием индивидуальных и групповых занятий;
• система онбординга клиентов;
• система уведомлений о занятиях, групповых чатов;
• контроль биологических показателей, прогрессии тренировок;
• учет полученных и затраченных калорий;
• рекомендации по тренингу;
• управление персоналом (тренеры, инструкторы, менеджеры, администраторы);
• ведение табелей сотрудников;
• ведение отчетности по клиентам, сотрудникам, занятиям, центру.

Общие сведения
ПараметрЗначениеНаименованиеФитнес-менеджер (FitMan)ТипКорпоративное приложениеЦелевая аудиторияФитнес-центры малого и среднего бизнесаПлатформыiOS, Android, WebТехнологический стекFlutter (Client) + Dart Frog/Shelf (Server) + PostgreSQLРазмещениеVPS без контейнеризации и baas


Функциональные сведения
ПараметрЗначениеТип системыОтраслевое решение для автоматизации фитнес-центровУправление бизнес-процессами   - Учет рабочего времени персонала
   - Управление расписанием и ресурсами
   - Учет занятий клиентовСпециализированный фитнес-функционал
   - Планирование и учет тренировок
   - Отслеживание прогресса клиентов
   - Учет полученных и затраченных калорий
   - Рекомендательная подсистема
Аналитика и отчетность
   - Бизнес-аналитика для руководства
   - Отчеты по эффективности тренеров
   - Анализ клиентской базы

Краткое описание функциональных процессов
Клиенты занимаются в фитнес-центре, согласно расписанию тренировок, под руководством назначенного тренера и инструктора. 
Тренер составляет групповые и индивидуальные планы тренировок. Он проводит индивидуальные занятия, может задавать прогресс нагрузок на основе плана тренировок. Тренер осуществляет общее руководство занятиями прикрепленных клиентов.
Инструктор в основном проводит групповые занятия. Так же может помочь тренеру провести индивидуальное занятие, вести учет времени. Если он имеет права, может создавать планы тренировок, задавать прогресс и т.п., аналогично функционалу тренера. 
У тренеров и инструкторов есть табель учета занятий, который составляется по факту проведения занятий.
Менеджер (куратор) осуществляет контроль за бизнес-процессами центра. Контролирует ведение журналов прикрепленных клиентов, инструкторов, тренеров. Также совместно с тренером ведет расписание тренировок. Назначенный дежурный менеджер ведет онбординг клиентов.
Администратору доступны все функции менеджера, также управляет системным функционалом, осуществляет контроль за системой.



Функциональные требования
1 Основной функционал системы 
1.1 Планирование и учет занятий с учётом инфраструктуры
Составление расписания занятий происходит с учетом:
• Пожеланий клиентов по дням недели и времени
• Доступности и загрузки залов (помещений)
• Наличия необходимого оборудования
• Расписания тренеров и инструкторов
Клиент в своём дашборде указывает предпочтительные дни и время занятий. При автоматическом составлении общего расписания система учитывает эти предпочтения, а также проверяет доступность залов и оборудования. Возможен вариант ручного обновления расписания для отдельного клиента с учётом текущей загрузки инфраструктуры.

1.2 Учет и анализ полученных и затраченных калорий
План тренировок состоит из тренировочных дней или занятий. Занятие включает набор упражнений с указанием повторов или времени выполнения.
Каждое упражнение имеет средний расход калорий. Система автоматически суммирует расход по упражнениям для занятия и по занятиям для плана тренировок.
Перед занятием клиент вносит количество потребленных калорий и свой текущий вес. После тренировки система автоматически рассчитывает затраченные калории, учитывая:
• Основной обмен веществ (BMR)
• Калории, потраченные непосредственно на занятии
• Оборудование, использованное на занятии
Клиент может сравнивать приход и расход калорий в таблице, а также просматривать графики зависимости калорий и веса от времени.

1.3 Система рекомендаций по плану тренировок на основе антропометрии, соматотипов, биоимпеданса
Система реализует двухуровневую гибридную модель рекомендаций:
1. Core-ядро (автономное, оффлайн) — алгоритмическая система, работающая на основе данных БД и детерминированных правил. Обеспечивает базовые, безопасные рекомендации, всегда доступные независимо от подключения к внешним сервисам.
2. AI Enhancer (опциональный модуль) — внешний AI-сервис (DeepSeek, Yandex GPT и др.), который при наличии доступа обогащает рекомендации ядра персонализированными советами. Модуль реализован как отдельный опциональный компонент.

1.4 Индивидуальные планы тренировок на основе шаблонов
Система реализует модель разделения на Шаблоны и Индивидуальные назначения тренировок клиента. Такая архитектура позволяет тренеру гибко настраивать прогрессию нагрузок для каждого клиента, изменяя параметры в таблицах назначений, без изменения исходных шаблонов.

1.5 Управление пользователями через роли
Роль представляет собой набор прав доступа и полномочий, позволяющих пользователю выполнять определенные действия в системе. Такой подход упрощает администрирование, обеспечивает единообразие и безопасность, так как позволяет назначать права группам пользователей, а не каждому отдельно.
В системе реализованы следующие роли: клиент, инструктор, тренер, менеджер, администратор.
Пользователь может иметь несколько ролей, что легко и гибко расширяет набор прав доступа. Например, для небольших фитнес-залов, где тренер является единственной штатной единицей, можно добавить ему роли менеджера и администратора. Или, как вариант, роли инструктора и менеджера отключить вообще.
1.6 Двухуровневая система группирования клиентов
1.6.1 Тренировочные группы (TrainingGroup)
Для организации групповых занятий с фиксированным составом:
• Имеют привязку к основному тренеру и инструктору
• Используют конкретные залы и оборудование
• Имеют фиксированное расписание занятий
• Автоматически создают групповые чаты
Нет автоматического обновления состава (только ручное управление)
1.6.2 Аналитические группы (AnalyticGroup)
Для сегментации клиентов по различным критериям:
• Финансовые: по статусу оплаты, типу абонемента
• Демографические: по возрасту, полу
• Поведенческие: по активности, посещаемости
• Корпоративные: клиенты компаний-партнёров
• Произвольные: ручное создание
Могут быть автоматическими — состав обновляется по заданным условиям без ручного вмешательства.
1.7 Управление инфраструктурой фитнес-центра
1.7.1 Помещения и залы
• Учёт всех помещений фитнес-центра с характеристиками (вместимость, площадь, оснащение)
• Контроль доступности и загрузки залов
• Управление расписанием работы помещений
• Отслеживание технического состояния
1.7.2 Оборудование
• Типы оборудования: справочник с характеристиками (кардио, силовое, свободные веса и т.д.)
• Экземпляры оборудования: учёт конкретных единиц с инвентарными номерами
• Контроль состояния и доступности
• Бронирование оборудования для занятий
• Упрощённый учёт технического обслуживания
1.7.3 Интеграция с тренировочным процессом
• Автоматическая проверка доступности залов и оборудования при планировании занятий
• Резервирование инфраструктуры для тренировочных групп
• Учёт использования оборудования в статистике
1.8 Онбординг (привлечение и активация клиентов)
Процесс превращения потенциального клиента в активного пользователя:
1. Управление лидами (заявками через сайт или телефон)
2. Активация учётной записи через пригласительные ссылки
3. Первоначальное знакомство с инфраструктурой: ознакомление с доступными залами и оборудованием
1.9 Комплексная отчетность и аналитика
• Отчетность по клиентам: динамика базы, посещаемость, прогресс
• Отчетность по сотрудникам: загрузка тренеров, эффективность
• Отчетность по инфраструктуре: загрузка залов, использование оборудования
• Финансовая отчетность (при интеграции с финансовыми системами)
• Экспорт отчетов в PDF, Excel форматы
1.10 Оффлайн-режим и синхронизация
• Оффлайн-работа для критически важных функций (фиксация занятий, ввод данных)
• Автоматическая синхронизация при восстановлении соединения
• Кэширование расписания и данных об инфраструктуре для работы без сети

1.11 Система безопасности и контроля доступа
• Ролевая модель доступа (RBAC)
• Row Level Security в базе данных
• Аудит всех действий пользователей
• Защита персональных данных клиентов
1.12 Мультиплатформенность и адаптивность
• Мобильные приложения для iOS и Android
• Веб-версия для администрации и клиентов
• Адаптивные интерфейсы для разных устройств
• Единая база данных для всех платформ
1.13 Универсальность развёртывания и инфраструктурная независимость
Система разработана с учетом требований малого и среднего бизнеса фитнес-индустрии и обладает максимальной гибкостью в развёртывании:
• Независимость от инфраструктуры: Система может работать на любом стандартном оборудовании без специфических требований к виртуализации или контейнеризации.
• Прямое развёртывание: Установка производится напрямую на операционную систему без промежуточных слоев абстракции.
• Полный контроль данных: Все данные остаются на стороне заказчика, без зависимостей от внешних BaaS-провайдеров.


2 Роли пользователей и их функции в системе
2.2 Клиент.
Пользователь системы, занимающийся в фитнес-центре под руководством тренера.
Функции:
• Аутентификация;
• Ввод антропометрии. Ввод входящих калорий и веса. Ввод предпочтений занятий. Просмотр графиков калорий и веса, просмотр расписания.

2.3 Инструктор.
Помощник тренера. Контролирует занятия, назначенных клиентов.
Функции:
• Аутентификация;
• Просмотр списка назначенных клиентов и открытие карточки клиента из списка;
• Ввод входящих калорий и входящего веса клиента. Просмотр графиков калорий и веса клиента;
• Просмотр расписания клиента, своего расписания и табеля;
• Коррекция плана занятия дня (списка упражнений);
• Фиксация начала и окончания занятия.
• Просмотр списка назначенных тренеров и открытие карточки из списка.

2.4 Тренер.
Тренирует клиентов. Контролирует занятия, назначенных клиентов и инструкторов. Составляет планы тренировок, назначает планы клиентам.
Функции:
• Аутентификация;
• Просмотр списка назначенных клиентов и открытие карточки клиента из списка;
• Ввод входящих калорий и входящего веса клиента. Просмотр графиков калорий и веса клиента;
• Коррекция плана занятия дня (списка упражнений);
• Фиксация начала и окончания занятия.
• Доступ к кнопке "Подобрать прогрессии" в карточке клиента;
• Выбор прогрессии тренировок;
• Смена плана тренировок до первого занятия клиента;
• Просмотр списка прикрепленных инструкторов и открытие карточки из списка.
• Просмотр расписания клиента, своего расписания и табеля, расписание и табель закрепленного инструктора;

2.5 Менеджер.
Контролирует тренировочные бизнес-процессы. Контроль за назначенными клиентами, инструкторами, тренерами.
Функции:
• Аутентификация;
• Ведение записей клиентов, инструкторов, тренеров.
• Ведение расписаний и табелей всех участников бизнес-процесса.
• Ведение обординга клиентов.

2.6 Администратор.
Администрирует систему.
Функции:
• Аутентификация;
• Ведение (просмотр, добавление, удаление, изменение записей) каталогов.
• Ведение записей клиентов, инструкторов, тренеров, менеджеров.
• Ведение расписания работы центра.
• Редактирование настроек системы.

Управление доступом пользователя осуществляется на основе ролей.
В структуре проекта на каждую роль должен отводиться свой модуль-каталог.


3 Система управления группами
   3.1 Общие положения
Система управления группами предназначена для организации работы с клиентами фитнес-центра через два принципиально разных типа групп:
    Тренировочные группы (TrainingGroup) - для проведения групповых занятий с фиксированным составом участников
    Аналитические группы (AnalyticGroup) - для сегментации клиентов по различным критериям для аналитики, маркетинга и управления
3.2 Тренировочные группы (TrainingGroup)
3.2.1 Назначение

Тренировочные группы предназначены для организации регулярных групповых занятий с фиксированным составом участников. Они используются в расписании занятий и имеют прямые связи с персоналом, оборудованием и локациями.

3.2.2 Модель данных

class TrainingGroup {
  String id;
  String name;
  String description;
  
  // ПЕРСОНАЛ (обязательные для тренировочного процесса)
  String primaryTrainerId;     // Основной тренер группы (обязательно)
  String? primaryInstructorId; // Основной инструктор группы
  String? responsibleManagerId; // Ответственный менеджер
  
  // СОСТАВ ГРУППЫ (фиксированный)
  List<String> clientIds;      // Фиксированный состав участников
  
  // РАСПИСАНИЕ ЗАНЯТИЙ
  List<GroupScheduleSlot> scheduleSlots;
  
  // ПАРАМЕТРЫ ТРЕНИРОВКИ
  String? programId;           // Ссылка на программу тренировок
  String? goalId;              // Цель тренировок (похудение, набор массы и т.д.)
  String? levelId;             // Уровень подготовки группы
  
  // ЛИМИТЫ И ОГРАНИЧЕНИЯ
  DateTime startDate;          // Дата начала работы группы
  DateTime? endDate;           // Дата окончания (если предусмотрена)
  int maxParticipants;         // Максимальное количество участников
  int currentParticipants;     // Текущее количество участников

  // ПОМЕЩЕНИЕ И ОБОРУДОВАНИЕ
  String? primaryRoomId;     // Основной зал для занятий
  List<String> requiredEquipmentIds; // Необходимое оборудование

  // СТАТУС И СВЯЗИ
  bool isActive;               // Активна ли группа
  String? chatId;              // Ссылка на групповой чат (создается автоматически)
}

3.2.3 Расписание группы (GroupScheduleSlot)

class GroupScheduleSlot {
  String id;
  String groupId;
  int dayOfWeek;          // 1-7 (понедельник-воскресенье)
  TimeOfDay startTime;
  TimeOfDay endTime;
  bool isActive;
}

3.2.4 Правила тренировочных групп

    Фиксированный состав - состав участников изменяется только вручную тренером или менеджером
    Обязательный тренер - каждая группа должна иметь основного тренера
    Четкое расписание - группа имеет расписание занятий на неделю
    Прямое участие в расписании - группа используется при создании занятий в модуле расписания

    Автоматический чат - при создании группы автоматически создается групповой чат

3.2.5 Бизнес-процессы

    Создание группы: Тренер или менеджер создает группу, назначает тренера, настраивает расписание
    Набор участников: Ручное добавление клиентов в группу с проверкой лимита
    Проведение занятий: Занятия создаются на основе расписания группы
    Закрытие группы: При достижении endDate группа переводится в неактивное состояние

   3.3 Аналитические группы (AnalyticGroup)
3.3.1 Назначение

Аналитические группы предназначены для сегментации клиентов по различным критериям для целей:
• Маркетинг и рассылки
• Аналитика и отчетность
• Управление клиентской базой
• Финансовый контроль

3.3.2 Типы аналитических групп

enum AnalyticGroupType {
  corporate,      // Корпоративные клиенты
  demographic,    // Демографические (возраст, пол)
  financial,      // Финансовые (статус оплаты, тип абонемента)
  behavioral,     // Поведенческие (активность, посещаемость)
  custom          // Произвольные (ручное создание)
}

3.3.3 Модель данных

class AnalyticGroup {
  String id;
  String name;
  String description;
  AnalyticGroupType type;
  
  // АВТОМАТИЧЕСКОЕ ОБНОВЛЕНИЕ
  bool isAutoUpdate;           // true - группа автоматически обновляется по условиям
  List<GroupCondition> conditions; // Условия для автоматических групп
  
  // ДИНАМИЧЕСКИЙ СОСТАВ
  List<String> clientIds;      // Кэшированный список клиентов в группе
  DateTime lastUpdatedAt;      // Время последнего обновления
  
  // ДОПОЛНИТЕЛЬНЫЕ ДАННЫЕ
  Map<String, dynamic> metadata; // Дополнительные данные по типам
}

3.3.4 Условия для автоматических групп (GroupCondition)

class GroupCondition {
  String field;        // Поле для условия (например, 'age', 'subscription_type')
  String operator;     // Оператор ('equals', 'greater_than', 'less_than', 'contains')
  String value;        // Значение для сравнения
}

3.3.5 Правила аналитических групп

    Динамический состав - состав может обновляться автоматически по условиям
    Нет связи с тренировками - группы не участвуют в расписании занятий
    Для аналитики - используются в отчетах, рассылках, анализе
    Гибкая настройка - могут быть как автоматическими, так и ручными

3.3.6 Бизнес-процессы

    Автоматическое обновление: Система ежедневно пересчитывает состав автоматических групп
    Массовые операции: Рассылки, уведомления для всех участников группы
    Аналитика: Построение отчетов по сегментам клиентов
    Управление: Контроль задолженностей, работа с неактивными клиентами

   3.4 Структура таблиц
3.4.1 Таблица тренировочных групп

CREATE TABLE training_groups (
  id BIGSERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  
  -- Персонал
  primary_trainer_id BIGINT NOT NULL REFERENCES users(id),
  primary_instructor_id BIGINT REFERENCES users(id),
  responsible_manager_id BIGINT REFERENCES users(id),
  
  -- Программа тренировок
  program_id BIGINT REFERENCES training_plan_templates(id),
  goal_id BIGINT REFERENCES goals_training(id),
  level_id BIGINT REFERENCES levels_training(id),
  
  -- Лимиты
  max_participants INT NOT NULL DEFAULT 15,
  current_participants INT DEFAULT 0,
  
  -- Жизненный цикл
  start_date DATE NOT NULL,
  end_date DATE,
  is_active BOOLEAN DEFAULT true,
  
  -- Связи
  chat_id BIGINT REFERENCES chats(id),
  
  -- Системные поля
  company_id BIGINT DEFAULT -1,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by BIGINT REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  archived_at TIMESTAMPTZ,
  archived_by BIGINT REFERENCES users(id)
);

3.4.2 Таблица расписания групп

CREATE TABLE group_schedule_slots (
  id BIGSERIAL PRIMARY KEY,
  group_id BIGINT NOT NULL REFERENCES training_groups(id),
  day_of_week SMALLINT NOT NULL, -- 1-7
  start_time TIME NOT NULL,
  end_time TIME NOT NULL,
  is_active BOOLEAN DEFAULT true
);

3.4.3 Таблица участников тренировочных групп 
CREATE TABLE training_group_members (
  id BIGSERIAL PRIMARY KEY,
  training_group_id BIGINT NOT NULL REFERENCES training_groups(id) ON DELETE CASCADE,
  user_id BIGINT NOT NULL REFERENCES users(id),
  joined_at TIMESTAMPTZ DEFAULT NOW(),
  added_by BIGINT REFERENCES users(id),
  UNIQUE(training_group_id, user_id)
);

3.4.4 Таблица аналитических групп (analytic_groups)

CREATE TABLE analytic_groups (
  id BIGSERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  type SMALLINT NOT NULL, -- 0:corporate, 1:demographic, 2:financial, 3:behavioral, 4:custom
  
  -- Автоматическое обновление
  is_auto_update BOOLEAN DEFAULT false,
  conditions JSONB, -- Условия для автоматических групп
  
  -- Метаданные
  metadata JSONB, -- Дополнительные данные
  
  -- Кэшированный состав
  client_ids_cache JSONB,
  last_updated_at TIMESTAMPTZ,
  
  -- Системные поля
  company_id BIGINT DEFAULT -1,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by BIGINT REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  archived_at TIMESTAMPTZ,
  archived_by BIGINT REFERENCES users(id)
);

   3.5 Архитектура и расположение кода
3.5.1 Бэкенд

backend/lib/
├── models/groups/
│   ├── training_group.dart
│   ├── analytic_group.dart
│   ├── group_schedule_slot.dart
│   └── group_condition.dart
├── controllers/groups/
│   ├── training_groups_controller.dart
│   ├── analytic_groups_controller.dart
│   ├── group_schedule_controller.dart
│   └── group_members_controller.dart
└── services/
    └── group_sync_service.dart  # Сервис синхронизации аналитических групп

3.5.2 Фронтенд

frontend/lib/
├── models/groups/
│   ├── training_group.dart
│   ├── analytic_group.dart
│   ├── group_schedule_slot.dart
│   └── group_condition.dart
├── providers/groups/
│   ├── training_groups_provider.dart
│   ├── analytic_groups_provider.dart
│   └── group_schedule_provider.dart
├── screens/admin/groups/
│   ├── training_groups_screen.dart
│   ├── analytic_groups_screen.dart
│   ├── training_group_edit_screen.dart
│   └── analytic_group_edit_screen.dart
└── widgets/groups/
    ├── training_group_card.dart
    ├── analytic_group_card.dart
    └── group_member_list.dart

   3.6 Интеграция с другими модулями
3.6.1 С модулем расписания (раздел 17)

    Тренировочные группы используются при создании групповых занятий
    Автоматическая подстановка тренера, инструктора и состава группы
    Проверка доступности зала и оборудования

3.6.2 С модулем чата (раздел 8)

    При создании тренировочной группы автоматически создается групповой чат
    Участники чата: клиенты группы, тренер, инструктор, менеджер
    Для аналитических групп чаты не создаются автоматически

3.6.3 С модулем отчетности (раздел 9)

    Отчеты по эффективности тренировочных групп
    Аналитика по сегментам клиентов (аналитические группы)
    Отслеживание динамики состава групп

3.6.4 С модулем уведомлений (раздел 7)

    Уведомления о расписании групповых занятий
    Массовые рассылки для аналитических групп
    Напоминания о необходимости продления участия в группе

   3.7 Пользовательские интерфейсы
3.7.1 Дашборд управления группами

    Вкладка "Тренировочные группы" - список групп с возможностью просмотра состава и расписания
    Вкладка "Аналитические группы" - список групп с фильтрами по типам

3.7.2 Форма создания/редактирования тренировочной группы

    Основные параметры (название, описание)
    Выбор тренера, инструктора, менеджера
    Настройка расписания (дни недели, время)
    Установка лимитов и сроков

3.7.3 Форма создания/редактирования аналитической группы

    Выбор типа группы
    Настройка условий для автоматических групп
    Ручной выбор участников для неавтоматических групп
    Настройка дополнительных параметров

   3.8 Ограничения и валидация
3.8.1 Тренировочные группы

    Максимальное количество участников не может быть меньше текущего
    Дата окончания не может быть раньше даты начала
    Обязательное наличие тренера

3.8.2 Аналитические группы

    Условия должны быть корректными и выполнимыми
    Для автоматических групп должен быть хотя бы один участник после обновления
4 
Управление помещениями и оборудованием
   4.1 Общие положения
Модуль управления помещениями и оборудованием обеспечивает базовый учёт инфраструктуры фитнес-центра.
• Контроль расположения оборудования
• Управление доступностью залов
• Учёт состояния оборудования
• Интеграция с тренировочным процессом
   4.2 Структура помещений
4.2.1 Модель помещения (Room)
dart
class Room {
  String id;
  String name;              // "Зал 1", "Кардио-зона", "Йога-студия"
  String? description;
  RoomType type;            // Тип помещения
  
  // Локация (если многоэтажный центр)
  String? floor;            // "1 этаж"
  String? building;         // "Корпус А"
  
  // Вместимость и параметры
  int maxCapacity;          // Максимальная вместимость (чел.)
  double area;              // Площадь (м²)
  bool hasMirrors;          // Есть зеркала
  bool hasSoundSystem;      // Есть аудиосистема
  
  // Расписание доступности
  TimeOfDay? openTime;      // Время открытия
  TimeOfDay? closeTime;     // Время закрытия
  List<int> workingDays;    // Рабочие дни (1-7)
  
  // Статус
  bool isActive;            // Активно ли помещение
  bool isUnderMaintenance;  // На ремонте
  String? maintenanceNote;  // Причина ремонта
  DateTime? maintenanceUntil; // До какого числа ремонт
  
  // Оборудование в помещении (кэшированный список)
  List<String> equipmentIds;
  
  // Фотографии
  List<String> photoUrls;
  String? floorPlanUrl;     // Схема расстановки
  String? note;
}
4.2.2 Типы помещений (RoomType)
dart
enum RoomType {
  groupHall,      // Зал групповых занятий
  cardioZone,     // Кардио-зона
  strengthZone,   // Силовая зона
  mixedZone,      // Смешанная зона
  studio,         // Студия (йога, пилатес)
  boxingRing,     // Бокс/единоборства
  pool,           // Бассейн
  lockerRoom,     // Раздевалка
  reception,      // Ресепшен
  office,         // Офис
  other           // Прочее
}
   4.3 Категории оборудования
4.3.1 Категории оборудования (EquipmentCategory)
dart
enum EquipmentCategory {
  cardio,           // Кардио-оборудование
  strength,         // Силовые тренажёры
  freeWeights,      // Свободные веса
  functional,       // Функциональное оборудование
  accessories,      // Аксессуары
  measurement,      // Измерительное оборудование
  other             // Прочее
}

// Комментарий: Используется только в коде для классификации.
// В БД хранится как SMALLINT. Нет отдельной таблицы категорий.
   4.4 Типы оборудования (EquipmentType)
4.4.1 Назначение
Справочник типов оборудования с базовыми характеристиками. 
4.4.2 Модель типа оборудования (EquipmentType)
dart
class EquipmentType {
  String id;
  String name;                // "Гантели", "Беговая дорожка"
  String? description;
  
  // Классификация
  EquipmentCategory category; // Категория (cardio, strength, etc.)
  EquipmentSubType subType;   // Подтип (опционально)
  
  // Базовые характеристики
  String? weightRange;        // "1-30 кг" (для свободных весов)
  String? dimensions;         // "80x150x200 см"
  String? powerRequirements;  // "220V, 2.5kW" (для электрических)
  bool isMobile;              // Мобильное оборудование
  
  // Связи
  String? exerciseTypeId;     // Связь с типом упражнения (type_exercis)
  
  // Медиа
  String? photoUrl;           // Фото оборудования
  String? manualUrl;          // Инструкция (опционально)
  
  // Статус
  bool isActive;              // Активен ли тип
}
4.4.3 Подтипы оборудования (EquipmentSubType)
dart
// Комментарий: Для детализации внутри категорий
// Примеры для cardio: treadmill, elliptical, bike, rower
// Примеры для freeWeights: dumbbell, barbell, kettlebell, plate
// В БД хранится как SMALLINT
   4.5 Экземпляры оборудования (EquipmentItem)
4.5.1 Назначение
Учёт конкретных физических единиц оборудования. Каждый экземпляр имеет инвентарный номер и отслеживается индивидуально.
4.5.2 Модель экземпляра оборудования (EquipmentItem)
dart
class EquipmentItem {
  String id;
  String typeId;              // Ссылка на EquipmentType
  String inventoryNumber;     // Внутренний инвентарный номер "ГАН-001"
  String? serialNumber;       // Заводской серийный номер (опционально)
  String? model;              // Модель "Matrix T7xe"
  String? manufacturer;       // Производитель
  
  // Локация
  String? roomId;             // Где находится (ссылка на Room)
  String? placementNote;      // "У окна, рядом с колонной"
  
  // Состояние
  EquipmentStatus status;     // available, inUse, maintenance
  int conditionRating;        // 1-5 (5 = отличное)
  String? conditionNotes;     // "Поцарапана панель, работает нормально"
  
  // Техническое обслуживание (упрощённое)
  DateTime? lastMaintenanceDate;
  DateTime? nextMaintenanceDate;
  String? maintenanceNotes;   // "Заменили ремень"
  
  // Покупка/учёт
  DateTime? purchaseDate;
  double? purchasePrice;
  String? supplier;
  int? warrantyMonths;        // Гарантия в месяцах
  
  // Использование
  int usageHours;             // Накопленные часы использования
  DateTime? lastUsedDate;
  
  // Фотографии конкретного экземпляра
  List<String> photoUrls;
}
4.5.3 Статусы оборудования (EquipmentStatus)
dart
enum EquipmentStatus {
  available,     // Доступно
  inUse,         // Используется (во время занятия)
  reserved,      // Забронировано
  maintenance,   // На обслуживании/ремонте
  outOfOrder,    // Неисправно
  storage,       // На складе
}
   4.6 Бронирование оборудования
4.6.1 Модель бронирования (EquipmentBooking)
dart
class EquipmentBooking {
  String id;
  String equipmentItemId;     // Конкретный экземпляр
  String bookedById;          // Кто забронировал (тренер/менеджер)
  
  // Время бронирования
  DateTime startTime;
  DateTime endTime;
  
  // Контекст
  String? lessonId;           // Для какого занятия
  String? trainingGroupId;    // Для какой группы
  String purpose;             // "Групповое занятие", "Индивидуальная тренировка"
  
  // Статус
  BookingStatus status;       // confirmed, active, completed, cancelled
  
  // Дополнительно
  String? notes;              // Особые пожелания
}
   4.7 Структура таблиц
4.7.1 Помещения (rooms)
sql
-- Таблица помещений
CREATE TABLE rooms (
  id BIGSERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  type SMALLINT NOT NULL,           -- RoomType enum
  
  -- Локация
  floor VARCHAR(50),                -- "1 этаж"
  building VARCHAR(100),            -- "Корпус А"
  
  -- Характеристики
  max_capacity INT NOT NULL DEFAULT 10,
  area DECIMAL(5,2),                -- площадь в м²
  has_mirrors BOOLEAN DEFAULT false,
  has_sound_system BOOLEAN DEFAULT false,
  
 
  -- Статус
  is_active BOOLEAN DEFAULT true,
  is_under_maintenance BOOLEAN DEFAULT false,
  maintenance_note TEXT,
  maintenance_until DATE,
  
  -- Файлы
  photo_urls JSONB,
  floor_plan_url TEXT,
  
  -- Системные поля (по требованиям раздела 26)
  company_id BIGINT DEFAULT -1,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by BIGINT REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  archived_at TIMESTAMPTZ,
  archived_by BIGINT REFERENCES users(id),
  note VARCHAR(100)                -- Заметки
);

-- Индексы для rooms
CREATE INDEX idx_rooms_type ON rooms(type) WHERE is_active = true;
CREATE INDEX idx_rooms_active ON rooms(is_active) WHERE is_active = true;
4.7.2 Типы оборудования (equipment_types)
sql
CREATE TABLE equipment_types (
  id BIGSERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,      -- "Гантели", "Беговая дорожка"
  description TEXT,
  
  -- Классификация
  category SMALLINT NOT NULL,      -- EquipmentCategory enum
  sub_type SMALLINT,               -- EquipmentSubType enum (опционально)
  
  -- Характеристики
  weight_range VARCHAR(50),        -- "1-30 кг"
  dimensions VARCHAR(100),         -- "80x150x200 см"
  power_requirements VARCHAR(100), -- "220V, 2.5kW"
  is_mobile BOOLEAN DEFAULT true,
  
  -- Связи (для обратной совместимости и интеграции)
  exercise_type_id BIGINT REFERENCES type_exercis(id),
  
  -- Медиа
  photo_url TEXT,
  manual_url TEXT,
  
  -- Статус
  is_active BOOLEAN DEFAULT true,
  
  -- Системные поля
  company_id BIGINT DEFAULT -1,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by BIGINT REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  archived_at TIMESTAMPTZ,
  archived_by BIGINT REFERENCES users(id),
  note VARCHAR(100)
);

-- Индексы для equipment_types
CREATE INDEX idx_eq_types_category ON equipment_types(category) WHERE is_active = true;
4.7.3 Экземпляры оборудования (equipment_items)
sql
-- Конкретные экземпляры оборудования
CREATE TABLE equipment_items (
  id BIGSERIAL PRIMARY KEY,
  
  -- Тип оборудования
  type_id BIGINT NOT NULL REFERENCES equipment_types(id),
  
  -- Идентификация
  inventory_number VARCHAR(50) NOT NULL UNIQUE,  -- "ГАН-001"
  serial_number VARCHAR(100),                    -- Заводской номер
  model VARCHAR(100),                            -- "Matrix T7xe"
  manufacturer VARCHAR(255),                     -- "Johnson Health Tech"
  
  -- Локация
  room_id BIGINT REFERENCES rooms(id),
  placement_note TEXT,
  
  -- Состояние
  status SMALLINT DEFAULT 0,                     -- EquipmentStatus enum
  condition_rating INT CHECK (condition_rating >= 1 AND condition_rating <= 5),
  condition_notes TEXT,
  
  -- Обслуживание (упрощённое)
  last_maintenance_date DATE,
  next_maintenance_date DATE,
  maintenance_notes TEXT,
  
  -- Учёт
  purchase_date DATE,
  purchase_price DECIMAL(10,2),
  supplier VARCHAR(255),
  warranty_months INT,
  
  -- Использование
  usage_hours INT DEFAULT 0,
  last_used_date DATE,
  
  -- Фотографии
  photo_urls JSONB,
  
  -- Системные поля
  company_id BIGINT DEFAULT -1,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by BIGINT REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  archived_at TIMESTAMPTZ,
  archived_by BIGINT REFERENCES users(id),
  note VARCHAR(100)
);

-- Индексы для equipment_items
CREATE INDEX idx_eq_items_type ON equipment_items(type_id);
CREATE INDEX idx_eq_items_room ON equipment_items(room_id) WHERE room_id IS NOT NULL;
CREATE INDEX idx_eq_items_status ON equipment_items(status) WHERE status = 0; -- available
CREATE INDEX idx_eq_items_inventory ON equipment_items(inventory_number);
4.7.4 Бронирование оборудования (equipment_bookings)
sql
-- Бронирование конкретного оборудования
CREATE TABLE equipment_bookings (
  id BIGSERIAL PRIMARY KEY,
  
  -- Что бронируем
  equipment_item_id BIGINT NOT NULL REFERENCES equipment_items(id),
  
  -- Кто бронирует
  booked_by BIGINT NOT NULL REFERENCES users(id),
  
  -- Время
  start_time TIMESTAMPTZ NOT NULL,
  end_time TIMESTAMPTZ NOT NULL,
  
  -- Контекст
  lesson_id BIGINT REFERENCES lessons(id),
  training_group_id BIGINT REFERENCES training_groups(id),
  purpose VARCHAR(255) NOT NULL,
  
  -- Статус
  status SMALLINT DEFAULT 0,  -- BookingStatus enum
  
  -- Дополнительно
  notes TEXT,
  
  -- Системные поля
  company_id BIGINT DEFAULT -1,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by BIGINT REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  archived_at TIMESTAMPTZ,
  archived_by BIGINT REFERENCES users(id),
  
  -- Ограничения
  CONSTRAINT valid_booking_time CHECK (end_time > start_time)
);

-- Индекс для проверки пересечений бронирований
CREATE INDEX idx_eq_bookings_time 
ON equipment_bookings(equipment_item_id, start_time, end_time) 
WHERE status IN (0, 1); -- confirmed, active
   4.8 Бизнес-правила
4.8.1 Бронирование помещений и оборудования
1. При создании занятия система проверяет доступность зала
2. Если для занятия требуется оборудование - проверяет его доступность
3. Приоритет бронирования:
o Регулярные занятия тренировочных групп
o Индивидуальные занятия
o Разовые мероприятия
4.8.2 Управление состоянием оборудования
1. Оборудование со статусом maintenance или outOfOrder не бронируется
2. При достижении next_maintenance_date система уведомляет ответственного
3. После ремонта обязательна отметка о проведённых работах
4.8.3 Инвентаризация
1. Раз в месяц проводится сверка оборудования
2. Отсутствующее оборудование отмечается статусом
3. Ответственность за оборудование лежит на менеджере зала
   4.9 Интеграция с существующими модулями
4.9.1 С тренировочными группами (TrainingGroup)
dart
class TrainingGroup {
  // ... существующие поля
  
  String? primaryRoomId;     // Основной зал для занятий группы
  List<String> requiredEquipmentTypeIds; // Типы необходимого оборудования
}
4.9.2 С расписанием занятий (раздел 17)
При создании занятия в таблицу lessons добавляются:
sql
ALTER TABLE lessons ADD COLUMN room_id BIGINT REFERENCES rooms(id);
ALTER TABLE lessons ADD COLUMN equipment_booking_ids JSONB; -- IDs из equipment_bookings
4.9.3 С системой уведомлений (раздел 7)
• Уведомления о необходимости ТО оборудования
• Напоминания о бронировании залов
• Предупреждения о конфликтах расписания
4.9.4 С каталогом упражнений
Существующая связь сохраняется:
text
exercises_templates → type_exercis_id → equipment_types (через exercise_type_id)
   4.10 API endpoints
4.10.1 Помещения
text
GET    /api/rooms                    # Список помещений
GET    /api/rooms/:id               # Детали помещения
POST   /api/rooms                   # Создать помещение
PUT    /api/rooms/:id               # Обновить помещение
GET    /api/rooms/availability      # Проверить доступность
GET    /api/rooms/:id/equipment     # Оборудование в помещении
4.10.2 Оборудование
text
GET    /api/equipment/types         # Типы оборудования
GET    /api/equipment/items         # Экземпляры оборудования
GET    /api/equipment/items/:id     # Детали экземпляра
POST   /api/equipment/items         # Создать экземпляр
PUT    /api/equipment/items/:id     # Обновить экземпляр
PUT    /api/equipment/items/:id/maintenance # Отметить ТО
GET    /api/equipment/availability  # Доступное оборудование
4.10.3 Бронирование
text
GET    /api/bookings/equipment      # Бронирования оборудования
POST   /api/bookings/equipment      # Создать бронирование
PUT    /api/bookings/equipment/:id/cancel # Отменить бронирование
GET    /api/bookings/conflicts      # Проверить конфликты
   4.11 Интерфейсы
4.11.1 Дашборд управления помещениями
• Карта залов с цветовой индикацией занятости
• Список оборудования в каждом зале
• Календарь бронирований
4.11.2 Форма бронирования
text
[+] Забронировать зал/оборудование

Тип бронирования: [Зал ▼] [Оборудование ▼]
Ресурс: [Выберите... ▼]
Дата: [25.12.2024 ▼]
Время начала: [10:00 ▼] 
Время окончания: [11:30 ▼]
Цель: [Групповое занятие ▼]
Группа: [Йога для начинающих ▼]

[Проверить доступность] [Забронировать]

4.11.3 Панель состояния оборудования
• Список оборудования с фильтрами по статусу
• Оборудование, требующее ТО
• История использования
    


5 Онбординг (Lead Management)
5.2 Управление лидами
1-й способ холодного контакта. Потенциальный клиент оставляет заявку на сайте компании через контейнер "Составить заявку". Система автоматически создает запись в каталоге "Заявки (Лид-менеджмент)" (onboarding_client) и уведомляет дежурного менеджера.
2-й способ холодного контакта. Менеджер вручную создает запись в каталоге "Заявки" после телефонного разговора.
Менеджер связывается с лидом для консультации. Результаты общения фиксируются в поле "Примечание менеджера" карточки лида.
5.3 Активация учетной записи клиента
После достижения договоренности менеджер в карточке лида нажимает кнопку "Отправить приглашение".
1. Генерация приглашения: Система создает уникальную одноразовую ссылку-приглашение с JWT-токеном, содержащим id записи лида. Ссылка действительна 72 часа.
2. Отправка уведомления: Ссылка отправляется лиду по тому каналу связи, который был указан как предпочтительный (email или SMS). Текст уведомления настраивается администратором.
3. Завершение регистрации: Лид переходит по ссылке, попадает на защищенную страницу, где должен задать свой пароль для системы. Пароль должен соответствовать политике безопасности.
4. Создание клиента: После успешной установки пароля система в рамках одной транзакции:
o Создает полноценную учетную запись User с ролью "Клиент", используя данные из onboarding_client.
o Помечает запись в onboarding_client как is_client_created = true.
o Автоматически аутентифицирует пользователя в системе и перенаправляет его в личный кабинет.
5. Обработка просрочки: Если ссылка истекла, клиент должен обратиться к менеджеру для генерации новой.

5.4 Диаграмма состояний для онбординга

Пояснения к диаграмме и процессу
Ключевые состояния:
1. NewLead (Новая заявка): Начальное состояние. Заявка создана (через сайт или менеджером), но еще не взята в работу.
o Подсостояние «ОжиданиеОбработки»: Заявка в очереди на менеджера.
o Подсостояние «Обработка»: Менеджер активно работает с лидом (звонок, консультация).
2. Обработка: Менеджер связался с лидом, идет этап консультации.
o Подсостояние «Консультация»: Идет общение.
o Подсостояние «ОжиданиеРешения»: Менеджер ждет ответа от клиента или принимает решение.
3. Отклонена (Archived): Конечное состояние. Заявка неактивна (клиент не заинтересовался, не вышел на связь).
4. ПриглашениеОтправлено: Ключевое состояние. Менеджер подтвердил согласие клиента, система сгенерировала и отправила ссылку-приглашение.
o Подсостояние «ОжиданиеРегистрации»: Ссылка активна, система ждет действия от клиента.
o Подсостояние «Просрочено»: Ссылка истекла (прошло >72 часов). Требуется действие менеджера. Возможен вариант повторной отправки приглашения: создается новая ссылка с новым TTL, а старые инвалидируются.
5. АктивныйКлиент (Client Created): Конечное состояние, цель процесса. Лид успешно зарегистрировался в системе, учетная запись пользователя создана.
Ключевые события (переходы):
• "Менеджер отправляет новое приглашение" из состояния Просрочено позволяет повторно активировать заявку, не создавая новую запись.
• "Лид переходит по ссылке" — это автоматическое событие, инициируемое клиентом, которое запускает процесс регистрации и финального перехода в статус АктивныйКлиент.
• "Менеджер архивирует заявку" — это ручное действие менеджера для очистки базы от неактивных просроченных заявок.

6 Подсистема уведомлений (Notification Service)
Подсистема уведомлений отвечает за своевременную отправку сообщений пользователям через различные каналы связи (Email, SMS, Push) в соответствии с их настройками и бизнес-событиями системы.
6.2 Архитектура и общие требования
• Централизованный сервис: Уведомления должны обрабатываться единым сервисом (отдельным Dart-модулем), который получает события от системы и управляет очередью отправки.
• Шаблоны сообщений: Тексты уведомлений должны храниться в базе данных в виде шаблонов с возможностями подстановки переменных (например, {{client_name}}, {{training_time}}). Это позволит администратору изменять тексты без изменения кода.
• Очередь отправки (Queue): Для надежности отправка должна использовать очередь сообщений, чтобы избежать потери уведомлений при сбоях в работе внешних сервисов (SMTP, SMS-шлюз).
• Логирование: Отправка каждого уведомления должна фиксироваться в отдельной таблице.
6.3 Типы уведомлений (Бизнес-события)
Система должна отправлять уведомления при наступлении следующих событий:
1. Приглашение клиента:
o Событие: Менеджер нажал "Отправить приглашение" в карточке лида.
o Канал: Email или SMS (в зависимости от данных лида).
o Получатель: Потенциальный клиент (запись в onboarding_client).
o Содержание: Приветствие, уникальная ссылка для активации, инструкция.
2. Напоминание о занятии:
o Событие: За hourNotification часов до начала занятия.
o Триггер: Система проверяет расписание каждые 15 минут.
o Канал: Push-уведомление в приложении (основной), дублирование на Email (опционально, по настройкам пользователя).
o Получатель: Клиент, Тренер, Инструктор (привязанные к занятию).
o Содержание: Время занятия, название плана тренировок, ссылка на карточку занятия.
3. Изменение в расписании:
o Событие: Тренер или менеджер изменил время/дату занятия, отменил его.
o Канал: Push-уведомление, Email.
o Получатель: Клиент, Тренер, Инструктор.
o Содержание: Информация об изменении, старое и новое время.
4. Новое сообщение в чате:
o Событие: Пользователь отправил сообщение в чат (Peer-to-Peer или Broadcast).
o Канал: Push-уведомление.
o Получатель: Участник(и) чата, которые в данный момент не в приложении.
o Содержание: Имя отправителя и начало текста сообщения.
5. Системные уведомления для персонала:
o Событие: Поступление новой заявки с сайта (onboarding_client).
o Канал: Push-уведомление, Email.
o Получатель: Дежурный менеджер.
o Содержание: "Поступила новая заявка от [Имя]".
o Уведомления о необходимости обслуживания оборудования
o Предупреждения о конфликтах бронирования
o Напоминания о плановом ТО
6.4 Управление подписками (Пользовательские настройки)
Каждый пользователь (в дашборде "Настройки") должен иметь возможность независимо настраивать получение уведомлений:
• Общий переключатель: sendNotification (Вкл/Выкл все уведомления).
• Время напоминания о занятии: hourNotification (в часах).
• Каналы для разных событий: Отдельные переключатели для получения уведомлений по каналам:
o Push-уведомления (всегда Вкл, если не выключены на уровне ОС).
o Email-уведомления (опционально).
o SMS-уведомления (опционально, может быть платной услугой).
6.5 Технологический стек
- **Очередь задач:** Redis Queue или пакет dart_redis
- **Шаблоны сообщений:** PostgreSQL + Handlebars-подобный движок
- **Email отправка:** SMTP сервер (Postfix или внешний провайдер)
- **SMS отправка:** REST API российских SMS-шлюзов
- **Push-уведомления:** Firebase Cloud Messaging (FCM) для мобильных приложений
- **Веб-уведомления:** WebSocket + Service Worker

6.6 Компоненты системы
notification_service/
├── lib/
│   ├── notification_queue.dart    # Очередь уведомлений
│   ├── email_sender.dart         # Отправка email
│   ├── sms_sender.dart           # Отправка SMS
│   ├── push_sender.dart          # Push-уведомления
│   ├── template_engine.dart      # Шаблонизатор
│   └── webhook_sender.dart       # Webhook-уведомления
├── config/
│   ├── smtp_config.dart          # Настройки SMTP
│   └── sms_providers.dart        # Конфигурация SMS-шлюзов
└── workers/
    ├── email_worker.dart         # Воркер для email
    └── sms_worker.dart           # Воркер для SMS

7 Подсистема чата (Messaging)
Чат является критически важным инструментом коммуникации между всеми участниками процесса (клиентами, тренерами, инструкторами, менеджерами).
7.2 Функциональные требования
7.2.1 	Типы чатов
Система должна поддерживать следующие типы бесед:
1. Личные сообщения (Peer-to-Peer):
o Между любыми двумя пользователями системы, у которых есть права на общение (например, клиент может писать своему тренеру, но не может писать другому клиенту, если это не разрешено настройками).
2. Групповые чаты (Broadcast / Group):
o Тренер → Его клиенты: Создается автоматически для каждого тренера с его клиентами.
o Инструктор → Его клиенты: Создается автоматически для каждого инструктора с его клиентами.
o Менеджер → Группа сотрудников/клиентов: Для объявлений.
o Возможность создания групповых чатов вручную (например, менеджером) с выбором участников.
3. Системные уведомления:
o Уведомления от системы (напоминания, изменения расписания)
o Broadcast сообщения от администрации

7.2.2 Базовый функционал
• Отправка сообщений:
o Текстовые сообщения.
o Поддержка вложений.
• История сообщений: Полная история переписки должна храниться и подгружаться при открытии чата (с пагинацией).
• Статусы сообщений:
o sent (отправлено), delivered (доставлено получателю), read (прочитано).
o В групповых чатах статус read должен отображаться в виде списка прочитавших (или количества).
• Индикаторы активности:
o Индикатор "онлайн" (зеленая точка) рядом с аватаром пользователя.
o Индикатор "печатает..." (is typing...) в реальном времени.
• Уведомления:
o Push-уведомления на устройство при новом сообщении, если пользователь не в активном чате.
o Звуковое оповещение (опционально, настраивается пользователем).
o Бейджи (цифры) на иконке чата в интерфейсе, указывающие на количество непрочитанных сообщений.
7.2.3 Управление чатами
• Список чатов: Интерфейс должен отображать список всех чатов пользователя, отсортированный по времени последнего сообщения.
o Для каждого чата в списке отображается: аватар/название, последнее сообщение (или вложение), время и бейдж непрочитанных.
• Поиск по чатам и сообщениям: Возможность быстрого поиска по названиям чатов и тексту сообщений.
• Архивация чатов: Возможность скрыть чат из основного списка без удаления истории.
7.2.4 Автоматическое создание чатов
• При назначении клиента тренеру → создается личный чат
• При создании группового занятия → создается групповой чат участников
• При найме нового сотрудника → добавляется в общие чаты филиала

7.3 Архитектура и техническая реализация
7.3.1 Технологический стек
• Backend: Dart сервер на Shelf/Dart Frog
• База данных: PostgreSQL 15+
• Real-time: WebSocket + Redis Pub/Sub
• Хранение файлов: Локальная файловая система
• Клиент: Flutter WebSocket client
7.3.2 Компоненты системы

// Структура серверной части чата
chat_server/
├── lib/
│   ├── websocket_server.dart    # WebSocket обработчик
│   ├── chat_service.dart        # Бизнес-логика чата
│   ├── message_repository.dart  # Работа с БД
│   └── redis_service.dart       # Pub/Sub для реального времени
├── config/
│   └── database.dart           # Конфигурация БД
└── bin/
    └── server.dart             # Точка входа

7.3.3 Таблицы чата
-- Таблица чатов
-- Таблица участников чата
-- Таблица сообщений
-- Таблица статусов сообщений (для отслеживания прочтения)

7.3.4 Алгоритмы и процессы
• Создание личного чата: Происходит автоматически при первой попытке отправить сообщение пользователю, если чата еще не существует.
• Доставка и прочтение:
1. Сообщение сохраняется в БД, ему присваивается статус sent.
2. Через Realtime канал оно мгновенно доставляется всем онлайн-участникам чата. В БД для них проставляется статус delivered.
3. Когда пользователь открывает чат, клиентское приложение отправляет команду на сервер о прочтении всех сообщений в этом чате. В БД проставляется статус read.
• Индикатор "печатает...": При начале ввода текста в поле сообщения клиент отправляет через Realtime событие typing_start в канал чата. При остановке или отправке сообщения — событие typing_stop.
7.4 Требования к интерфейсу (UI/UX)
• Экран списка чатов: Должен быть доступен с главного навигационного меню каждого дашборда.
• Экран чата:
o Шапка с названием чата и списком участников (для групповых).
o Область сообщений с группировкой по датам.
o Панель ввода сообщения с кнопкой отправки.
o На втором этапе: кнопка прикрепления файла.
• Контекстные меню: Должен быть реализован функционал "долгого нажатия" на сообщение для его копирования или пересылки (для администраторов/менеджеров).
7.5 Безопасность и контроль доступа
• Row Level Security (RLS): Должны быть настроены строгие политики RLS на все таблицы чатов. Пользователь может видеть и писать только в те чаты, участником которых он является.
• Валидация: Проверка прав пользователя на отправку сообщения в конкретный чат должна выполняться на стороне сервера перед сохранением сообщения.
• Модерация: На втором этапе рассмотреть возможность удаления сообщений для ролей Менеджер/Администратор.

8 Подсистема отчетности (Reporting & Analytics)
Подсистема отчетности предоставляет руководству и менеджерам инструмент для анализа эффективности фитнес-центра, сотрудников и бизнес-процессов на основе накопленных данных.
8.2 Общие принципы
• Доступ на основе ролей: Отчеты доступны только пользователям с ролями Администратор и Менеджер. Уровень детализации данных может различаться (например, менеджер видит данные только по своим клиентам/тренерам, а администратор — по всему центру).
• Интерактивность: Отчеты должны быть интерактивными: с возможностью фильтрации, сортировки и детализации (drill-down). Например, клик на цифру "Количество занятий" открывает список этих занятий.
• Визуализация: Данные должны представляться в виде сводных таблиц, графиков (столбчатые, линейные, круговые) и дашбордов с KPI.
• Экспорт: Все отчеты должны поддерживать экспорт данных в форматы PDF (для печати и презентаций) и XLSX/CSV (для дальнейшего анализа в Excel).
8.3 Виды отчетов
8.3.1 Отчетность по клиентам
8.3.1.1 Отчет «Динамика клиентской базы»
o Цель: Анализ притока и оттока клиентов.
o Параметры: Период (месяц, квартал, год).
o Метрики:
• Новые клиенты (зарегистрировались за период).
• Активные клиенты (посетили хотя бы 1 занятие за период).
• Ушедшие клиенты (не были на занятиях последние N дней).
• Общее количество клиентов на конец периода.
• График: Динамика изменения этих показателей over time.
8.3.1.2 Отчет «Посещаемость и прогресс клиентов»
o Цель: Оценка вовлеченности и эффективности тренировок.
o Параметры: Период, конкретный клиент (опционально), тренер (опционально).
o Метрики:
• Общее количество проведенных занятий.
• Процент посещаемости от запланированных занятий.
• Среднее количество занятий в неделю на одного клиента.
• Динамика изменения веса, обхватов тела.
• Динамика потребленных и затраченных калорий (дефицит/профицит).
• Достижение целей (количество клиентов, достигших целевого веса за период).
8.3.2 Отчетность по сотрудникам
8.3.2.1 Отчет «Загрузка и эффективность тренеров»
o Цель: Оценка продуктивности и загруженности тренерского состава.
o Параметры: Период, конкретный тренер (опционально).
o Метрики:
• Общее количество проведенных занятий.
• Общее количество рабочих часов (по табелю).
• Количество прикрепленных клиентов (на начало и конец периода).
• Средний доход с клиента (если интегрировано с финансовой системой. Это вынесено за рамки данной системы и будет интегрироваться via API).
• Рейтинг тренера на основе отзывов клиентов (если функционал реализован).
• График: Сравнительная диаграмма загрузки тренеров.
8.3.2.2 Отчет «Табель учета рабочего времени» (Расширенная версия)
o Цель: Финальное подведение итогов для payroll (расчета заработной платы).
o Параметры: Расчетный период (например, с 1 по последнее число месяца).
o Метрики: По каждому сотруднику:
• Отработанные часы (суммировано из занятий).
• Количество проведенных индивидуальных/групповых занятий.
• Простои/опоздания (если ведется учет).
• Экспорт: Обязательный вывод в XLSX для бухгалтерии.
8.3.3 Отчетность по занятиям и расписанию
8.3.3.1 Отчет «Статистика занятий»
o Цель: Анализ популярности направлений и загрузки зала.
o Параметры: Период, тип занятия (индивидуальное/групповое), зал (если несколько).
o Метрики:
• Распределение занятий по типам (индив./групп.).
• Распределение занятий по планам тренировок (похудение, масса и т.д.).
• Процент отмененных/перенесенных занятий.
• Среднее количество участников в групповых занятиях.
• График: Загрузка зала по времени суток и дням недели.
8.3.4 Отчетность по помещениям и оборудованию
• Отчет по загрузке залов
• Анализ использования оборудования
• Отчет по затратам на обслуживание
8.3.5 Финансовая отчетность по центру (если интегрировано с кассой/оплатами)
8.3.5.1 Отчет «Выручка и платежи»
o Цель: Контроль финансовых потоков.
o Параметры: Период.
o Метрики:
• Общая выручка за период.
• Выручка по типам услуг (абонементы, разовые занятия, персональные тренировки).
• Количество оформленных абонементов.
• Динамика выручки (сравнение с предыдущим периодом).
• График: Круговая диаграмма структуры выручки.
8.4 Техническая реализация
8.4.1 Архитектура
• Источник данных: Все отчеты строятся на основе основной базы данных PostgreSQL (таблицы users, lessons, track_calories, anthropometry_start/finish и др.).
• Генерация отчетов: Для сложных отчетов с агрегацией данных рекомендуется использовать представления (Views) или материализованные представления (Materialized Views) в PostgreSQL для оптимизации производительности.
• API: Бэкенд должен предоставлять API-эндпоинты для получения данных отчетов в формате JSON, которые затем визуализируются на фронтенде.
o Пример эндпоинта: GET /api/reports/client_dynamics?start_date=2023-01-01&end_date=2023-12-31
8.4.2 Интерфейс генератора отчетов
• Дашборд «Аналитика» в интерфейсе Администратора/Менеджера.
• Левая панель: Древовидный список всех доступных отчетов.
• Центральная часть:
1. Панель параметров: Выбор периода, фильтров (тренер, клиент, тип занятия).
2. Область визуализации: Здесь отображаются графики и таблицы.
3. Панель инструментов: Кнопки "Обновить", "Экспорт в PDF", "Экспорт в Excel".
8.5 Пример технического задания для одного отчета
Отчет: «Динамика клиентской базы за период»
• Эндпоинт API: GET /api/reports/client_dynamics
• Параметры запроса (Query Parameters):
o start_date (обязательный)
o end_date (обязательный)
• Ответ (Response Body):
json
{
  "period": {"start": "2023-01-01", "end": "2023-12-31"},
  "metrics": {
    "new_clients": 150,
    "active_clients": 400,
    "churned_clients": 45,
    "total_clients_end": 1200
  },
  "chart_data": [
    {"month": "2023-01", "new": 10, "active": 350, "churned": 5, "total": 1000},
    {"month": "2023-02", "new": 15, "active": 370, "churned": 8, "total": 1007},
    ...
  ]
}
• Логика расчета на бэкенде:
o new_clients: COUNT пользователей с ролью 'client', у которых created_at входит в период.
o active_clients: COUNT уникальных user_id из таблицы lessons, где start_fact_at входит в период и complete = 'completed'.
o churned_clients: COUNT клиентов, у которых последнее занятие (MAX(start_fact_at)) было раньше, чем end_date - 30 days (или другой порог "ухода").
o total_clients_end: COUNT пользователей с ролью 'client' на дату end_date.

9 Подсистема управления пользователями (User Management)
Подсистема управления пользователями является фундаментом всей системы, обеспечивая безопасную аутентификацию, гибкую авторизацию на основе ролей и централизованное управление учетными записями.
9.2 Модель данных и ролевая система
9.2.1 Сущность «Пользователь» (User)
Универсальная сущность, хранящая общие данные для всех участников системы.
• Базовые поля:
o id (UUID, Primary Key)
o login (String, Unique) // Логин для входа (может совпадать с email/телефоном)
o password_hash (String) // Хеш пароля (алгоритм bcrypt)
o email (String, Unique, Nullable)
o phone (String, Unique, Nullable)
o last_name (String)
o first_name (String)
o middle_name (String, Nullable)
o gender (SMALLINT) //значение перечисления в коде
o date_of_birth (DATE) //День рождения
o photo_url (String, Nullable) // Ссылка на аватар в хранилище
o created_at (Timestamp)
o updated_at (Timestamp)
o archived_at (Timestamp)
o archived_by (BIGINT FK → users(id))
o created_by (BIGINT FK → users(id))
o updated_by (BIGINT FK → users(id))

• Настройки уведомлений (хранятся в таблице user_settings):
o send_notifications (Boolean, default: true) // Разрешить уведомления
o hour_notification (Integer) // За сколько часов уведомлять о занятии
o notification_email (Boolean) // Получать на email
o notification_push (Boolean) // Получать push-уведомления
9.2.2 Ролевая модель (Role-Based Access Control - RBAC)
Гибкая система, позволяющая назначать пользователю несколько ролей.
• Таблица roles:
o id (Primary Key)
o name (String, Unique: 'client', 'instructor', 'trainer', 'manager', 'admin') // Системное имя
o title (String) // Человекочитаемое название ('Клиент', 'Тренер')
o icon (String) // Иконка роли для UI
• Таблица user_roles (связь многие-ко-многим):
o user_id (Foreign Key -> users)
o role_id (Foreign Key -> roles)
o assigned_at (Timestamp)
• Иерархия и комбинации ролей:
o Пользователь может иметь несколько ролей.
o Пример: В небольшом клубе тренер может иметь роли trainer, manager и admin.
o Наличие роли определяется бизнес-логикой, а не техническими ограничениями.
9.2.3 Профили конкретных ролей (Profile Tables)
Дополнительные данные, специфичные для роли, хранятся в отдельных таблицах с связью One-to-One к основной таблице users.
• Таблица client_profiles (для клиентов):
o user_id (Primary Key, Foreign Key -> users)
o goal_training_id (Foreign Key -> goals_training)
o level_training_id (Foreign Key -> levels_training)
o track_calories (Boolean, default: true) // Включить учет калорий
o coeff_activity (Double, default: 1.2) // Коэффициент активности

• Таблица instructor_profiles (для инструкторов):
o user_id (Primary Key, Foreign Key -> users)
o specialization (String, Nullable) // Специализация
o work_experience (Integer, Nullable) // Стаж в годах
o is_duty (Boolean, default: false) // Дежурный (логика на основе employees_duty)
o can_replace_trainer (Boolean, default: false) // Может замещать тренера
o can_create_plan (Boolean, default: false) // Может создавать планы тренировок

• Таблица trainer_profiles (для тренеров):
o user_id (Primary Key, Foreign Key -> users)
o specialization (String, Nullable) // Специализация
o work_experience (Integer, Nullable) // Стаж в годах

• Таблица manager_profiles (для менеджеров):
o user_id (Primary Key, Foreign Key -> users)
o specialization (String, Nullable) // Специализация
o work_experience (Integer, Nullable) // Стаж в годах
o is_duty (Boolean, default: false) // Дежурный (логика на основе employees_duty)

9.2.4 Требования к ролям в пользовательских интерфейсах

1. Пользователи с ролями "Инструктор", "Тренер", "Менеджер" могут иметь несколько ролей, кроме роли "Клиент".
2. Если роль одна, созданная при создании пользователя, то она считается основной. В дашбордах перечисленных пользователей она не отображается.
3. Если ролей несколько, то в дашборде выводится список ролей с подзаголовком: "Роли". Добавлять или удалять роли из списка может только администратор. Основную роль удалить нельзя.
4. Если у пользователя несколько ролей, то при входе предлагать выбор роли в попап-окне. Такой же функционал при входе в дашборд из списка пользователей в дашборде администратора.
5.  Пользователи с ролью "Клиент" могут иметь только одну роль при создании.

9.3 Функциональные требования
9.3.1 Жизненный цикл учетной записи
• Создание пользователя:
o Сценарий А (Администратором): Через интерфейс "Создание пользователя" с ручным назначением ролей.
o Сценарий Б (Самостоятельная регистрация): Через процесс онбординга (пригласительная ссылка).
• Активация/Деактивация: Возможность временно отключить учетную запись без удаления данных (is_active = false).
• Удаление: Строго логическое удаление. Запись помечается как удаленная (is_deleted = true), данные сохраняются для аудита.
9.3.2 Аутентификация и безопасность
• Вход в систему: По паре login (email/телефон) и password.
• Политика паролей:
o Минимальная длина: 8 символов.
o Обязательные категории: заглавные и строчные буквы, цифры, специальный символ.
o Запрет на использование простых паролей (проверка against словаря).
• Защита от брутфорса: Блокировка учетной записи после 5 неудачных попыток входа за 15 минут.
• Сброс пароля: Стандартный flow через email с одноразовой ссылкой.
• Смена пароля: Обязательна при первом входе, если пароль был установлен администратором.
9.3.3 Управление пользователями (CRUD)
• Просмотр списка пользователей:
o Интерфейс: Единый дашборд с возможностью фильтрации по ролям, активности, ФИО.
o Отображение: Аватар, ФИО, основные роли, контакты, статус активности.
• Создание/Редактирование пользователя:
o Универсальная форма: Основные поля (ФИО, контакты, логин).
o Динамические блоки: В зависимости от выбранных ролей появляются дополнительные поля (например, блок "Данные клиента" при назначении роли client).
o Назначение ролей: Выбор из списка с чекбоксами.
• Управление доступом: Только пользователи с ролями admin и manager имеют полный доступ к CRUD. Тренер может просматривать и редактировать только своих клиентов.
9.4 Техническая реализация
9.4.1 Безопасность (Row Level Security - RLS)
• Для всех таблиц (users, client_profiles, etc.) должны быть настроены политики RLS.
• Пример политики для users:
o Администратор (role_admin) видит всех пользователей.
o Менеджер (role_manager) видит пользователей, которые являются его клиентами/тренерами/инструкторами (через таблицы связей manager_client, manager_trainer, manager_instructor).
o Тренер (role_trainer) видит только себя и своих клиентов/инструкторов.
o Инструктор (role_instructor) видит только себя и своих.
o Клиент (role_client) видит только свою учетную запись.
9.4.2 Процессы и бизнес-логика
• Создание клиента из лида: При нажатии "Создать клиента" в карточке лида система:
1. Создает запись в users на основе данных из onboarding_client.
2. Назначает пользователю роль client.
3. Создает запись в client_profiles.
4. Устанавливает связь trainer_client с тренером-менеджером.
• Проверка уникальности: При создании/редактировании обязательна проверка на уникальность login, email, phone.

9.5 Требования к списочным формам, карточкам, дашбордам
• Все ListView должны быть пагинированы.
• В карточке или дашборде, в панели инструментов должна быть кнопка "Инфо", по клику которой в popup-окне выводится диагностическая информация: имя таблицы сущности, id записи таблицы. Так же выводятся поля: created_at, updated_at, created_by, updated_by. Данная кнопка доступна всем, кроме клиентов.
9.6 Требования к личной информации в дашбордах
В каждом типе дашборда пользователей должен быть экран "Профиль" с основными данными из таблицы users:
• photo (URL). //Фото.
• login (string). //Логин.
• lastName (string). //Фамилия.
• firstName (string). //Имя.
• middleName (string). //Отчество.
• fullName (string). //Полное ФИО, расчетное.
• shortName (string). //Краткое ФИО, расчетное.
• gender (string). //Пол.
• date_of_birth (DateTime). //День рождения.
• age (int). //Возраст. Расчетное.
• phone (string). //Телефон.
• email (string). //E-mail.
• sendNotification (bool). //Посылать уведомления. Поле есть у всех, кроме админа.
• hourNotification (duration). //Время уведомления до занятий (в часах).  Поле есть у всех, кроме админа.
• List<Role> roles. //Список ролей, если больше одной. Поле есть у всех, кроме клиента.
В случае дашборда клиента, отображаются дополнительные поля:
• trackCalories (bool) //Учет калорий.
• double coeffActivity = //Минимальный коэффициент активности.

Экран должен отображаться после нажатия на кнопку "Профиль" в меню дашборда.

10 Функциональный модуль "Администратор"
10.1  Дашборд "Администратор"
Обозначение: AdminDashboard.
Заголовок: "Администратор".
Меню дашборда:
• Главное. Экран дашборда.
• Профиль. Экран с личной информацией.
• Подменю каталогов. Доступны для создания/редактирования записей всех каталогов.
• Параметры -> Настройки. Открывается popup-форма "Настройки".
• Инфо.
Дашборд включает ListView пользователей с панелью инструментов. На панели инструментов находятся кнопки: "Создать" (активная), "Изменить", " Архивировать", "Сброс пароля" (активные при выборе строки в списке). Так же имеется поле поиска по ФИО/телефону/e-mail и кнопкой сброса содержимого поля. На каждое действие определяется своя команда.
Отдельно размещен виджет SegmentedButton со значениями: Все | Администраторы | Менеджеры | Тренеры | Инструкторы | Клиенты. При клике вызывается соответствующая команда фильтрации списка.

10.1.1 Окно "Создание пользователя"
Параметр: строка (userRole).
Заголовок: "Создание: " + userRole.
Поля:
• login (string). //Логин. Обязательное.
• password (string). //Пароль. Обязательное.
• lastName (string). //Фамилия. Обязательное.
• firstName (string). //Имя. Обязательное.
• middleName (string). //Отчество. Не обязательное.
• fullName (string). //Полное ФИО.
• shortName (string). //Краткое ФИО.
• gender (string). //Пол. Обязательное.
• age (int). //Возраст. Обязательное.
• phone (string). //Телефон. Обязательное.
• email (string). //E-mail. Не обязательное.
• photo (URL). //Фото. Не обязательное
• sendNotification (bool). //Посылать уведомления. Обязательное. Значение берется из файла настроек.
• hourNotification (duration). //Время уведомления до занятий (в часах). Обязательное. Значение берется из файла настроек.

В случае создания администратора, поля sendNotification, hourNotification, не отображаются.
В случае создания клиента, отображаются дополнительные поля:
• trackCalories (bool) //Учет калорий. Значение берется из файла настроек.
• double coeffActivity = 1.2; //Минимальный коэффициент активности.

Поле "Пароль" имеет отображаемый формат в виде звездочек.
Поля fullName и shortName вычисляются автоматически после ввода lastName, firstName, middleName.
Для выбора пола сформировать выпадающий список со значениями "мужской", "женский".
Телефон и почту проверять функциями валидации.

Кнопки: "Генерировать пароль", "Создать", "Отмена".
По кнопке "Генерировать пароль", запускается команда генерации пароля с солью в поле Пароль.
По кнопке "Создать", запускается команда создания пользователя с параметром userRole.
По кнопке "Отмена" закрывает окно.

10.1.2 Окно "Сброс пароля"
Параметр: строка (userLogin).
Лэйбл: "При сбросе пароля будет установлен новый пароль, который нужно будет сообщить пользователю. Продолжить?"
Поле: "Пароль".
Кнопки: "Сбросить пароль" и "Отменить".
Должно быть предусмотрено скрытие пароля. Должен быть предусмотрен ручной ввод пароля. Должна быть предусмотрена повторная генерация пароля.
При открытии формы запускается Команда "Генерация пароля" и возвращаемое значение подставляется в поле "Пароль".
При нажатии на кнопку "Сбросить пароль" запускается Команда "Сохранение пароля " с параметрами: userLogin и паролем.

10.1.3 Окно "Дежурства сотрудников"
Фрейм "Дежурный менеджер"
Содержит элементы:
• ФИО дежурного менеджера; //Статус "дежурный" определяется по последней незавершенной записи в employees_duty (где duty_finish_at IS NULL)'
• Дежурство с: ' + время последней записи duty_start_at из таблицы employees_duty по id из таблицы users;  
• ListView пользователей, отфильтрованных по роли Менеджер. 
• Кнопка с заголовком "Назначить", если ФИО пусто, или с заголовком "Сменить", если ФИО не пусто.
Логика: После выбора строки из ListView, и нажатия кнопки, запускается команда назначения дежурного сотрудника с параметрами: типа роли и id сотрудника. У нее есть 2 варианта:
1. id == null. В этом случае выдается предупреждающее сообщение "Назначить имярек дежурным менеджером?" В случае "Да" в таблице employees_duty создается новая запись с текущем временем в поле duty_start_at. На выходе команды заполняется поле ФИО и 'Дежурство с: ' + время duty_start_at;
2. id != null. В этом случае выдается предупреждающее сообщение "Сменить дежурного менеджера имярек1 на имярек2?" В случае "Да" в таблице employees_duty по id менеджера1 устанавливается текущем временем поле duty_finish_at. Далее создается новая запись с текущем временем в поле duty_start_at.  На выходе команды заполняется поле ФИО и 'Дежурство с: ' + время dutyManagerStartAt;

10.1.4 Окно "Настройки"
Имеет поля из файла настроек.
Кнопка: "Сохранить". Становится доступной при изменении любого поля окна.
10.1.5 Окно "Расписание работы центра"
Содержит редактируемую ListView из таблицы work_schedules.

10.1.6 Окно "Расписание занятий"
Содержит все виды расписаний занятий, с выборкой по тренеру, инструктору, клиенту.
Содержит функционал составления общего расписания, обновления по клиенту.

10.1.7 Окно "Табели"
Окно содержит дашборд "Табель" в групповом режиме.

11 Функциональный модуль "Клиент"
11.1 Таблицы индивидуальных назначений
• Таблица: client_training_plans
o id (PK)
o user_id (FK -> users)
o training_plan_template_id (FK -> training_plan_templates) // Исходный шаблон
o assigned_by (FK -> users) // Кто назначил (тренер)
o assigned_at (TIMESTAMP)
o is_active (BOOLEAN) // Активный план у клиента
o goal (VARCHAR) // Цель может быть переопределена для этого клиента
o notes (TEXT) // Персональные заметки тренера
• Таблица: client_set_exercises
o id (PK)
o client_training_plan_id (FK -> client_training_plans) // Часть какого ИНДИВИДУАЛЬНОГО плана
o set_exercise_template_id (FK -> set_exercise_templates) // Основано на каком шаблоне
o order (INT) // Порядок в плане для этого клиента
o is_active (BOOLEAN)
o repeats (INT) // Индивидуальное кол-во повторений всего сета
o rest_after_set (REAL) // Индивидуальное время отдыха после сета
• Таблица: client_exercises
o id (PK)
o client_set_exercise_id (FK -> client_set_exercises) // Часть какого ИНДИВИДУАЛЬНОГО сета
o exercise_template_id (FK -> exercise_templates) // Основано на каком шаблоне
o order (INT) // Порядок в сете для этого клиента
o custom_repeat_qty (INT) // Индивидуальное кол-во повторов
o custom_duration_exec (REAL) // Индивидуальная длительность
o custom_duration_rest (REAL) // Индивидуальный отдых
o custom_notes (TEXT) // Персональные указания (например, "ставить ноги шире")
11.2 Таблица "lessons"

• schedule_id (BIGINT); //определяет запланированный слот,
• client_training_plan_id (BIGINT); //конкретный план, который был выполнен в этом слоте
• set_exercises_id (BIGINT);
• user_id (BIGINT);
• instructor_id (BIGINT);
• trainer_id (BIGINT);
• room_id BIGINT REFERENCES rooms(id);
• equipment_ids JSONB; -- список equipment.id
• start_plan_at (TIMESTAMP);
• start_fact_at (TIMESTAMP);
• finish_plan_at (TIMESTAMP);
• finish_fact_at (TIMESTAMP);
• complete (INT);
• note (VARCHAR(100));
Таблица lessons заполняется на основе расписания.

Таблица "track_сalories"
• user_id (BIGINT);
• lesson_id (BIGINT);
• weight (double); //вес
• calories_in (REAL); //входящие калории
• calories_out (REAL); //исходящие калории

Таблица хранения формулы расчета BMR "bmr_formulas"
• name (VARCHAR(100));
• formula (TEXT), -- например: "66 + (13.7 * weight) + (5 * height) - (6.8 * age)"
• for_men (BOOLEAN),
• for_women (BOOLEAN),
• is_active (BOOLEAN DEFAULT true)


11.3 Таблицы антропометрии
Таблица "anthropometry_fix" (фиксированные значения, вводятся 1 раз).
• user_id (BIGINT);
• date_time (TIMESTAMP);
• height (int); //рост в см
• wrist_circ (Обхват запястья, см);
• ankle_circ (Обхват лодыжки, см);
Таблица "anthropometry_start" (антропология начало).
• user_id (BIGINT);
• date_time (TIMESTAMP);
• photo_date_time (TIMESTAMP);
• photo (URL); //фото 
• weight (double); //вес в кг
• shoulders_circ (int); //обхват в плечах
• breast_circ (int); //обхват в груди
• waist_circ (int); //обхват в талии
• hips_circ (int); //обхват бедер

Таблица "anthropometry_finish" " (антропология окончание). По структуре повторяет таблицу "anthropometry_start".
Таблицы anthropometry_ обновлять могут только сотрудники (не роль Клиент).

11.4 Таблицы биоимпеданса
Таблица "bioimpedance_start"
• user_id (BIGINT);
• date_time (TIMESTAMP);
• fat_percentage (Процент жира);
• muscle_mass (Мышечная масса, кг);
• water_percentage (Процент воды);
• visceral_fat (Висцеральный жир, уровень);
• bmc (Минеральная масса костей);
• bmi (Индекс массы тела, часто считает сам аппарат);
• metabolism (Скорость основного обмена, ккал);

Таблица "bioimpedance_finish". По структуре повторяет таблицу "bioimpedance_start".
Таблицы bioimpedance_ обновлять могут только сотрудники (не роль Клиент).

11.5 Таблица предпочтений
Таблица "client_schedule_preferences" (предпочтения клиента по расписанию).
• user_id (FK -> users). Ссылка на клиента.
• day_of_week (Integer, NOT NULL). День недели: 1-7.
• preferred_start_time (Time, NOT NULL). Желаемое время начала занятия.
• preferred_end_time (Time, NOT NULL). Желаемое время окончания занятия.

11.6 Списочная форма
ListView клиентов должна отображаться в дашбордах инструкторов, тренеров, менеджеров в окне "Клиенты".
Отображаемые поля:
• Фото клиента. При выборе поля открывается дашборд клиента.
• Фамилия, Имя, Отчество. При выборе поля открывается дашборд клиента.
• Занятие ближайшее. При выборе поля открывается дашборд занятия
• Инфо.
Поле Инфо представляет собой строку информации о ближайшем занятии клиента в зависимости от значения hourNotification клиента:
• Текущее время меньше разницы времени начала ближайшего занятия и hourNotification:
отображается строка: "До занятия " + (разница времени начала ближайшего занятия и текущего) + " час."
• Текущее время в пределах разницы времени начала ближайшего занятия и hourNotification:
отображается строка на желтом фоне: "До занятия " + (разница времени начала ближайшего занятия и текущего) + " час."
• Текущее время больше времени начала ближайшего занятия и меньше времени окончания занятия:
      отображается строка на зеленом фоне: "Идет занятие".
   Функционал поля Инфо является задачей бэкенд-API с периодом 1 минута.
11.7 Дашборд "Клиент"
Дашборд "Клиент" должен быть доступен как клиенту, так и всем остальным ролям при открытии дашборда из списка клиентов.
Обозначение: ClientDashboard.
Дашборд должен включать следующие виджеты:
1. Виджет "Следующая тренировка":
o Отображает информацию о ближайшем предстоящем занятии.
o Включает динамический обратный отсчет до начала занятия.
o Содержит кнопку-ссылку для перехода к деталям занятия.
2. Виджет "Прогресс тренировок":
o Отображает общую статистику: количество завершенных занятий за период, общее количество сожженных калорий, процент посещаемости.
o Визуализирует данные с помощью индикаторов выполнения (progress bar) и компактных графиков активности.
3. Виджет "Прогресс по цели":
o Отображает текущую цель клиента (напр., целевой вес).
o Показывает прогресс в достижении цели в виде численных индикаторов и тренда на мини-графике.
o Отображает средний недельный дефицит или профицит калорий.
4. Виджет "Достижения":
o В геймифицированном виде отображает последние полученные клиентом достижения.
o Представляет собой сетку иконок с кратким описанием.
5. Быстрое меню: Доступ к основным разделам ("Занятия", "Учет калорий") должен быть реализован в виде панели быстрого доступа или виджетов-карточек на самом дашборде.
Примечание: Виджеты должны быть адаптивными и перестраиваться в зависимости от размера экрана устройства. Порядок и наличие виджетов можно настроить.

Меню дашборда:
• Главное. Экран дашборда.
• Профиль. Экран с личной информацией.
• Мой тренер.
• Мой инструктор (при включенном roleInstructor из файла настройки).
• Мой менеджер (при включенном roleManager из файла настройки).
• Антропометрия.
• Занятия.
• Учет калорий (при включенном trackCalories из таблицы client).
• Прогресс.
• Инфо (доступно всем ролям, кроме Клиента).

11.7.1 Окно "Мой тренер"
Содержит фото тренера, полное ФИО, телефон, фрейм чата.

11.7.2 Окно "Мой инструктор"
Содержит фото инструктора, полное ФИО, телефон, фрейм чата.

11.7.3 Окно "Мой менеджер"
Содержит фото менеджера, полное ФИО, телефон, фрейм чата.
  
11.7.4 Окно "Антропометрия"
Состоит из:
• Виджета вверху по центру с данными из таблицы anthropometry_fix.
• 2-х одинаковых виджетов "Начало" и "Окончание", расположенных горизонтально, с данными из таблиц anthropometry_start и anthropometry_finish.
• В каждом виджете кнопка "Редактировать" переводит данные в режим редактирования. Кнопка "Редактировать" видна всем, кроме роли клиента.
• Кнопка "Сохранить" появляется после активации редактирования. После сохранения - возврат в режим просмотра.
• В виджетах "Начало" и "Окончание" имеется виджет "Индекс здоровья WHtR".  WHtR рассчитывается, как рост/обхват талии. Индекс рассчитывается с поправкой на возраст:
• Возраст до 25 – поправка 0.
• Возраст до 40 – поправка 0.02.
• Возраст до 60 – поправка 0.04.
• Возраст после 60 – поправка 0.05.
Виджет представляет собой линейный прогресс-бар с разметкой:
• Зеленая зона (0.45 - 0.55): "Норма, риск низкий"
• Желтая/Оранжевая зона (0.55 - 0.6): "Повышенный риск ожирения"
• Желтая/Оранжевая зона (0.4 - 0.45): "Повышенный риск истощения"
• Красная зона (>0.6): "Высокий риск ожирения"
• Красная зона (<0.4): "Высокий риск истощения"
• В окне расположена кнопка "Сравнение по фото". После нажатия открывается экран "Сравнение по фото" с двумя виджетами с заголовками "Начало" и "Окончание", выровненными по горизонтали. В каждом виджете имеется фрейм для показа фото, поле даты и кнопка "Загрузить фото". Кнопка видна всем, кроме роли клиента. По кнопке загружается фото из выбранной папки, с указанием даты/времени создании фото, если имеется, если нет, то даты/времени загрузки. При отображении обоих фото появляется кнопка "Сравнить". По кнопке запускается функция "Сравнить".
Функция "Сравнить":
• При нажатии кнопки "Сравнить" система открывает полноэкранный режим для визуального сравнения фотографий "до" и "после".
• Реализовать режим "Слайдер" (split-view), позволяющий пользователю интерактивно перекрывать одно изображение другим для наглядной оценки изменений.
• На втором этапе разработки рассмотреть возможность добавления функционала ручной разметки ключевых точек на фотографиях для автоматического расчета и сравнения объемов тела.
• Технологии автоматического замера объемов с помощью Computer Vision (AI) являются опциональными и требуют отдельного технико-экономического обоснования.

11.7.5 Окно "Биоимпеданс"
Состоит из 2-х одинаковых фреймов "Начало" и "Окончание", расположенных горизонтально, с ListView таблиц bioimpedance_start и bioimpedance_finish.

11.7.6 Окно "Занятия"
Окно содержит ListView "Lessons" c расписанием занятий.
Поля:
• № занятия.
• Наименование набора упражнений.
• Начало занятия план.
• Конец занятия план.
• Начало занятия факт. 
• Конец занятия факт.
• Длительность.
• Инструктор.
• Тренер.
• Выполнение.
• Примечание.
Логика отображения:
• Если у клиента есть активные занятия в расписании: отображается таблица с расписанием.
• Если активных занятий нет: таблица скрывается. Вместо нее отображается виджет с текстом: "Вам еще не назначены занятия. Заполните, пожалуйста, предпочтения по времени." и кнопка "Заполнить предпочтения".
Логика кнопки "Заполнить предпочтения":
• При нажатии открывается окно "Предпочтения по расписанию" ClientPreferenceSchedule.
После тапа-клика строки ListView "Lessons", открывается карточка "Занятие". Редактирование полей карточки возможно только последней записи.
Окно содержит кнопку "Создать", после чего создается запись в таблице lessons на основе расписания и открывается карточка "Занятие".
Карточка "Занятие"
Поля:
• № занятия (недоступно).
• Наименование набора упражнений (недоступно).
• Начало занятия план (недоступно).
• Конец занятия план (недоступно).
• Начало занятия факт. 
• Конец занятия факт.
• Длительность (недоступно).
• Инструктор.
• Тренер.
• Выполнение.
• Примечание.

Примечания:

По умолчанию поля Начало занятия факт = Начало занятия план, Конец занятия факт = Конец занятия план, и их можно изменить.
Длительность рассчитывается после обновления поля "Выполнение".
По умолчанию поле Выполнение пустое. Поле Выполнение выбирается из
enum CompleteLesson {completed, postponed, canceled, frozen} (выполнено, перенесено, отменено, заморожено). В случае выбора из последних двух, открывается inputBox для обязательного ввода примечания. Нельзя сохранить запись с пустым полем Выполнение.

В полях Инструктор и Тренер можно выбрать из выпадающего списка произвольного инструктора и тренера.


11.7.7 Окно "Предпочтения по расписанию"
Класс ClientPreferenceSchedule.
• Форма загружает данные из таблицы work_schedules.
• Для каждого рабочего дня недели (is_day_off = false) отображается строка с:
• Наименованием дня недели.
• Диапазоном доступного времени (взят из work_schedules для этого дня). Например: "Понедельник (доступно с 09:00 до 20:00)". (минус 1 час на последнее занятие: end_time - 1h).
• Полями для ввода или выбором времени (TimePicker) "Желаемое время начала" и "Желаемое время окончания" в пределах доступного диапазона.
• Клиент может заполнить предпочтения для одного или нескольких дней.
• Кнопки "Сохранить" и "Отмена".

11.7.8 Окно "Учет калорий"
Окно представляет собой дашборд, включающий ListView "Таблица учета калорий".
Редактирование разрешено только последней записи.
Поля ListView:
№ занятия (недоступно).
Наименование набора упражнений (недоступно).
Начало занятия факт (недоступно).
Длительность (недоступно).
Входящий вес (in-line). 
Полученные калории (in-line). 
Затраченные калории (недоступно).

Примечания:
Клиент, после создания занятия, вводит свой вес и полученные калории в последнюю запись в режиме in-line. Полученные калории рассчитываются за время в часах, прошедшее с окончания предыдущего занятия до начала текущего. После ввода калорий рассчитывается поле "Затраченные калории" по формуле
Затраченные калории = (BMR / 24 * coeffActivity * ΔT) + calories_out
где:
• BMR - Основной обмен веществ (ккал/день).
• 24 - количество часов в сутках.
• coeffActivity - Коэффициент активности.
• ΔT (Delta T) - Время в часах между занятиями, прошедшее с окончания предыдущего занятия до начала текущего.
• calories_out - Расход на занятии. Рассчитывается как сумма caloriesOut всех упражнений в плане, скорректированная на длительность и интенсивность.
Если занятие первое, то клиент вводит полученные калории за последние сутки и рассчитывается за последние сутки.
Пример 1: Тренировки день через день (короткий интервал)
• Данные:
o BMR = 1600 ккал/день
o coeffActivity = 1.55
o Предыдущее занятие закончилось вчера в 19:00.
o Текущее занятие началось сегодня в 10:00.
o ΔT = 15 часов (с 19:00 до 10:00 следующего дня).
o Расход на занятии = 350 ккал.
• Расчет:
1. Часовой BMR: 1600 / 24 ≈ 66.67 ккал/час
2. Расход за период между тренировками: 66.67 ккал/час * 1.55 * 15 часов ≈ 1550 ккал
3. Общий расход: 1550 ккал + 350 ккал = 1900 ккал
Пример 2: Тренировки 2 раза в неделю (длинный интервал)
• Данные:
o ΔT = 3 дня = 72 часа (с понедельника 19:00 до четверга 19:00).
o Расход на занятии = 400 ккал.
• Расчет:
1. Расход за период: 66.67 ккал/час * 1.55 * 72 часа ≈ 7440 ккал
2. Общий расход: 7440 ккал + 400 ккал = 7840 ккал
Расчет затраченных калорий на занятии является задачей бэкенд-API.

11.7.9 Окно "Прогресс"

Комплекс визуализации прогресса должен включать:
• График зависимости веса и калорий.
• График дефицита/профицита калорий.
• Индикаторы и KPI.
• Выводы системы рекомендаций.
• Интерактивные элементы.
• Адаптивный дизайн.
• Интеграция с планами тренировок.

12 Функциональный модуль "Инструктор"
12.1  Списочная форма
ListView инструкторов должна отображаться в дашбордах тренера, менеджера в окне "Инструкторы".


12.2  Дашборд "Инструктор"
Дашборд должен быть доступен как инструктору, так и тренеру, и менеджеру, и администратору.
Обозначение: InstructorDashboard.
Меню дашборда:
• Главное. Экран дашборда.
• Профиль. Экран с личной информацией.
• Клиенты
• Мой тренер.
• Мой менеджер (при включенном roleManager из файла настройки).
• Расписание.
• Табель.
• Подменю каталогов, только просмотр. 
• Инфо.

12.2.1 Окно "Клиенты"
Содержит ListView привязанных клиентов, фрейм группового чата. При выборе клиента открывается дашборд клиента.
12.2.2 Окно "Мой тренер"
Содержит фото тренера, полное ФИО, телефон, фрейм чата.
12.2.3 Окно "Мой менеджер"
Содержит фото менеджера, полное ФИО, телефон, фрейм чата.
12.2.4 Окно "Расписание"
Окно содержит персональное расписание инструктора.
12.2.5 Окно "Табель"
Окно содержит дашборд "Табель" в одиночном режиме.


13 Функциональный модуль "Тренер"
13.1 Списочная форма
ListView тренеров должна отображаться в дашборде менеджера, в окне "Тренеры". 
13.2 Дашборд "Тренер"
Дашборд должен быть доступен как тренеру, так и менеджеру, и администратору.
Обозначение: TrainerDashboard.
Меню дашборда:
• Главное. Экран дашборда.
• Профиль. Экран с личной информацией.
• Клиенты.
• Мой менеджер (при включенном roleManager из файла настройки).
• Расписание.
• Табель.
• Подменю каталогов. Тренер может создавать/редактировать только шаблоны упражнений и планов, все остальное – только просмотр.
• Инфо.

13.2.1 Окно "Клиенты"
Содержит ListView привязанных клиентов, фрейм группового чата. При выборе клиента открывается дашборд клиента.
13.2.2 Окно "Инструкторы"
Содержит ListView привязанных инструкторов, фрейм группового чата. При выборе инструктора открывается дашборд инструктора.
13.2.3 Окно "Мой менеджер"
Содержит фото менеджера, полное ФИО, телефон, фрейм чата.
13.2.4 Окно "Расписание"
Окно содержит персональное расписание тренера.
13.2.5 Окно "Табель"
Окно содержит дашборд "Табель" в одиночном режиме.


14 Функциональный модуль "Менеджер"
14.1 Дашборд "Менеджер"
Дашборд должен быть доступен как менеджеру, так и администратору.
Обозначение: ManagerDashboard.
Меню дашборда:
• Главное. Экран дашборда.
• Профиль. Экран с личной информацией.
• Клиенты
• Расписание.
• Табели.
• Подменю каталогов. Доступны для создания/редактирования записей всех каталогов, кроме "Расписание работы центра" и Дежурства сотрудников, они только для просмотра.

14.1.1 Окно "Клиенты"
Содержит ListView привязанных клиентов, фрейм группового чата. При выборе клиента открывается дашборд клиента.
14.1.2 Окно "Инструкторы"
Содержит ListView привязанных инструкторов, фрейм группового чата. При выборе инструктора открывается дашборд инструктора.
14.1.3 Окно "Тренеры"
Содержит ListView привязанных тренеров, фрейм группового чата. При выборе тренера открывается дашборд тренера.
14.1.4 Окно "Расписание"
Содержит все виды расписаний занятий, с выборкой по тренеру, инструктору, клиенту.
Содержит функционал составления общего расписания, обновления по клиенту.

14.1.5 Окно "Табели"
Окно содержит дашборд "Табель" в групповом режиме.
15 Архитектура планов тренировок
Система должна реализовывать модель разделения на Шаблоны и Индивидуальные назначения для поддержки кастомизации тренировок для каждого клиента.
15.1 Таблицы шаблонов (Templates)
Являются общей библиотекой сущностей, доступной для создания и редактирования тренерам.
o training_plan_templates
o set_exercise_templates
o exercise_templates
15.2 Таблицы индивидуальных назначений (Assignments)
Связывают клиента с его персональной версией плана тренировок, созданной на основе шаблонов. Поля в этих таблицах позволяют переопределить любые параметры шаблона (повторы, длительность, порядок, заметки).
o client_training_plans - Связь "клиент - план". Хранит активный план и историю назначений.
o client_set_exercises - Индивидуальные наборы упражнений в рамках плана клиента.
o client_exercises - Индивидуальные упражнения в рамках набора клиента.
15.3 Связь с занятиями
Таблица lessons должна быть связана с таблицей client_training_plans через foreign key, чтобы однозначно идентифицировать, какая персональная версия плана отрабатывалась на занятии.

16 Расписание занятий
16.1 Виды и шаблоны расписаний
Система должна поддерживать следующие виды расписаний и их отображение:
16.1.1 Общее расписание зала
Сводная таблица всех групповых занятий на неделю с привязкой ко времени, залу и тренеру. Должна поддерживать фильтрацию по залу и типу занятия.
16.1.2 Персональное расписание тренера и инструктора
Детальное расписание конкретного тренера с указанием клиентов, планов тренировок и статусов занятий на каждый день. Должно отображать свободные и занятые слоты.
16.1.3 Индивидуальное расписание клиента
Упрощенный вид, отображающий только занятия конкретного клиента с указанием статуса (Завершено, Запланировано, Отменено, Заморожено).
16.1.4 Коллизии предпочтений клиентов
При коллизии (см. класс ClientPreferenceSchedule), отдавать приоритет по дате-времени регистрации. 
16.1.5 Поддержка сложных сценариев
o Повторяющиеся события: Создание расписания по шаблону (ежедневно, еженедельно) на указанный период.
o Исключения: Возможность отменить одно повторяющееся событие в серии.
o Перенос: Возможность изменить время или дату одного события в серии.
o Контроль конфликтов: Система не должна позволять назначать клиенту или тренеру два занятия на одно и то же время.

16.2 Процесс составления расписания
1. Выбор плана тренировок.
2. Проверка конфликтов.
3. Генерация расписания на период.
4. UI для составления расписания.
5. Интеграция с каталогами.
16.3 Процесс работы:
1. Менеджер/Тренер выбирает дату, время, тренера.
2. Система предлагает подходящие планы тренировок based on цели клиентов.
3. Проверяются конфликты в расписании.
4. Рассчитывается длительность и калорийность.
5. Создается расписание с привязкой ко всем каталогам.
16.4 Таблицы расписания
1. Основная таблица расписания schedules.
2. Таблица связи расписания с клиентами schedule_clients.
3. Таблица повторяющихся расписаний recurring_schedules.
4. Таблица исключений расписания schedule_exceptions.
5. Таблица уведомлений о занятиях schedule_notifications.
6. Выходная таблица занятий lessons.

17 Табели
Табели составляются на сотрудников, имеющих время проведения занятий – тренерам и инструкторам.
Табели могут отображаться как на одного сотрудника, так и на группы (роли) и имеет 2 режима: одиночный и групповой.
Табель представляет собой дашборд "Табель" с элементами управления отображения и ListView времени занятий.
В дашборде «Табель» фильтр по умолчанию: archived_at IS NULL.
Администратор может включить «Показать архивных сотрудников».

1. Элементы управления:
• Выбор интервала времени. По умолчанию отображается начало текущего месяца и текущее число.
• Комбобокс "Вид сетки". Выбор разреза времени: день, неделя, месяц. По умолчанию – день. В зависимости от выбора вида сетки, формируются колонки с соответствующими заголовками, уточняющими время.
• Комбобокс "Сотрудники". Отображается только в групповом режиме. Осуществляет выбор групп сотрудников: все, тренеры, инструкторы. По умолчанию – все. 
• Экспорт. Осуществляется выбор экспорта в pdf, xlsx или csv и по кнопке "Экспорт", проводит экспорт в указанный каталог.

2. Режимы отображения табеля.
• Групповой. В левой колонке отображаются сотрудники, выбранные по значению комбобокса "Сотрудники", с общем временем по каждому и общем временем в последней строке "Всего". Далее по горизонтали отображаются колонки в зависимости от выбора комбобокса "Вид сетки". После клика по сотруднику, открывается одиночный режим.
• Одиночный. В этом режиме колонка сотрудника скрывается, ФИО сотрудника добавляется в шапку, так же добавляется колонка со всеми ФИО прикрепленными клиентами, с общем временем по каждому и общем временем в последней строке "Всего". После клика по клиенту, открывается окно "Занятия" клиента за выбранный интервал времени.

В клетках сетки табеля, по колонкам выбранного разреза, отображаются суммирующее фактическое время, полученное функцией подсчета времени занятий.

18 Подсистема рекомендаций по тренингу
Система реализует двухуровневую гибридную модель рекомендаций:
3. Core-ядро (автономное, оффлайн) — алгоритмическая система, работающая на основе данных БД и детерминированных правил. Обеспечивает базовые, безопасные рекомендации, всегда доступные независимо от подключения к внешним сервисам.
4. AI Enhancer (опциональный модуль) — внешний AI-сервис (DeepSeek, Yandex GPT и др.), который при наличии доступа обогащает рекомендации ядра персонализированными советами. Модуль реализован как отдельный опциональный компонент.
Процесс формирования рекомендаций (Core-ядро)
1. Сбор данных: Система анализирует антропометрию (anthropometry_fix, anthropometry_start), соматотип (по обхватам запястья и лодыжки), биоимпеданс (bioimpedance_start при наличии), цель и уровень подготовки клиента.
2. Анализ соматотипа: На основе значений wrist_circ и ankle_circ определяется вероятностный профиль телосложения (процентное соотношение Эктоморф/Мезоморф/Эндоморф) по правилам из каталога types_body_build.
3. Определение типа фигуры: По соотношениям обхватов плеч, талии и бедер вычисляется текущий тип фигуры: "Яблоко", "Груша", "Песочные часы", "Прямоугольник", "Перевернутый треугольник".
4. Качественная оценка: При наличии данных биоимпеданса система оценивает процент жира, мышечную массу и скорость метаболизма, добавляя качественные флаги ("высокий жир", "низкие мышцы", "медленный метаболизм").
5. Генерация рекомендации: На основе собранного "портрета" клиента система:
o Ищет наиболее подходящую запись в таблице готовых рекомендаций training_recommendations по совпадению типа фигуры, цели и уровня подготовки.
o При неполном совпадении или отсутствии записи формирует композитную рекомендацию на основе преобладающих факторов.
o Возвращает два варианта текста: детализированный для тренера (recommendation_text_trainer) и упрощённый для клиента (recommendation_text_client).
18.1 Архитектура алгоритма рекомендаций
Входные данные (от пользователя):
1. Константы: Пол, Возраст, Рост.
2. Генетические замеры (не меняются): Обхват запястья (wrist_circ), Обхват лодыжки (ankle_circ).
3. Текущие динамические замеры: Обхват плеч (shoulders_circ), груди (breast_circ), талии (waist_circ), бедер (hips_circ).
4. Данные биоимпеданса (если есть): Процент жира (fat_percentage), мышечная масса (muscle_mass), скорость основного обмена (BMR).


Рисунок алгоритма рекомендаций

Пояснения к алгоритму
Шаг 1: Определение соматотипа (Вероятностный, генетический профиль).
• Что анализируется: Обхват запястья и лодыжки + пол пользователя.
• Как работает: Система сравнивает замеры с таблицей types_body_build.
• Результат: Вероятностный профиль (например: "Эктоморф: 15%, Мезоморф: 80%, Эндоморф: 5%").
• Особенность: Учитывает генетическую предрасположенность, которая не меняется при тренировках.

• Основа: Данные клиента (пол, wrist_circ, ankle_circ) сверяются с правилами в каталоге "Типы телосложения " (таблица types_body_build).
• Логика:
1. Для каждого типа телосложения (Эктоморф, Мезоморф, Эндоморф) из каталога, подходящего по полу клиента, система рассчитывает балл близости.
2. Расчет балла для запястья:
• Если wrist_circ меньше wrist_min, балл = 0.
• Если wrist_circ между wrist_min и rule_wrist_max, балл = 100 (полное соответствие).
• Если wrist_circ больше wrist_max, балл линейно убывает от 100 до 0 на интервале от wrist_max до (wrist_max + 2 см).
3. Аналогично рассчитывается балл для лодыжки на основе ankle_circ, ankle_min, ankle_max.
4. Итоговый балл по типу = среднее арифметическое баллов для запястья и лодыжки. Если данные для лодыжки отсутствуют, используется только балл для запястья.
5. Система выполняет п.2-4 для всех трех типов.
6. Результат: Формируется профиль вида { "Эктоморф": 25, "Мезоморф": 70, "Эндоморф": 5 }, где значения - процент принадлежности (сумма процентов равна 100 после нормализации).
Шаг 2: Определение Типа Фигуры (Текущий, динамический силуэт).
• Что анализируется: Соотношение обхватов плеч, талии и бедер.
• Как работает: Математический расчет пропорций по четким правилам.
• Результат: Один из типов: "Яблоко", "Груша", "Песочные часы", "Прямоугольник", "Перевернутый треугольник".
• Особенность: Показывает текущее состояние тела, которое можно изменить.
• Основа: Обхват плеч (shoulders_circ), талии (waist_circ), бедер (hips_circ).
• Логика: Алгоритм вычисляет соотношения.
o IF (waist_circ / hips_circ >= 0.85 AND waist_circ > shoulders_circ AND waist_circ > hips_circ) THEN bodytype = 'Яблоко' (Apple).
o IF (hips_circ > shoulders_circ * 1.05) THEN bodytype = 'Груша' (Pear).
o IF (ABS(shoulders_circ - hips_circ) < 0.05 AND (waist_circ / shoulders_circ) < 0.75) THEN bodytype = 'Песочные часы' (Hourglass).
o IF (ABS(shoulders_circ - hips_circ) < 0.05 AND (waist_circ / shoulders_circ) >= 0.75) THEN bodytype = 'Прямоугольник' (Rectangle).
o IF (shoulders_circ > hips_circ * 1.05) THEN bodytype = 'Перевернутый треугольник' (Inverted Triangle).
Шаг 3: Уточнение через Биоимпеданс (Качество состава тела).
• Что анализируется: Процент жира, мышечная масса, скорость метаболизма.
• Как работает: Оценка качества тела относительно здоровых норм.
• Результат: Флаги качества ("высокий жир", "низкие мышцы", "медленный метаболизм").
• Особенность: Дает качественную оценку состава тела.

• Основа: Процент жира (fat_percentage), мышечная масса (muscle_mass), BMR.
• Логика: Алгоритм добавляет "качественную" оценку.
o Фактор ожирения: IF (fat_percentage > max_healthy_for_age_gender) THEN flag = 'high_fat'.
o Фактор худобы: IF (fat_percentage < min_healthy_for_age_gender AND muscle_mass < average) THEN flag = 'low_muscle'.
o Фактор метаболизма: IF (BMR > calculated_average_BMR * 1.1) THEN metabolism = 'fast' ELSE IF (BMR < calculated_average_BMR * 0.9) THEN metabolism = 'slow'.

Шаг 4: Комплексный анализ и вывод рекомендаций
Процесс объединения:
• Система собирает данные всех трех этапов.
• Создает комплексный "портрет" пользователя.
• Учитывает как генетику, так и текущее состояние.
Пример портрета:
• Генетика: Преимущественно мезоморф (70%) с небольшой склонностью к эндоморфу (25%).
• Фигура: "Яблоко" (скопление жира в области талии).
• Качество: Высокий процент жира, нормальные мышцы, медленный метаболизм.

• Основа: Комбинация всех полученных данных: профиль соматотипа  + bodytype + flags + metabolism.
• Логика поиска в БД:
1. Система ищет в таблице training_recommendations записи, соответствующие bodytype, goal_training_id, level_training_id.
2. Если найдено несколько записей, приоритет отдается той, которая лучше всего подходит для преобладающего соматотипа из профиля клиента.
3. Если точного совпадения нет, система формирует композитную рекомендацию. Например, если профиль клиента {"Мезоморф": 60, "Эндоморф": 40}, итоговая рекомендация может быть: "На 60% используй стратегию для мезоморфа, на 40% - стратегию для эндоморфа, уделяя внимание ...".

• Учет смешанных типов для ИИ: Сформированный профиль соматотипа и все остальные данные передаются ИИ как есть. Это позволяет ИИ генерировать truly персонализированные рекомендации, учитывающие смешанную природу телосложения пользователя.

Таблица training_recommendations (Рекомендации по тренировкам)
• body_type// тип фигуры.
• goal_training_id; // из таблицы Цели тренировок.
• level_trainig_id; //из таблицы Уровень подготовки.
• recommendation_text_trainer // Текст рекомендации для тренера.
• recommendation_text_client // Текст рекомендации для клиента.

18.2 Рекомендации на основе ИИ 
AI-обогащение (опционально)
1. При наличии настройки use_ai_recommendations = true и доступности внешнего AI-сервиса:
2. Система отправляет AI-модулю структурированный "портрет" клиента (результаты анализа ядра + исходные данные).
3. AI-модель выступает в роли эксперта-тренера, персонализируя и дополняя базовую рекомендацию:
o Предлагает конкретные упражнения с учётом смешанного типа телосложения.
o Даёт советы по питанию и восстановлению.
o Объясняет рекомендации простым языком.
Алгоритмы и таблица: Формируют структурированный, проверенный и безопасный каркас рекомендаций. Новая вероятностная модель обеспечивает гораздо более высокую точность для пользователей со смешанным типом телосложения.
ИИ-модель (LLM DeepSeek): Выступает как "креативный ассистент-эксперт", который:
• Персонализирует стандартные рекомендации под уникальный, в том числе смешанный, кейс на основе переданного профиля.
• Генерирует конкретные примеры, учитывающие нюансы смешанного типа (например, "так как у вас есть склонность к эндоморфу, несмотря на мезоморфную основу, рекомендуем...").
• Объясняет сложные концепции простым языком.
Обновленный Пример Промпта (Запроса) для ИИ:
Ты - опытный персональный тренер и диетолог с 10-летним опытом. 
Генерируй персонализированные рекомендации по тренировкам и питанию.

ОГРАНИЧЕНИЯ И ПРАВИЛА:
1. НЕ давай медицинских рекомендаций и диагнозов
2. НЕ предлагай добавки и фармакологию
3. НЕ создавай экстремальные диеты (менее 1200 ккал/день)
4. Призывай консультироваться с врачом при проблемах со здоровьем
5. Используй только научно-доказанные методы
6. Учитывай российские пищевые привычки и доступность продуктов
ДАННЫЕ ПОЛЬЗОВАТЕЛЯ:
- Пол: {пол}
- Возраст: {возраст}
- Цель: {цель_из_таблицы}
- Опыт тренировок: {уровень}
- Генетический профиль телосложения (соматотип): {рассчитанный_профиль_соматотипа} // Напр.: "Эктоморф: 15%, Мезоморф: 80%, Эндоморф: 5%"
- Актуальный тип фигуры: {тип_фигуры}
- Биоимпеданс: процент жира - {процент_жира}, мышечная масса - {мышцы}, скорость метаболизма - {BMR}.
- Основная рекомендация из нашей базы данных: "{базовая_рекомендация_из_БД}"
ОСОБОЕ ВНИМАНИЕ: Учти, что у пользователя смешанный тип телосложения. Сгенерируй рекомендации, которые объединят подходы для его преобладающего типа, но скорректируют их с учетом влияния второстепенных типов.
СФОРМУЛИРУЙ РЕКОМЕНДАЦИИ:
1. Тренировки: Предложи 2-3 конкретных упражнения, которые особенно эффективны для этого сочетания типов и цели. Объясни, почему они подходят именно для его смешанного профиля.
2. Питание: Дай совет по балансу БЖУ и калорийности, учитывающий его метаболизм и генетические склонности.
3. Образ жизни: Дай 1-2 совета по восстановлению.
4. Предупреждение: Укажи на главную ошибку, которую ему стоит избегать, исходя из его профиля.
Тон: поддерживающий, мотивирующий, профессиональный, но без сложного жаргона.
18.3 Интеграция в интерфейс
• Доступ к рекомендациям осуществляется через кнопку "Получить рекомендации" в окне "Антропометрия" клиентского дашборда.
• При нажатии открывается модальное окно "Персональные рекомендации", содержащее:
o Базовые рекомендации (из ядра системы)
o AI-обогащённые рекомендации (при наличии)
o Кнопку "Улучшить с помощью AI" для повторного запроса к AI-сервису
• Для ролей Тренер и Менеджер рекомендации также доступны в карточке клиента, с отображением детализированной версии (recommendation_text_trainer).


19 Команды (pattern Command)
Команда реализует паттерн Command. Каждая команда должна иметь спецификацию. Команда должна иметь полную логику действий – в случае нескольких операций, не разбивать их на подкоманды, а выполнять все операции в одной команде, заключая их в блоки try-catch.

Каждая команда реализует интерфейс Command<T> с методом
Future<Result<T, String>> execute();

• Команда не знает о слое UI и не возвращает виджеты.
• Все входные данные передаются через конструктор и не изменяются после создания.
• Команда логирует начало, успешное завершение и ошибку уровня INFO / ERROR.
• В случае исключения, команда перехватывает его и возвращает Failure.

Все команды, имеющие бизнес-сценарии, должны быть задачами бэкенд-API.

20 Каталоги (Catalogs)
• Все каталоги должны иметь списочную форму и карточку или дашборд. В списке должна быть панель с элементами управления: создание, клонирование, сохранение, удаление, поиск. В карточке аналогично должна быть панель элементов (без поиска), а также возможность изменения, удаления, выбора полей сущности.
• Если действия (создание, сохранение и т.д.) требуют внутреннюю логику, обращение к нескольким таблицам, то создавать отдельные команды.
• В списочной форме чек-бокс "Показать архивные" добавляет фильтр archived_at IS NOT NULL. Архивные строки выделяются серым фоном.
• Все таблицы каталогов должны иметь поле замечаний: note (VARCHAR(100));
• Работа со каталогами в полном объеме (CRUD) доступна ролям "Администратор" и "Менеджер". Роль "Тренер" имеет разрешение создавать записи, изменять и удалять. Изменять и удалять записи может только свои. Роль "Инструктор" имеет разрешение на просмотр и переход. Роли "Клиент" каталоги недоступны.

Каталог "Виды активности клиента "
Необходим для определения коэффициента активности для расчета калорийности BMR. 
Таблица kinds_activity_client
Поля:
• name (VARCHAR(100));
• coeffActivity (REAL); //Коэффициент активности.

Каталог "Уровни фитнес-подготовки"
Необходим для сопоставления с планами тренировок. 
Таблица levels_training
Поля:
• name (VARCHAR(20));

Класс LevelTrainingCatalog
Поля:
• name.

Списочная форма
Заголовок: Уровни фитнес-подготовки
Отображаемые поля: 
• Наименование (name).

Каталог "Цели тренировок"
Таблица goals_training
Поля:
• name (VARCHAR(20));
Класс GoalTrainingCatalog
Поля:
• name.

Списочная форма
Заголовок: Цели тренировок
Отображаемые поля: 
• Наименование (name).

Каталог "Типы телосложения "
Необходим для составления рекомендаций. 
Таблица types_body_build
Поля:
• name (VARCHAR(20)); //Название: "Эктоморф", "Мезоморф", "Эндоморф";
• description (VARCHAR(200)); //Описание;
• gender (VARCHAR(20)); //Пол, для которого правило актуально: 'M', 'Ж', 'ALL';
• wrist_max (REAL); //Максимальное значение обхвата запястья для этого типа);
• wrist_min (REAL); //Минимальное значение обхвата запястья для этого типа;
• ankle_max (REAL); //Максимальное значение обхвата лодыжки для этого типа;
• ankle_min (REAL); //Минимальное значение обхвата лодыжки для этого типа;

Класс TypeBodyBuildCatalog
Поля:
• name;
• description;
• gender;
• wristMax;
• wristMin;
• ankleMax;
• ankleMin;

      
Каталог "Виды Упражнений"
Таблица kinds_exercis
Поля:
• name (VARCHAR(100));
Класс KindExercisCatalog
Поля:
• name;

   Списочная форма
      Заголовок: Виды упражнений
      Отображаемые поля: Наименование (name).
   Карточка
      Заголовок: Вид упражнения
      Отображаемые поля: Наименование (name).
      
Каталог "Типы Упражнений"
Таблица types_exercis
Поля:
• name (VARCHAR(100));
• kind_exercis_id (BIGINT);
• equipment_type_id (BIGINT);


Класс TypeExercisCatalog
Поля:
• name;
• kindExercis;
• typeEquip;
   Списочная форма
      Заголовок: Типы упражнений
Отображаемые поля:
• Наименование (name)
• Вид упражнения (kindExercis.name)
• Фото оборудования (typeEquip.photo).
   Карточка
      Заголовок: Тип упражнения
Отображаемые поля:
• Наименование (name)
• Вид упражнения (kindExercis.name)
• Фото оборудования (typeEquip.photo).
К полю kindExercis.name привязана кнопка с действием выбора вида упражнения из списка в popup-окне.

Каталог "Упражнения"
Таблица exercises_templates
Поля:
• name (VARCHAR(100));
• repeatQty (INT);
• duration_exec (REAL);
• duration_rest (REAL);
• caloriesOut (REAL);
• is_group (BOOL, false);
• type_exercis_id (BIGINT);

Класс ExercisCatalog
Поля:
• name;
• repeatQty; //nullable (Количество повторов).
• durationExec; //Длительность проведения в минутах.
• durationRest; //Длительность отдыха после упражнения в минутах.
• caloriesOut; //Расход калорий в кал.
• isGroup; //Групповое упражнение.
• typeExercis; //Тип.

   Списочная форма
      Заголовок: Упражнения - шаблон
Отображаемые поля: 
• Фото (typeExercis.typeEquip.photo).
• Наименование (name).
• Количество повторов (repeatQty).
• Время проведения (durationExec).
• Время отдыха (durationRest).
• Расход калорий в калориях (caloriesOut).
• Групповое (isGroup).
   Карточка
      Заголовок: Упражнение - шаблон
Отображаемые поля: 
• Фото (typeExercis.typeEquip.photo).
• Наименование (name).
• Количество повторов (repeatQty).
• Время проведения (durationExec).
• Время отдыха (durationRest).
• Расход калорий в калориях (caloriesOut).
• Групповое (isGroup).

Каталог "Набор упражнений"
Таблица sets_exercises_templates
Поля:
• name (VARCHAR(100));
• level_training_id; //уровень фитнес-подготовки

Таблица отношений "Набор упражнений - Упражнения"
Обозначение: set_exercises_templates_exercis_templates
Поля: set_exercises_template_id, exercis_template_id.


Класс SetExercisCatalog
Поля:
• name;
• exercisQty (int); //расчетное, кол-во упражнений.
• durationExecSum (double); //расчетное, длительность проведения всех упражнений.
• durationRestSum(double); //расчетное, длительность отдыха упражнений.
• durationSum(double); //расчетное, durationExecSum + durationRestSum.
• caloriesOutSum (double); //расчетное, расходуемые калории. 

   Списочная форма
      Заголовок: Наборы упражнений - шаблон
Отображаемые поля: 
• Наименование (name).
• Уровень подготовки (level_training_id).
• Количество (exercisQty).
• Длительность упражнений (durationExec).
• Отдых (durationRestSum).
• Длительность набора (durationSum).
• Расход калорий (caloriesOutSum).

 Дашборд
 Заголовок: Набор упражнений - шаблон
 Отображаемые поля: 
• Наименование (name).
• Уровень подготовки (level_training_id).
• Количество (exercisQty).
• Длительность упражнений (durationExec).
• Длительность отдыха между упражнениями(durationRestSum).
• Длительность набора упражнений (durationSum).
• Расход калорий (caloriesOutSum).
Элемент дашборда представляет собой фрейм с наименованием "Упражнения". Во фрейме сверху размещается панель инструментов с активной кнопкой "Добавить" и неактивной кнопкой "Удалить".  Так же находится список упражнений, привязанный к данному набору. При выделении строки из списка, кнопка "Удалить" становится активной.
При нажатии на кнопку "Добавить" отображается popup-окно со списком всех упражнений, с неактивной кнопкой "Ок" и активной кнопкой "Отмена". По кнопке "Отмена", окно закрывается. При выделении строки из списка упражнений, кнопка "Ок" становится активной. По кнопке "Ок", окно закрывается и выбранное упражнение добавляется к списку упражнений.
При нажатии на кнопку "Удалить" удаляется id выбранного упражнения по id набора упражнений из таблицы set_exercises_exercis.
После изменения списка упражнений, все поля должны обновиться.

Каталог "Планы тренировок"
Каталог имеет записи плана тренировок – наборы упражнений в отношении один ко многим.
Таблица training_plan_templates
Поля:
• name (VARCHAR(100));
• goal_training_id (BIGINT). //из таблицы Цели тренировок

Таблица отношений "Планы тренировок – Наборы упражнений"
Обозначение: training_plan__templates_set_exercises_templates
Поля: training_plan_template_id, set_exercises_template_id.

Класс TrainingPlanCatalog
Поля:
• name;
• kindTrainingPlan; //вид плана тренировок.
• setExercisQty (int); //расчетное, кол-во наборов упражнений.
• exercisQty (int); //расчетное, кол-во упражнений.
• durationExecSum (double); //расчетное, длительность всех упражнений.
• durationRestSum(double); //расчетное, длительность отдыха упражнений.
• durationSum(double); //расчетное, durationExecSum + durationRestSum.
• caloriesOutSum (double); //расчетное, расходуемые калории. 
   
   Списочная форма
      Заголовок: Планы тренировок – шаблон
      Отображаемые поля: 
• Наименование (name).
• Вид плана тренировок (kindTrainingPlan.name).
• Длительность упражнений (durationExec).
• Длительность отдыха между упражнениями (durationRestSum).
• Длительность набора упражнений (durationSum).
• Расход калорий (caloriesOutSum).
   Дашборд
      Заголовок: План тренировок - шаблон
      Отображаемые поля: 
• Наименование (name).
• Вид плана тренировок (kindTrainingPlan.name).
• Длительность упражнений (durationExec).
• Длительность отдыха между упражнениями (durationRestSum).
• Длительность набора упражнений (durationSum).
• Расход калорий (caloriesOutSum).
Элемент дашборда представляет собой фрейм с наименованием "Наборы упражнений". Во фрейме сверху размещается панель инструментов с активной кнопкой "Добавить" и неактивной кнопкой "Удалить".  Так же находится список наборов упражнений, привязанный к данному плану. При выделении строки из списка, кнопка "Удалить" становится активной.
При нажатии на кнопку "Добавить" отображается popup-окно со списком всех наборов упражнений, с неактивной кнопкой "Ок" и активной кнопкой "Отмена". По кнопке "Отмена", окно закрывается. При выделении строки из списка упражнений, кнопка "Ок" становится активной. По кнопке "Ок", окно закрывается и выбранный набор упражнений добавляется к списку.
При нажатии на кнопку "Удалить" удаляется id выбранного набора упражнений по id плана из таблицы training_plan_set_exercises.  
После изменения списка упражнений, все поля должны обновиться.

Каталог "Заявки (Лид-менеджмент)"
Таблица onboarding_client
   Поля:
• first_name (VARCHAR(100));//Имя
• last_name (VARCHAR(100));//Фамилия
• middle_name (VARCHAR(100); //Отчество
• gender (VARCHAR(20)); //'М', 'Ж'
• age (int); //Возраст
• phone (VARCHAR(20));  //Телефон
• email (VARCHAR(100);  //E-mail
• feedback_method (VARCHAR(20));  //способ обратной связи: 'телефон' или 'почта'
• is_contact_on_website (bool); //по умолчанию – false, признак холодного контакта клиента через вебсайт
• is_client_build (bool); //признак, что на основе записи создан клиент
• client_build_at (TIMESTAMP); //дата-время создания клиента


Класс OnboardingClientCatalog
   Поля:
• firstName (string);//Имя
• lastName (string);//Фамилия
• middleName (string); //Отчество
• gender (string); //'М', 'Ж'
• age (int); //Возраст
• phone (string);  //Телефон
• email (string);  //E-mail
• feedbackMethod(string); //способ обратной связи: 'телефон' или 'почта'
• isContactOnWebsite (bool); //признак холодного контакта клиента через вебсайт
• isClientBuild (bool); //признак создания клиента
• clientBuildAt (datetime); // дата-время создания клиента
• archived_at (Timestamp)
• archived_by (BIGINT)
• note (VARCHAR(100)); //примечание


Списочная форма
Заголовок: Заявки (Лид-менеджмент)
Отображаемые поля: 
• Имя (firstName)
• Фамилия (lastName)
• Отчество (middleName)
• Пол (gender)
• Возраст (age)
• Телефон (phone)
• E-mail (email)
• Cпособ обратной связи (feedbackMethod)
• Активное (isActive)
Форма содержит панель инструментов с поиском по имени, фамилии, телефону, почте. Так же содержит чекбокс по полю isActive, по умолчанию true.
Карточка
Заголовок: Заявка (Лид-менеджмент)
Отображаемые поля:
• Имя (firstName)
• Фамилия (lastName)
• Отчество (kindEquip.name)
• Пол (gender)
• Возраст (age)
• Телефон (phone)
• E-mail (email)
• Зашел через сайт (isContactOnWebsite)
• Cпособ обратной связи (feedbackМethod)
• Активное (isActive)
• Примечание менеджера (note)

Обязательность полей при создании записи: 
• firstName;
• gender;
• age;
• phone или email. Обязательное хотя бы одно из двух.
Карточка содержит кнопку "Создать клиента", которая вызывает функцию-команду создания клиента. При успешном создании, заполняются поля isClientBuild, ClientBuildAt и isActive.

Каталог "Расписание работы центра"
Таблица work_schedules
Поля:
• day_of_week (Integer, NOT NULL, UNIQUE). День недели: 1 (Понедельник) - 7 (Воскресенье).
• start_time (Time, NOT NULL). Время начала работы (например, 09:00).
• end_time (Time, NOT NULL). Время окончания работы (например, 21:00).
• is_day_off (Boolean, default: false). Флаг, указывающий, что этот день недели по умолчанию нерабочий (например, Воскресенье).

Класс WorkSchedule
Поля:
• dayOfWeek;
• startTime;
• endTime;
• IsDayOff


Каталог "Дежурства сотрудников"
Каталог имеет записи дежурства сотрудников по центру.
Таблица employees_duty
Поля:
• user_id(BIGINT). //из таблицы users
• duty_start_at (TIMESTAMP); //время начала дежурства
• duty_finish_at (TIMESTAMP); //время окончания дежурства

Класс EmployeeDuty
Поля:
• userId; //сотрудник
• dutyManagerStartAt (DateTime); //время начала дежурства
• dutyManagerFinishAt (DateTime); //время окончания дежурства
   Списочная форма
      Заголовок: "Дежурства сотрудников"
      Отображаемые поля: 
• ФИО (userId).
• Время начала (dutyManagerStartAt).
• Время окончания (dutyManagerFinishAt).
   Дашборд
      Заголовок: "Дежурство сотрудника" + ФИО
      Отображаемые элементы: 
• ФИО (userId).
• ListView по userId с полями Время начала, Время окончания.

Каталог "Квалификации"
Каталог имеет записи квалификаций тренеров и инструкторов.
Таблица employees_qualifications
Поля:
• user_id (BIGINT); //из таблицы users
• education_level (SMALLINT); //enum employeeEducation ('высшее', 'среднее', 'курсы')
• specialization (SMALLINT); //enum employeeSpec ('фитнес', 'йога', 'реабилитация')
• qualification_date (TIMESTAMP); //дата присвоения квалификации
• education_document (URL); //скан диплома/сертификата


Класс employeeQualification
Поля:
• userId; //сотрудник
• educationLevel (Enum); //enum employeeEducation 
• specialization (Enum); //enum employeeSpec
• qualificationDate (DateTime);
• educationDocument (Image); //скан документа  
   Списочная форма
      Заголовок: "Квалификации"
      Отображаемые поля: 
• ФИО (userId);
• Уровень (educationLevel );
• Специализация (specialization);
• Дата квалификации (qualificationDate);
   Дашборд
      Заголовок: "Квалификация" + ФИО
      Отображаемые элементы: 
• ФИО (userId);
• Уровень (educationLevel );
• Специализация (specialization);
• Дата квалификации (qualificationDate);
• Скан (educationDocument);

21 Оффлайн-режим (Offline-First Approach)
21.1 Цель и Область применения
Система должна быть способна функционировать с ограниченным или полностью отсутствующим интернет-соединением для выполнения критически важных бизнес-процессов. Основной фокус — на мобильном приложении для ролей Тренер и Инструктор, которые работают непосредственно в зале, где связь может быть нестабильной.
21.2 Архитектура оффлайн-работы
• Стратегия: Offline-First. Приложение по умолчанию пытается сохранять данные локально, а затем синхронизировать их с сервером при наличии соединения.
• Локальное хранилище: Использование Hive или Sembast для быстрого и надежного локального хранения структурированных данных.
• Механизм синхронизации: Фоновая синхронизация при восстановлении соединения с использованием очереди (queue) отложенных запросов.
21.3 Функциональность, доступная оффлайн
Для Тренера/Инструктора:
• Просмотр расписания: Доступ к расписанию на текущий и следующий день.
• Просмотр карточек клиентов: Основная информация, актуальные планы тренировок, последние замеры.
• Фиксация занятий:
o Отметка начала и окончания занятия (start_fact_at, finish_fact_at).
o Ввод фактических параметров занятия (примечания, изменение упражнений "на лету").
o Ввод weight и calories_in для клиента после занятия.
• Работа с чатом: Просмотр истории чатов, отправка сообщений (доставляются при появлении сети).
Для Клиента:
• Просмотр своего расписания и деталей ближайшего занятия.
• Просмотр своего дневника калорий и прогресса.
• Ввод данных о потребленных калориях и весе.
21.4 Процесс синхронизации
1. Обнаружение сети: Приложение автоматически определяет восстановление стабильного интернет-соединения.
2. Выполнение очереди:
o Данные, созданные или измененные оффлайн, помещаются в специальную таблицу pending_sync_operations (локально).
o При появлении сети система последовательно отправляет эти данные на сервер.
3. Разрешение конфликтов:
o Стратегия: "Последнее изменение побеждает" (Last Write Wins - LWW) на основе меток времени updated_at.
o Если конфликт не может быть разрешен автоматически (например, изменение одних и тех же данных разными пользователями оффлайн), запись помечается как требующая ручного разрешения администратором/менеджером.
21.5 Ограничения оффлайн-режима
• Невозможно оффлайн:
o Первоначальная регистрация и вход в систему (требует аутентификации).
o Составление нового расписания.
o Генерация сложных отчетов.
o Получение онлайн-рекомендаций от ИИ.
o Работа с каталогами (создание/редактирование шаблонов упражнений).
• Уведомления: Push-уведомления не доставляются оффлайн. Локальные уведомления (напоминания о начале занятия) работают.
21.6 Требования к данным
• Кэширование при запуске: При наличии сети приложение заранее кэширует данные, необходимые для работы в течение дня:
o Активное расписание пользователя.
o Карточки прикрепленных клиентов (тренеру).
o Активные планы тренировок.
o Последние сообщения в чатах.
• Политика устаревания кэша: Локальные данные считаются актуальными в течение 24 часов. При попытке работы с устаревшим кэшем система показывает предупреждение.
21.7 Пользовательский интерфейс
• Индикатор статуса: В верхней части интерфейса всегда отображается значок:
o Зеленый / "Online" — стабильное соединение.
o Желтый / "Синхронизация..." — идет процесс синхронизации.
o Красный / "Оффлайн" — соединение отсутствует.
• Уведомления: При отправке данных в оффлайне появляется сообщение "Сообщение будет отправлено при подключении к сети". После успешной синхронизации — "Все данные синхронизированы".
21.8 Техническая реализация
dart
// Примерная структура очереди синхронизации
class PendingSyncOperation {
  String id;
  String tableName; // 'lessons', 'track_calories', etc.
  String operation; // 'INSERT', 'UPDATE'
  Map<String, dynamic> data;
  DateTime timestamp;
  int retryCount;
}

22 Архивация и восстановление записей
1. В каждой таблице обязательно присутствуют два служебных поля:
archived_at timestamp with time zone NULL – дата/время архивации;
archived_by bigint NULL – ссылка на users(id), кто архивировал.
NULL в обоих полях означает «запись активна».
2. Архивация выполняется командой ArchiveEntityCommand (паттерн Command), которая:
проверяет право «Архивировать» у текущей роли;
заполняет archived_at = now(), archived_by = current_user_id;
пишет запись в audit_log (действие = ‘ARCHIVE’).
3. Восстановление – командой RestoreEntityCommand, которая:
сбрасывает archived_at и archived_by в NULL;
пишет в audit_log действие ‘RESTORE’.
4. На всех таблицах создаётся RLS-политика (или эквивалентный механизм БД):
sql 
USING (archived_at IS NULL)
Политика действует для ролей «Клиент», «Инструктор», «Тренер», «Менеджер».
Роль «Администратор» видит записи без ограничений.
5. Списочные формы по умолчанию не выводят архивные строки. Чек-бокс «Показать архивные» добавляет условие archived_at IS NOT NULL.
6. Экспорт/отчёты/API-методы, не предназначенные для администратора, автоматически фильтруют archived_at IS NULL.
7. Физическое удаление (DELETE) запрещено; используется только логическое удаление через архивацию.


23 Аудит и журнал событий (Audit Log)
1. Цель
Обеспечить полную прослеживаемость изменений любых данных системы (клиенты, сотрудники, расписания, справочники, архивация/восстановление) без физического хранения версий строк.
2. Единая таблица аудита
Создаётся одна таблица на всю БД:
sql 
CREATE TABLE audit_log (
id            bigserial PRIMARY KEY,
table_name    text      NOT NULL,                       -- имя таблицы-источника
row_pk        bigint    NOT NULL,                       -- PK изменённой строки
action        text      NOT NULL CHECK (action IN (
 'INSERT','UPDATE','DELETE','ARCHIVE','RESTORE')),
changed_at    timestamptz DEFAULT now(),
changed_by    uuid      REFERENCES users(id),
old_values    jsonb,                                    -- предыдущие значения (NULL при INSERT)
new_values    jsonb                                     -- новые значения (NULL при DELETE)
);
3. Триггеры
Для каждой таблицы автоматически создаются триггеры AFTER INSERT, AFTER UPDATE, AFTER DELETE (через миграцию или генератор кода).
Триггер:
заполняет table_name = TG_TABLE_NAME,
row_pk = NEW.id / OLD.id,
action по типу операции,
changed_by = current_user_id() (из RLS-сессии),
old_values = to_jsonb(OLD), new_values = to_jsonb(NEW).
При архивации/восстановлении (команды ArchiveEntityCommand / RestoreEntityCommand) триггер фиксирует action = 'ARCHIVE' или 'RESTORE'.
4. Доступ к журналу
• Просмотр аудита доступен только роли Администратор.
• В карточке любой сущности кнопка «История» открывает список записей audit_log отфильтрованных по table_name + row_pk, отсортированных по changed_at DESC.
• Для удобства чтения поля old_values/new_values отображаются в виде сворачиваемого JSON-дерева; значения дат/чисел форматируются по текущей локали.
5. Хранение и ротация
Строки хранятся 36 месяцев.
Ежедневным cron-Job (pg_cron или внешний планировщик) удаляются записи старше 36 мес:
sql 
DELETE FROM audit_log WHERE changed_at < now() - interval '36 months';
6. Производительность
Индексы:
(table_name, row_pk, changed_at DESC) – быстрая выборка истории строки.
(changed_at) – быстрая чистка старых данных.
Триггеры объявляются FOR EACH ROW, но только при первичной записи (без каскадных UPDATE-ов) чтобы избежать рекурсии.
7. Интерфейс
• Списочная форма «Аудит» (доступна только администратору): фильтры по периоду, таблице, пользователю, типу действия; экспорт в CSV/XLSX.
• Виджет «Последние изменения» на дашборде администратора: 10 последних записей системы.
8. Безопасность
• Таблица audit_log не подлежит архивации (archived_at не добавляется).
• Прямое изменение/удаление строк audit_log запрещено триггером BEFORE DELETE / UPDATE (только SELECT и INSERT).
• Маскировка чувствительных данных: перед записью в new_values/old_values поля password_hash, sms_code, jwt_refresh_token обнуляются ('::text = '***').


24 Файл настроек приложения
Файл настроек приложения должен быть типовым средством фреймворка технологического стека. В файле должны содержаться следующие ключи:
Контактный телефон (contactPhone).
• E-mail (contactEmail).
• Посылать уведомления (sendNotification).
• Уведомление до начала занятий (часов) (hourNotification).
• SMS-шлюз (smsGate).
• Роль инструктора (roleInstructor). Включение и отключение (по умолчанию) роли инструктора.
• Роль менеджера (roleManager). Включение (по умолчанию) и отключение роли менеджера.
• Учет калорий (trackCalories). Включение (по умолчанию) и отключение функционала учета калорий клиентов.

• Текст приглашения для клиента (invitationText).
• Время жизни ссылки-приглашения (часы) (invitationLinkTTL).
• SMTP-хост (smtpHost).
• SMTP-порт (smtpPort).
• SMTP-логин (smtpLogin).
• SMS-шлюз URL (smsGateUrl).
   
   Файл настроек доступен только администратору.



25 
Сайт компании
   Сайт компании выполняет две ключевые функции: 
• Маркетинговую для привлечение новых клиентов.
• Служит точкой входа в веб-версию приложения для существующих пользователей.
25.1 Общие требования к дизайну и архитектуре
• Стиль: Строгий, лаконичный, корпоративный. Академичный подход с акцентом на надежность и профессионализм. Минимум декоративной графики.
• Технологии: Веб-сайт должен быть реализован как Single Page Application (SPA) на Flutter Web, что обеспечит единообразие дизайна и логики с мобильными приложениями.
• Адаптивность: Сайт должен корректно отображаться и функционировать на устройствах с разным разрешением экрана (десктоп, планшет, смартфон).
• Навигация: Интуитивно понятное главное меню, расположенное в шапке сайта. Меню должно быть доступно на всех страницах.
25.2 Структура и содержание страниц
Сайт состоит из следующих обязательных страниц:
• Главная страница («О компании»):
o Краткое описание фитнес-центра, его философия, преимущества.
o Блок с ключевыми показателями (количество довольных клиентов, лет на рынке и т.д.).
o Призыв к действию (CTA) "Оставить заявку".
o Призыв к скачиванию apk мобильной версии на Андроид.
• Контакты:
o Адрес центра с интерактивной картой (Google Maps/Яндекс.Карты).
o Телефон, email, график работы.
o Форма для обратной связи (упрощенный аналог блока "Составить заявку").
• Расписание работы: Информация о работе центра по дням недели. Данные должны подгружаться из таблицы work_schedules (только для чтения).
• FAQ: Страница с ответами на часто задаваемые вопросы.
• Отзывы: Модуль для отображения отзывов реальных клиентов.
25.3 Функциональные блоки
25.3.1 Блок «Составить заявку» (Форма лида)
Это ключевой маркетинговый элемент, доступный на главной странице и в виде всплывающего модального окна на других страницах.
• Поля формы:
1. Имя (обязательное, текст).
2. Пол (обязательное, выпадающий список: Мужской, Женский).
3. Возраст (обязательное, число).
4. Телефон (условно-обязательное, валидация формата).
5. Email (условно-обязательное, валидация формата).
6. Способ обратной связи (обязательное, радиокнопки: "По телефону", "По email"). Логика: если выбран телефон, обязательным становится поле "Телефон", и наоборот.
• Логика работы:
1. Валидация на стороне клиента: При попытке отправить форму проверяется заполненность обязательных полей и корректность формата. Ошибки выводятся рядом с полями.
2. Отправка данных: При нажатии кнопки "Отправить" данные формы отправляются методом POST на защищенный (HTTPS) API-эндпоинт бэкенда (например, /api/leads).
3. Обработка на сервере: Бэкенд создает запись в таблице onboarding_client и запускает процесс уведомления дежурного менеджера (как описано в разделе об онбординге).
4. Реакция на клиенте: После успешной отправки форма скрывается, а пользователю показывается сообщение: "Спасибо! Ваша заявка принята. Наш менеджер свяжется с вами в ближайшее время.".
25.3.2 Блок «Личный кабинет»
Это веб-интерфейс основного приложения, доступный после аутентификации.
• Страница входа:
o Поля: "Логин (Email/Телефон)" и "Пароль".
o Кнопка "Войти".
o Ссылка "Забыли пароль?" (запускает стандартный процесс сброса через email).
• Функциональность после входа:
o После успешной аутентификации пользователь перенаправляется на дашборд, соответствующий его роли (Клиент, Тренер, Менеджер, Администратор).
o Функциональность веб-дашбордов на 100% идентична функциональности мобильного приложения, описанной в разделах "Функциональный модуль «Клиент»", «Тренер» и т.д.
o Интерфейс должен быть оптимизирован для управления с помощью мыши и клавиатуры, но сохранять общую стилистику мобильного UI.
25.4 Интеграция с основной системой
• API: Веб-сайт общается с бэкендом через те же API и RESTful эндпоинты, что и мобильное приложение.
• Аутентификация: Используется единая система аутентификации. Сессия, открытая в браузере, не должна конфликтовать с сессией в мобильном приложении.
• Данные: Данные для страниц "Расписание работы" и др. должны браться напрямую из БД основной системы, чтобы избежать дублирования и расхождения информации.
25.5 Требования к контенту и SEO
• Контент: Все тексты на сайте должны быть уникальными, грамотными и отражать специфику центра.
• Мета-теги: Настройка title, description и keywords для каждой страницы.
• Скорость загрузки: Оптимизация изображений и кода для быстрой загрузки страниц, что критично для SEO и удержания пользователей.



26 Интеграция с системами бухгалтерского учета
Данный раздел описывает архитектуру, механизмы и требования к интеграции системы «Фитнес-менеджер» с внешними бухгалтерскими и финансовыми системами на примере типовой интеграции с «1С:Предприятие».
Интеграция обеспечивает двусторонний обмен ключевыми бизнес-данными для автоматизации учёта клиентов, платежей, абонементов и посещений.
26.1 Общие положения
Цель интеграции:
Автоматизация передачи финансово-учётных данных между FitMan и бухгалтерской системой для исключения ручного ввода, минимизации ошибок и обеспечения актуальности данных в обеих системах.
Основные принципы:
• Двусторонняя синхронизация: Данные могут передаваться как из FitMan в 1С, так и в обратном направлении (например, обновление реквизитов клиента).
• Поддержка различных конфигураций 1С: Интеграция должна быть гибкой и настраиваемой под типовые конфигурации («1С:Бухгалтерия», «1С:Зарплата и управление персоналом», «1С:Управление торговлей»).
• Надёжность и отказоустойчивость: Использование очереди сообщений, повторные попытки отправки, логирование всех операций.
• Безопасность: Все данные передаются по защищённым каналам (HTTPS), используются ключи API, чувствительные данные шифруются.
26.2 Синхронизируемые сущности и сценарии
26.2.1 Клиенты (физические лица)
• Направление: В основном FitMan → 1С (при создании/обновлении клиента).
• Данные: ФИО, пол, дата рождения, контакты (телефон, email), дата регистрации.
• Сценарий: Новый клиент регистрируется в FitMan → его карточка автоматически создаётся в 1С как контрагент (физическое лицо).
26.2.2 Платежи и финансовые операции
• Направление: FitMan → 1С.
• Данные: Сумма, дата и время оплаты, тип платежа (абонемент, разовое занятие, товар), способ оплаты (наличные, карта, перевод), привязка к клиенту и договору.
• Сценарий: Клиент оплачивает абонемент через кассу FitMan → платёж фиксируется в 1С как приходный кассовый ордер (ПКО) или поступление на расчётный счёт.
26.2.3 Абонементы и договоры оказания услуг
• Направление: Двусторонняя.
• Данные: Тип абонемента (месячный, годовой, разовый), срок действия, стоимость, статус (активен, приостановлен, завершён), привязка к клиенту.
• Сценарий: Менеджер оформляет в FitMan новый абонемент клиенту → в 1С создаётся документ «Договор оказания услуг» или регистрируется продажа услуги.
26.2.4 Посещения и оказанные услуги (для аналитики и расчёта зарплаты)
• Направление: FitMan → 1С.
• Данные: Факт посещения клиентом занятия (дата, время, тип услуги), привязка к тренеру (для расчёта вознаграждения).
• Сценарий: После завершения занятия в FitMan фиксируется факт оказания услуги → данные передаются в 1С для учёта выручки и расчёта зарплаты тренера.
26.3 Архитектура и механизм обмена
26.3.1 Общая схема
Интеграция построена по принципу асинхронного обмена через очередь сообщений.
FitMan выступает инициатором событий, помещая задачи в очередь. Отдельный сервис (воркер) обрабатывает очередь и взаимодействует с веб-сервисом 1С через REST API.
FitMan → [Очередь задач] → Сервис синхронизации → [REST API] → 1С

26.3.2 Компоненты системы
1. Таблица конфигурации интеграции (integration_1c_config) – хранит настройки подключения к конкретному экземпляру 1С.
2. Очередь задач (integration_1c_queue) – хранит отложенные операции синхронизации.
3. Сервис-воркер – фоновый процесс, который:
o Забирает задачи из очереди.
o Формирует и отправляет запросы в 1С.
o Обрабатывает ответы, обновляет статусы задач, выполняет повторные попытки при ошибках.
4. REST API в 1С – набор веб-сервисов (HTTP-ендпоинтов), разработанных в конфигурации 1С для приёма и отправки данных.
26.3.3 Модель данных для обмена (Dart-модели)
dart
// Конфигурация подключения к 1С
class Integration1CConfig {
  String id;
  String baseUrl; // URL веб-сервиса 1С (например, https://1c.company.com/ws/fitman)
  String apiKey; // Ключ авторизации для доступа к API 1С
  SyncSettings syncSettings; // Настройки синхронизации
  List<EntityMapping> entityMappings; // Соответствие полей между системами
  bool isActive; // Включена ли интеграция
}

// Настройки синхронизации
class SyncSettings {
  bool autoSyncEnabled; // Автоматическая фоновая синхронизация
  Duration syncInterval; // Интервал (например, каждые 5 минут)
  List<String> syncEntities; // Какие сущности синхронизировать: ['client', 'payment', 'subscription']
  DateTime lastSuccessfulSync; // Время последней успешной синхронизации
}

// Соответствие полей сущности между FitMan и 1С
class EntityMapping {
  String fitmanEntity; // Название сущности в FitMan ('client')
  String externalCode; // Код соответствующей сущности в 1С
  Map<String, String> fieldMappings; // {'first_name': 'Имя', 'last_name': 'Фамилия'}
}
26.4 Техническая реализация
26.4.1 Структура таблиц в PostgreSQL
sql
-- Таблица конфигурации интеграции
CREATE TABLE integration_1c_config (
    id BIGSERIAL PRIMARY KEY,
    base_url VARCHAR(500) NOT NULL,
    api_key VARCHAR(500) NOT NULL,
    is_active BOOLEAN DEFAULT FALSE,
    sync_interval_minutes INTEGER DEFAULT 60,
    auto_sync_enabled BOOLEAN DEFAULT FALSE,
    last_successful_sync TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    company_id BIGINT DEFAULT -1
);

-- Очередь синхронизации
CREATE TABLE integration_1c_queue (
    id BIGSERIAL PRIMARY KEY,
    entity_type VARCHAR(50) NOT NULL, -- 'client', 'payment', 'subscription', 'visit'
    entity_id BIGINT NOT NULL, -- ID сущности в FitMan
    operation VARCHAR(20) NOT NULL, -- 'create', 'update', 'delete'
    payload JSONB NOT NULL, -- Данные сущности в формате JSON
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'processing', 'sent', 'error'
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    company_id BIGINT DEFAULT -1
);

-- Логи синхронизации (для аудита и отладки)
CREATE TABLE integration_1c_logs (
    id BIGSERIAL PRIMARY KEY,
    log_level VARCHAR(20) NOT NULL, -- 'info', 'warning', 'error'
    message TEXT NOT NULL,
    details JSONB, -- Дополнительные данные (например, тело запроса/ответа)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    company_id BIGINT DEFAULT -1
);
26.4.2 Сервис синхронизации (Dart)
dart
import 'dart:convert';
import 'package:http/http.dart' as http;

class Integration1CService {
  final HttpClient httpClient;
  final Integration1CConfig config;
  
  // Основной метод синхронизации (вызывается по расписанию или вручную)
  Future<SyncResult> syncData() async {
    try {
      // 1. Получаем pending-задачи из очереди
      final pendingItems = await _getPendingQueueItems();
      
      // 2. Группируем по типам сущностей для batch-отправки
      final groupedItems = _groupByEntityType(pendingItems);
      
      // 3. Отправляем пачки данных в 1С
      for (final entityType in groupedItems.keys) {
        await _sendBatchTo1C(entityType, groupedItems[entityType]!);
      }
      
      // 4. Опционально: запрашиваем обновления из 1С (если настроена двусторонняя синхронизация)
      if (config.syncSettings.syncDirection == 'bidirectional') {
        await _fetchUpdatesFrom1C();
      }
      
      await _logSyncSuccess();
      return SyncResult.success();
    } catch (e) {
      await _logSyncError(e);
      return SyncResult.error(e.toString());
    }
  }
  
  // Отправка пачки данных одного типа
  Future<void> _sendBatchTo1C(String entityType, List<QueueItem> items) async {
    final payload = {
      'entity_type': entityType,
      'items': items.map((item) => item.payload).toList(),
      'sync_timestamp': DateTime.now().toIso8601String(),
    };
    
    final response = await httpClient.post(
      Uri.parse('${config.baseUrl}/api/sync'),
      headers: {
        'Authorization': 'Bearer ${config.apiKey}',
        'Content-Type': 'application/json',
      },
      body: jsonEncode(payload),
    );
    
    if (response.statusCode == 200) {
      // Помечаем задачи как успешно отправленные
      await _markItemsAsSent(items);
    } else {
      // Обрабатываем ошибку (логируем, увеличиваем счётчик повторов)
      await _handleSyncError(items, response);
    }
  }
}
26.5 Интерфейс управления интеграцией
Интерфейс для администратора должен находиться в разделе «Администрирование» → «Интеграции» и включать:
1. Панель статуса:
o Статус подключения (✅/❌).
o Время последней успешной синхронизации.
o Количество неотправленных сообщений в очереди.
2. Настройки подключения:
o Поля для ввода URL веб-сервиса 1С, API-ключа.
o Переключатель «Интеграция активна».
o Выбор сущностей для синхронизации (чекбоксы: Клиенты, Платежи, Абонементы).
3. Управление синхронизацией:
o Кнопка «Синхронизировать сейчас» (ручной запуск).
o Переключатель «Автоматическая синхронизация» с настройкой интервала.
4. Мониторинг и логи:
o Таблица с последними операциями (статус, сущность, ошибка).
o Фильтры по дате, типу сущности, статусу.
o Кнопка «Экспорт логов».
26.6 Обработка ошибок и повторные попытки
Для обеспечения надёжности реализована стратегия повторных попыток (retry policy):
dart
class SyncErrorHandler {
  static const maxRetries = 3;
  static const retryDelays = [
    Duration(minutes: 1),
    Duration(minutes: 5),
    Duration(minutes: 15)
  ];
  
  Future<void> handleSyncError(QueueItem item, dynamic error) async {
    if (item.retryCount < maxRetries) {
      // Повторная попытка с увеличением задержки
      final delay = retryDelays[item.retryCount];
      await _rescheduleItem(item, delay);
      await _logWarning('Повторная попытка отправки ${item.entityType}#${item.entityId} через ${delay.inMinutes} мин.');
    } else {
      // Превышено максимальное число попыток - требуется вмешательство администратора
      await _notifyAdmin(
        'Критическая ошибка синхронизации',
        'Сущность: ${item.entityType}, ID: ${item.entityId}. Ошибка: ${error.toString()}'
      );
      await _markItemAsFailed(item, 'Превышено максимальное число попыток: $error');
    }
  }
}
26.7 Требования к API 1С
Со стороны 1С должен быть реализован REST API, поддерживающий как минимум следующие методы:
1. POST /api/sync – приём пачки данных от FitMan.
2. GET /api/sync/status – проверка доступности и статуса.
3. GET /api/clients/updates?since=... – получение обновлённых данных клиентов из 1С (для двусторонней синхронизации).
Формат запроса/ответа – JSON.
Обязательна авторизация по API-ключу в заголовке Authorization: Bearer <key>.
26.8 Рекомендации по внедрению
1. Этапность: Начать с синхронизации Клиентов и Платежей, затем добавить Абонементы и Посещения.
2. Тестирование: Перед включением в production выполнить тестовую синхронизацию с тестовой базой 1С.
3. Мониторинг: Настроить оповещения администратора при накоплении ошибок в очереди (>10 ошибок подряд).
4. Документация: Составить документ «Инструкция по настройке интеграции с 1С» для администраторов заказчика.


Нефункциональные требования


26 Требования к технологическому стеку
Технологический стек должен обеспечивать полную независимость от внешних BaaS-провайдеров, отсутствие контейнеризации, соответствие российским требованиям безопасности и возможность развертывания на собственной инфраструктуре заказчика.
26.1 Серверная часть
Backend Framework

**Основной стек:**
- **Язык:** Dart 3.0+
- **Фреймворк:** Dart Frog или Shelf
- **HTTP сервер:** Dart native (dart:io)
- **Реальное время:** WebSocket + Redis Pub/Sub

База данных
**Основная БД:** 
- **Система:** PostgreSQL 15+
- **Хостинг:** Отдельный сервер или VPS
- **Миграции:** Dart-пакет `moor` или собственные скрипты

**Расширения PostgreSQL:**
- pg_trgm - для полнотекстового поиска
- btree_gin - для составных индексов
- uuid-ossp - для генерации UUID

**Репликация:** 
- Настройка master-slave репликации
- Автоматические бэкапы

Кэширование и реальное время
**Redis сервер:**
- **Назначение:** Pub/Sub для реального времени, кэширование
- **Конфигурация:** Отдельный инстанс Redis 7+
- **Использование:**
  - WebSocket сообщения через Pub/Sub
  - Кэш сессий пользователей
  - Временное хранение токенов
  - Очереди задач
26.2 Клиентская часть
Мобильные приложения

**Фреймворк:** Flutter 3.0+
- **Язык:** Dart 3.0+
- **Состояние:** Riverpod 2.0
- **Навигация:** Go Router
- **Локальное хранилище:** Hive 2.0

**Поддерживаемые платформы:**
- Android 8.0+ (API 26+)
- iOS 13.0+
- **Сборка:** Ручная компиляция APK/IPA

Веб-приложение

**Фреймворк:** Flutter Web
- **Режим сборки:** CanvasKit для производительности
- **Роутинг:** Browser history API
- **PWA:** Service Worker для оффлайн-работы

**Хостинг:** 
- Статические файлы на nginx
- NAS хранилище для медиа-файлов
26.3 Инфраструктура
Серверное окружение
**Операционная система:**
- **Основная:** Ubuntu 22.04 LTS
- **Альтернативная:** Debian 11+

**Веб-сервер:**
- **Прокси:** Nginx 1.20+
- **SSL:** Let's Encrypt или коммерческий сертификат
- **Балансировка:** На уровне nginx (при масштабировании)

**Управление процессами:**
- **Инит-система:** Systemd
- **Логирование:** Journald + ротация логов
- **Мониторинг:** Prometheus + Grafana (опционально)

Файловое хранилище
**Локальное хранилище:**
- **Структура:** 
  `/opt/fitman/storage/`
  ├── uploads/     # Пользовательские файлы
  ├── avatars/     # Фотографии профилей
  ├── documents/   # Сканы документов
  └── backups/     # Резервные копии

26.4 Установка и развертывание
Способ дистрибуции
**Серверная часть:**
- **Формат:** Самодостаточный инсталлятор (.run)
- **Содержимое:** 
  - Бинарные файлы Dart приложения
  - Скрипты установки PostgreSQL/Redis
  - Конфигурационные файлы nginx
  - Systemd unit files

**Мобильные приложения:**
- **Android:** APK файлы для скачивания с сайта
- **iOS:** TestFlight для тестирования, App Store для продакшена
26.5 Процесс установки
bash
# Пример установочного скрипта
#!/bin/bash
# fitman-installer.run

echo "Установка Фитнес-Менеджера..."

# Автоматическая установка зависимостей
apt-get install -y postgresql postgresql-contrib redis-server nginx

# Настройка БД
sudo -u postgres psql -c "CREATE USER fitman_user WITH PASSWORD '${DB_PASSWORD}';"
sudo -u postgres psql -c "CREATE DATABASE fitman OWNER fitman_user;"

# Развертывание приложения
cp -r application /opt/fitman/
chown -R www-data:www-data /opt/fitman

# Запуск сервисов
systemctl enable fitman.service
systemctl start fitman.service
26.6 Безопасность
Аутентификация и авторизация
**Механизм аутентификации:**
- **Токены:** JWT (JSON Web Tokens)
- **Алгоритм:** HS256 или RS256
- **Время жизни:** Access token - 24 часа, Refresh token - 7 дней

**Защита API:**
- **HTTPS:** Обязательно для всех endpoints
- **CORS:** Настройка для доменов клиента
- **Rate Limiting:** Ограничение запросов по IP/пользователю
26.7 Защита данных
**Шифрование:**
- **Пароли:** bcrypt с salt rounds = 12
- **Чувствительные данные:** AES-256 в базе данных
- **Транспорт:** TLS 1.3 для всех соединений

**Резервное копирование:**
- **Частота:** Ежедневные полные бэкапы
- **Хранение:** Отдельный защищенный сервер
- **Шифрование:** GPG для резервных копий
26.8 Мониторинг и логирование
Система мониторинга
**Встроенные метрики:**
- Нагрузка CPU, памяти, диска
- Количество активных пользователей
- Время ответа API endpoints
- Статус WebSocket соединений

**Внешний мониторинг:**
- **Доступность:** Zabbix или UptimeKuma или UptimeRobot
- **Логи:** Centralized logging через rsyslog
- **Оповещения:** Telegram bot для критических ошибок

Логирование
dart
// Пример системы логирования
class AppLogger {
  static final Logger _logger = Logger();
  
  static void setupLogging() {
    Logger.root.level = Level.INFO;
    Logger.root.onRecord.listen((record) {
      // Запись в файл с ротацией
      _writeToFile(record);
      // Отправка в syslog для критических ошибок
      if (record.level >= Level.SEVERE) {
        _sendToSyslog(record);
      }
    });
  }
}
26.9 Производительность и масштабирование
Оптимизация базы данных
sql
-- Пример индексов для производительности
CREATE INDEX CONCURRENTLY idx_users_email ON users(email);
CREATE INDEX CONCURRENTLY idx_chats_company ON chats(company_id);
CREATE INDEX CONCURRENTLY idx_messages_chat_date ON messages(chat_id, created_at DESC);

-- Частичные индексы для архивных данных
CREATE INDEX idx_active_users ON users(id) WHERE archived_at IS NULL;

Стратегия масштабирования
**Вертикальное масштабирование:**
- Увеличение ресурсов VPS (CPU, RAM, SSD)
- Настройка репликации PostgreSQL
- Кэширование часто запрашиваемых данных

**Горизонтальное масштабирование (при росте):**
- Добавление application-серверов
- Балансировка нагрузки через nginx
- Шардирование базы данных
26.10 Резервные копии и восстановление
Процедуры бэкапа
**Автоматические бэкапы:**
- **База данных:** pg_dump ежедневно в 02:00
- **Файлы приложения:** rsync раз в неделю
- **Конфигурации:** Git-репозиторий с историей изменений

**Восстановление:**
- Скрипт автоматического восстановления из бэкапа
- Пошаговые инструкции для ручного восстановления
- Регулярные тесты восстановления


27 Требования к таблицам
База данных системы – PostgreSQL.
• В каждой таблице должно быть поле id (BIGSERIAL) с primary key.
Имена foreign key полей должны соответствовать шаблону: <имя_таблицы_в_единственном_числе>_id.
• В каждой таблице должно быть поле company_id (BIGINT) для мультитенантности. По умолчанию равно -1.
• Индексы должны быть добавлены на все поля, используемые в условиях JOIN и WHERE, в частности, на все foreign key поля.
• Имена и поля таблиц должны быть в snake_case нотации.
• Способ удаления записей -- логическая архивация: заполняются поля archived_at, archived_by. Физический DELETE запрещён.
• Поле для фото – тип URL, ссылка на файл с фото в хранилище
• Не использовать встроенный тип ENUM. Вместо него использовать SMALLINT, в нем значение enum в коде. 
• Не использовать строковый тип как перечисления. Вместо него использовать SMALLINT, в нем значение enum в коде.
• Тип дата/время должен быть timestamp with time zone.
• Для оперативного аудита, все таблицы должны иметь поля:
• "Дата Создания" (created_at (TIMESTAMP)) 
• "Дата Изменения" (updated_at (TIMESTAMP))
• "Создан пользователем" (created_by (BIGINT FK → users(id)))
• "Изменен пользователем" (updated_by (BIGINT FK → users(id))).
Поля created_at, created_by, необходимо учитывать при добавлении записи. Поля updated_at, updated_by, необходимо учитывать при обновлении запросов.
• Для архивации и восстановления записей, все таблицы должны включать поля:
• archived_at (TIMESTAMP NULL)
• archived_by (BIGINT FK → users(id))

28 Требования к логированию приложения
Логирование должно осуществляться средствами технологического стека. Логирование должно иметь 4 уровня важности сообщения: отладочное, информационное, предупреждение, ошибка. Максимальный уровень, по которому сообщения будут записываться, записывается в файл настроек приложения. Сообщения должны записываться в суточный файл формата "EFT_YYYY_MM_DD", где YYYY_MM_DD – год, месяц и день. Сообщение, кроме отладочного, должно выводиться на экран.


29 Требования к безопасности
Данный раздел описывает меры, направленные на обеспечение конфиденциальности, целостности и доступности данных системы, а также на защиту от несанкционированного доступа.
29.1 Аутентификация и авторизация
• Многофакторная аутентификация (MFA). Система должна предоставлять возможность включения MFA для ролей Администратор, Менеджер и Тренер.
• Политика паролей. Пароли пользователей должны храниться в базе данных исключительно в виде хешей с использованием современных алгоритмов (например, bcrypt/scrypt/Argon2).
• Минимальная длина пароля — 8 символов.
• Пароль должен содержать как минимум одну заглавную букву, одну строчную букву, одну цифру и один специальный символ.
• Запрещено использовать простые или скомпрометированные пароли.
• Защита от brute-force. Система должна блокировать учетную запись или вводить задержку после 5 неуспешных попыток ввода пароля в течение 15 минут.
• JWT Tokens. Время жизни Access Token должно быть ограничено (например, 15-30 минут).
• Обязательно использование Refresh Tokens с ограниченным временем жизни (например, 7 дней) и механизмом их отзыва.
• Tokens должны быть подписаны с использованием надежного алгоритма (например, RS256).
• Управление сессиями. При выходе из системы или по истечении времени неактивности (30 минут) сессия пользователя должна быть полностью завершена на стороне клиента и сервера.

29.2 Контроль доступа (Authorization)
• Принцип наименьших привилегий. Каждая роль в системе должна иметь доступ только к тем данным и функциям, которые абсолютно необходимы для выполнения ее задач.
• Row Level Security (RLS)  Для базы данных PostgreSQL  **обязательно** должна быть настроена политика RLS на всех таблицах, содержащих персональные или бизнес-данные. Доступ к данным должен предоставляться на основе роли пользователя и его идентификатора.
• Валидация на стороне сервера. Все запросы к API, включая проверки прав доступа к объектам, должны быть валидированы на стороне бэкенда. Недостаточно проверять права только на фронтенде.

29.3 Защита данных
• Все данные должны передаваться по защищенному протоколу **HTTPS/TLS 1.2+**.
• Чувствительные данные (например, пароли, персональные данные клиентов) должны шифроваться при хранении в базе данных или использовать механизмы шифрования.
• Маскирование данных. При отображении конфиденциальной информации (например, телефона, email) в интерфейсах для некоторых ролей следует применять маскирование (например, `+7 *** *** ** 12`).
• Безопасное хранение секретов. Ключи API, секреты для подписи JWT, учетные данные для внешних сервисов (SMS-шлюз) не должны храниться в коде или репозитории. Необходимо использовать защищенные механизмы хранения секретов.
• Доступ к архивным записям возможен только роли «Администратор». Остальные роли видят только активные записи (RLS-политика archived_at IS NULL).
29.4 Безопасность API
• Защита от перебора (Rate Limiting).  API должен быть защищен от DDoS-атак и перебора паролей путем ограничения количества запросов с одного IP-адреса или для одной учетной записи в единицу времени.
• Валидация входных данных. Все входные данные, поступающие в API (параметры запросов, тела запросов), должны быть строго валидированы на предмет типа, длины, диапазона и наличия потенциально опасных конструкций (SQL-инъекции, XSS).

29.5 Защита на клиенте (Frontend).
• Защита от XSS. Данные, предоставляемые пользователями (например, комментарии, имена), должны быть экранированы перед отображением в интерфейсе для предотвращения межсайтового скриптинга.
• Безопасные заголовки HTTP. Приложение должно использовать security headers (например, Content-Security-Policy, X-Frame-Options, X-Content-Type-Options) для защиты от различных видов атак.

29.6 Аудит и мониторинг
• Логирование событий безопасности. В логи приложения должны записываться все критичные события:
• Неудачные попытки входа в систему.
• Попытки доступа к запрещенным ресурсам (ошибки 403).
• Изменение критичных настроек системы, прав пользователей.
• Создание, изменение и удаление учетных записей пользователей.
• Мониторинг. Система должна иметь возможность мониторинга подозрительной активности, с уведомлением ответственных лиц (Администратор).

29.7 Резервное копирование и восстановление
• Регулярное резервное копирование. Должна быть обеспечена процедура регулярного (ежедневного) резервного копирования базы данных и критичных файлов.
• План восстановления. Должен быть документирован и протестирован план восстановления работы системы после сбоя в течение не более 4 часов.



30 Требования к тестированию
• Реализовать юнит-тесты по всем командам.
• Реализовать интеграционные тесты по каждой роли.


31 Дополнительные требования
31.1 Добавить диаграмму БД.
• ER-диаграмму отношений между таблицами
• Схему связей и индексов

31.2 Уточнить API endpoints.
• REST API методы для каждого модуля
• Форматы запросов/ответов

Архитектурные требования
32 Редакции продукта
32.1 Редакция Basic
Эта редакция является текущей.
Основной функционал:
• Для будущей мультитенантности вводится поле company_id во все таблицы.
• Система лицензий и ограничений.
• Весь функционал в Basic-качестве.
Для: малых фитнес-залов, студий, персональных тренеров
Ограничения: 1 филиал, до 100 клиентов, до 3 тренеров

32.2 Редакция Pro
Основной функционал:
• Мультитенантная архитектура.
• Расширенная аналитика.
• White-label.
• API для интеграций.
Для: средних клубов, сетей в одном городе, мультибрендовых операторов
Ограничения: мультитенантность, до 500 клиентов, до 10 тренеров

32.3 Редакция Enterprise
Основной функционал:
• Филиальная и мультитенантная архитектура.
• Корпоративная отчетность.
• Сложные интеграции.
Для: федеральных сетей, крупных клубов с филиалами
Ограничения: неограниченно, филиальная структура


Архитектура с учетом трех версий
Базовая версия:
  - Единая база данных
  - Простая схема tenant_id = 1
  - Ограничения через application logic

Pro версия:
  - Schema-based мультитенантность
  - Отдельные схемы для каждого tenant
  - Общие справочники

Enterprise версия:
  - База данных на филиал + общая сводная
  - Репликация между филиалами
  - Единый каталог пользователей


Глоссарий

• Списочная форма – виджет-экран со списочным представлением (ListView).
• Карточка – виджет-экран с детальным представлением (DetailView).
• Дашборд – виджет-экран с вложенными виджетами.
• Фрейм – виджет-контейнер для группировки других виджетов.
• BMR - Basal Metabolic Rate (Основной обмен веществ).
• Дефицит/профицит калорий - разница между потребленными и затраченными калориями.
• Мультитенантность - архитектура для работы с несколькими независимыми клиентами в одной системе
• Филиальность - иерархическая структура подразделений с единым управлением



75


